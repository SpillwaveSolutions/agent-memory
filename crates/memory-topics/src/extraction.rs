//! Topic extraction using HDBSCAN clustering.

use hdbscan::{Hdbscan, HdbscanHyperParams};
use tracing::{debug, info};
use ulid::Ulid;

use crate::config::ExtractionConfig;
use crate::error::TopicsError;
use crate::labeling::{ClusterDocument, TopicLabel, TopicLabeler};
use crate::similarity::calculate_centroid;
use crate::types::Topic;

/// Input for topic extraction: node ID with its embedding.
#[derive(Debug, Clone)]
pub struct NodeEmbedding {
    /// TOC node identifier
    pub node_id: String,
    /// Embedding vector
    pub embedding: Vec<f32>,
    /// Summary text (for keyword extraction)
    pub summary: String,
}

/// Result of clustering: cluster ID to node IDs.
#[derive(Debug)]
pub struct ClusterResult {
    /// Cluster label (-1 = noise)
    pub label: i32,
    /// Node IDs in this cluster
    pub node_ids: Vec<String>,
    /// Node embeddings in this cluster
    pub embeddings: Vec<Vec<f32>>,
    /// Summaries for keyword extraction
    pub summaries: Vec<String>,
}

/// Topic extractor using HDBSCAN clustering.
pub struct TopicExtractor {
    config: ExtractionConfig,
}

impl TopicExtractor {
    /// Create a new topic extractor.
    pub fn new(config: ExtractionConfig) -> Self {
        Self { config }
    }

    /// Cluster embeddings using HDBSCAN.
    ///
    /// Returns clusters grouped by label. Label -1 indicates noise points.
    pub fn cluster(&self, nodes: &[NodeEmbedding]) -> Result<Vec<ClusterResult>, TopicsError> {
        if nodes.len() < self.config.min_cluster_size {
            debug!(
                count = nodes.len(),
                min = self.config.min_cluster_size,
                "Not enough nodes for clustering"
            );
            return Ok(vec![]);
        }

        info!(count = nodes.len(), "Starting HDBSCAN clustering");

        // Convert to 2D array format expected by hdbscan (f64)
        let data: Vec<Vec<f64>> = nodes
            .iter()
            .map(|n| n.embedding.iter().map(|&x| x as f64).collect())
            .collect();

        // Create clusterer with custom params
        let params = HdbscanHyperParams::builder()
            .min_cluster_size(self.config.min_cluster_size)
            .build();

        let clusterer = Hdbscan::new(&data, params);

        // Run clustering (blocking - should be called from spawn_blocking)
        let labels = clusterer
            .cluster()
            .map_err(|e| TopicsError::Clustering(e.to_string()))?;

        info!(
            labels = labels.len(),
            unique = count_unique_clusters(&labels),
            "Clustering complete"
        );

        // Group nodes by cluster label
        let clusters = group_by_cluster(nodes, &labels);

        Ok(clusters)
    }

    /// Create topics from cluster results.
    ///
    /// Each cluster becomes a topic with a centroid embedding.
    pub fn create_topics(&self, clusters: &[ClusterResult]) -> Vec<Topic> {
        clusters
            .iter()
            .filter(|c| c.label >= 0) // Skip noise
            .map(|cluster| {
                let topic_id = Ulid::new().to_string();

                // Calculate centroid
                let embedding_refs: Vec<&[f32]> =
                    cluster.embeddings.iter().map(|e| e.as_slice()).collect();
                let centroid = calculate_centroid(&embedding_refs);

                // Create topic with placeholder label (labeling is Plan 14-02)
                let mut topic = Topic::new(
                    topic_id,
                    format!("Topic {}", cluster.label), // Placeholder
                    centroid,
                );
                topic.node_count = cluster.node_ids.len() as u32;

                topic
            })
            .collect()
    }

    /// Get configuration.
    pub fn config(&self) -> &ExtractionConfig {
        &self.config
    }

    /// Create topics from cluster results with labeling.
    ///
    /// Each cluster becomes a topic with a centroid embedding and a label
    /// generated by the provided labeler.
    pub fn create_labeled_topics(
        &self,
        clusters: &[ClusterResult],
        labeler: &dyn TopicLabeler,
    ) -> Result<Vec<Topic>, TopicsError> {
        let mut topics = Vec::new();

        for cluster in clusters.iter().filter(|c| c.label >= 0) {
            let topic_id = Ulid::new().to_string();

            // Calculate centroid
            let embedding_refs: Vec<&[f32]> =
                cluster.embeddings.iter().map(|e| e.as_slice()).collect();
            let centroid = calculate_centroid(&embedding_refs);

            // Create cluster documents for labeling
            let documents: Vec<ClusterDocument> = cluster
                .node_ids
                .iter()
                .zip(cluster.summaries.iter())
                .map(|(id, summary)| ClusterDocument::new(id.clone(), summary.clone()))
                .collect();

            // Generate label using the labeler
            let TopicLabel {
                label,
                keywords,
                confidence: _,
            } = labeler.label_cluster(&documents)?;

            // Create topic with generated label
            let mut topic = Topic::new(topic_id, label, centroid);
            topic.node_count = cluster.node_ids.len() as u32;
            topic.keywords = keywords;

            topics.push(topic);
        }

        Ok(topics)
    }
}

/// Count unique non-noise clusters.
fn count_unique_clusters(labels: &[i32]) -> usize {
    let mut unique: std::collections::HashSet<i32> = labels.iter().copied().collect();
    unique.remove(&-1); // Remove noise label
    unique.len()
}

/// Group nodes by cluster label.
fn group_by_cluster(nodes: &[NodeEmbedding], labels: &[i32]) -> Vec<ClusterResult> {
    use std::collections::HashMap;

    let mut groups: HashMap<i32, ClusterResult> = HashMap::new();

    for (node, &label) in nodes.iter().zip(labels.iter()) {
        let cluster = groups.entry(label).or_insert_with(|| ClusterResult {
            label,
            node_ids: Vec::new(),
            embeddings: Vec::new(),
            summaries: Vec::new(),
        });
        cluster.node_ids.push(node.node_id.clone());
        cluster.embeddings.push(node.embedding.clone());
        cluster.summaries.push(node.summary.clone());
    }

    groups.into_values().collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    fn make_node(id: &str, embedding: Vec<f32>) -> NodeEmbedding {
        NodeEmbedding {
            node_id: id.to_string(),
            embedding,
            summary: format!("Summary for {}", id),
        }
    }

    #[test]
    fn test_cluster_insufficient_nodes() {
        let config = ExtractionConfig {
            min_cluster_size: 5,
            ..Default::default()
        };
        let extractor = TopicExtractor::new(config);

        let nodes = vec![
            make_node("n1", vec![1.0, 0.0, 0.0]),
            make_node("n2", vec![0.0, 1.0, 0.0]),
        ];

        let result = extractor.cluster(&nodes).unwrap();
        assert!(result.is_empty());
    }

    #[test]
    fn test_count_unique_clusters() {
        let labels = vec![0, 0, 1, 1, -1, 2, -1];
        assert_eq!(count_unique_clusters(&labels), 3); // 0, 1, 2
    }

    #[test]
    fn test_count_unique_clusters_all_noise() {
        let labels = vec![-1, -1, -1];
        assert_eq!(count_unique_clusters(&labels), 0);
    }

    #[test]
    fn test_count_unique_clusters_empty() {
        let labels: Vec<i32> = vec![];
        assert_eq!(count_unique_clusters(&labels), 0);
    }

    #[test]
    fn test_group_by_cluster() {
        let nodes = vec![
            make_node("n1", vec![1.0]),
            make_node("n2", vec![2.0]),
            make_node("n3", vec![3.0]),
        ];
        let labels = vec![0, 0, 1];

        let groups = group_by_cluster(&nodes, &labels);
        assert_eq!(groups.len(), 2);

        let cluster_0 = groups.iter().find(|c| c.label == 0).unwrap();
        assert_eq!(cluster_0.node_ids.len(), 2);

        let cluster_1 = groups.iter().find(|c| c.label == 1).unwrap();
        assert_eq!(cluster_1.node_ids.len(), 1);
    }

    #[test]
    fn test_group_by_cluster_with_noise() {
        let nodes = vec![
            make_node("n1", vec![1.0]),
            make_node("n2", vec![2.0]),
            make_node("n3", vec![3.0]),
        ];
        let labels = vec![0, -1, 0];

        let groups = group_by_cluster(&nodes, &labels);
        assert_eq!(groups.len(), 2); // cluster 0 and noise (-1)

        let noise = groups.iter().find(|c| c.label == -1).unwrap();
        assert_eq!(noise.node_ids.len(), 1);
        assert_eq!(noise.node_ids[0], "n2");
    }

    #[test]
    fn test_create_topics_skips_noise() {
        let config = ExtractionConfig::default();
        let extractor = TopicExtractor::new(config);

        let clusters = vec![
            ClusterResult {
                label: -1, // Noise
                node_ids: vec!["n1".to_string()],
                embeddings: vec![vec![1.0, 0.0]],
                summaries: vec!["Summary".to_string()],
            },
            ClusterResult {
                label: 0,
                node_ids: vec!["n2".to_string(), "n3".to_string()],
                embeddings: vec![vec![1.0, 0.0], vec![0.0, 1.0]],
                summaries: vec!["Sum1".to_string(), "Sum2".to_string()],
            },
        ];

        let topics = extractor.create_topics(&clusters);
        assert_eq!(topics.len(), 1); // Only non-noise cluster
        assert_eq!(topics[0].node_count, 2);
    }

    #[test]
    fn test_create_topics_generates_ulid() {
        let config = ExtractionConfig::default();
        let extractor = TopicExtractor::new(config);

        let clusters = vec![ClusterResult {
            label: 0,
            node_ids: vec!["n1".to_string()],
            embeddings: vec![vec![1.0, 0.0]],
            summaries: vec!["Summary".to_string()],
        }];

        let topics = extractor.create_topics(&clusters);
        assert_eq!(topics.len(), 1);
        // ULID is 26 characters
        assert_eq!(topics[0].topic_id.len(), 26);
    }

    #[test]
    fn test_create_topics_empty_clusters() {
        let config = ExtractionConfig::default();
        let extractor = TopicExtractor::new(config);

        let clusters: Vec<ClusterResult> = vec![];
        let topics = extractor.create_topics(&clusters);
        assert!(topics.is_empty());
    }

    #[test]
    fn test_extractor_config() {
        let config = ExtractionConfig {
            min_cluster_size: 10,
            similarity_threshold: 0.9,
            ..Default::default()
        };
        let extractor = TopicExtractor::new(config);

        assert_eq!(extractor.config().min_cluster_size, 10);
        assert!((extractor.config().similarity_threshold - 0.9).abs() < f32::EPSILON);
    }

    #[test]
    fn test_create_labeled_topics() {
        use crate::config::LabelingConfig;
        use crate::labeling::KeywordLabeler;

        let config = ExtractionConfig::default();
        let extractor = TopicExtractor::new(config);
        let labeler = KeywordLabeler::new(LabelingConfig::default());

        let clusters = vec![ClusterResult {
            label: 0,
            node_ids: vec!["n1".to_string(), "n2".to_string()],
            embeddings: vec![vec![1.0, 0.0], vec![0.0, 1.0]],
            summaries: vec![
                "rust programming systems memory".to_string(),
                "rust ownership borrowing safety".to_string(),
            ],
        }];

        let topics = extractor
            .create_labeled_topics(&clusters, &labeler)
            .unwrap();
        assert_eq!(topics.len(), 1);
        assert!(!topics[0].label.is_empty());
        assert!(!topics[0].keywords.is_empty());
        assert_eq!(topics[0].node_count, 2);
    }

    #[test]
    fn test_create_labeled_topics_skips_noise() {
        use crate::config::LabelingConfig;
        use crate::labeling::KeywordLabeler;

        let config = ExtractionConfig::default();
        let extractor = TopicExtractor::new(config);
        let labeler = KeywordLabeler::new(LabelingConfig::default());

        let clusters = vec![
            ClusterResult {
                label: -1, // Noise - should be skipped
                node_ids: vec!["noise".to_string()],
                embeddings: vec![vec![1.0, 0.0]],
                summaries: vec!["noise summary".to_string()],
            },
            ClusterResult {
                label: 0,
                node_ids: vec!["valid".to_string()],
                embeddings: vec![vec![0.0, 1.0]],
                summaries: vec!["valid summary content".to_string()],
            },
        ];

        let topics = extractor
            .create_labeled_topics(&clusters, &labeler)
            .unwrap();
        assert_eq!(topics.len(), 1); // Only non-noise cluster
    }

    #[test]
    fn test_create_labeled_topics_empty() {
        use crate::config::LabelingConfig;
        use crate::labeling::KeywordLabeler;

        let config = ExtractionConfig::default();
        let extractor = TopicExtractor::new(config);
        let labeler = KeywordLabeler::new(LabelingConfig::default());

        let clusters: Vec<ClusterResult> = vec![];
        let topics = extractor
            .create_labeled_topics(&clusters, &labeler)
            .unwrap();
        assert!(topics.is_empty());
    }
}
