---
phase: 12-vector-teleport-hnsw
plan: 03
type: execute
wave: 3
depends_on: [12-01, 12-02]
files_modified:
  - proto/memory.proto
  - crates/memory-service/Cargo.toml
  - crates/memory-service/src/lib.rs
  - crates/memory-service/src/vector.rs
  - crates/memory-service/src/hybrid.rs
autonomous: true

must_haves:
  truths:
    - "VectorTeleport RPC accepts query and returns ranked matches"
    - "HybridSearch RPC combines BM25 and vector scores using RRF"
    - "GetVectorIndexStatus RPC returns index availability and stats"
    - "Scores are normalized to [0, 1] range for client consumption"
  artifacts:
    - path: "proto/memory.proto"
      provides: "Vector RPC definitions"
      contains: "VectorTeleport"
    - path: "crates/memory-service/src/vector.rs"
      provides: "VectorTeleport implementation"
      exports: ["VectorTeleportHandler"]
    - path: "crates/memory-service/src/hybrid.rs"
      provides: "Hybrid search implementation"
      exports: ["HybridSearchHandler", "RrfFusion"]
  key_links:
    - from: "crates/memory-service/src/vector.rs"
      to: "memory-vector::HnswIndex"
      via: "searches vector index"
      pattern: "hnsw_index.search"
    - from: "crates/memory-service/src/vector.rs"
      to: "memory-embeddings::CandleEmbedder"
      via: "embeds query text"
      pattern: "embedder.embed"
    - from: "crates/memory-service/src/hybrid.rs"
      to: "memory-search"
      via: "calls BM25 search for fusion"
      pattern: "search_index.search"
---

<objective>
Add gRPC RPCs for vector search and hybrid BM25+vector fusion.

Purpose: Expose vector search capabilities to agents via gRPC. VectorTeleport enables semantic similarity search. HybridSearch combines BM25 keywords with vector semantics for best-of-both-worlds retrieval.

Output: VectorTeleport, HybridSearch, and GetVectorIndexStatus RPCs added to memory-service.
</objective>

<execution_context>
@/Users/richardhightower/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardhightower/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/12-vector-teleport-hnsw/12-RESEARCH.md
@.planning/phases/12-vector-teleport-hnsw/12-01-SUMMARY.md
@.planning/phases/12-vector-teleport-hnsw/12-02-SUMMARY.md
@proto/memory.proto
@crates/memory-service/src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Vector RPC definitions to proto</name>
  <files>
    proto/memory.proto
  </files>
  <action>
Add vector search RPC definitions to proto/memory.proto:

1. Add new RPC methods to MemoryService:
   ```protobuf
   // Vector semantic search
   rpc VectorTeleport(VectorTeleportRequest) returns (VectorTeleportResponse);

   // Hybrid BM25 + vector search
   rpc HybridSearch(HybridSearchRequest) returns (HybridSearchResponse);

   // Get vector index status
   rpc GetVectorIndexStatus(GetVectorIndexStatusRequest) returns (VectorIndexStatus);
   ```

2. Add target type enum:
   ```protobuf
   enum VectorTargetType {
     VECTOR_TARGET_TYPE_UNSPECIFIED = 0;
     VECTOR_TARGET_TYPE_TOC_NODE = 1;
     VECTOR_TARGET_TYPE_GRIP = 2;
     VECTOR_TARGET_TYPE_ALL = 3;
   }
   ```

3. Add VectorTeleport messages:
   ```protobuf
   message VectorTeleportRequest {
     string query = 1;              // Query text to embed and search
     int32 top_k = 2;               // Max results (default: 10)
     float min_score = 3;           // Min similarity 0.0-1.0 (default: 0.0)
     TimeRange time_filter = 4;     // Optional time range filter
     VectorTargetType target = 5;   // Target type filter
   }

   message VectorMatch {
     string doc_id = 1;             // node_id or grip_id
     string doc_type = 2;           // "toc_node" or "grip"
     float score = 3;               // Similarity 0.0-1.0
     string text_preview = 4;       // Preview of matched text
     int64 timestamp_ms = 5;        // Document timestamp
   }

   message VectorTeleportResponse {
     repeated VectorMatch matches = 1;
     VectorIndexStatus index_status = 2;
   }
   ```

4. Add HybridSearch messages:
   ```protobuf
   enum HybridMode {
     HYBRID_MODE_UNSPECIFIED = 0;
     HYBRID_MODE_VECTOR_ONLY = 1;
     HYBRID_MODE_BM25_ONLY = 2;
     HYBRID_MODE_HYBRID = 3;
   }

   message HybridSearchRequest {
     string query = 1;
     int32 top_k = 2;               // Max results (default: 10)
     HybridMode mode = 3;           // Search mode
     float bm25_weight = 4;         // Weight for BM25 (default: 0.5)
     float vector_weight = 5;       // Weight for vector (default: 0.5)
     TimeRange time_filter = 6;     // Optional time range filter
     VectorTargetType target = 7;   // Target type filter
   }

   message HybridSearchResponse {
     repeated VectorMatch matches = 1;
     HybridMode mode_used = 2;      // Actual mode used
     bool bm25_available = 3;       // BM25 index status
     bool vector_available = 4;     // Vector index status
   }
   ```

5. Add VectorIndexStatus messages:
   ```protobuf
   message GetVectorIndexStatusRequest {}

   message VectorIndexStatus {
     bool available = 1;            // Ready for search
     int64 vector_count = 2;        // Vectors in index
     int32 dimension = 3;           // Embedding dimension
     string last_indexed = 4;       // Last index timestamp (RFC3339)
     string index_path = 5;         // Index file path
     int64 size_bytes = 6;          // Index size
   }
   ```

6. Add TimeRange if not present:
   ```protobuf
   message TimeRange {
     int64 start_ms = 1;            // Start time (inclusive)
     int64 end_ms = 2;              // End time (exclusive)
   }
   ```
  </action>
  <verify>
    cd /Users/richardhightower/clients/spillwave/src/agent-memory && cargo build -p memory-service
  </verify>
  <done>
    Proto compiles. VectorTeleport, HybridSearch, GetVectorIndexStatus RPCs defined with all messages.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement VectorTeleport RPC handler</name>
  <files>
    crates/memory-service/Cargo.toml
    crates/memory-service/src/vector.rs
    crates/memory-service/src/lib.rs
  </files>
  <action>
Implement the VectorTeleport RPC handler:

1. Update `crates/memory-service/Cargo.toml`:
   - Add: memory-embeddings = { workspace = true }
   - Add: memory-vector = { workspace = true }
   - Add: parking_lot = { workspace = true } (for RwLock)

2. Create `crates/memory-service/src/vector.rs`:
   ```rust
   //! VectorTeleport RPC implementation.

   use std::sync::Arc;
   use parking_lot::RwLock;
   use tonic::{Request, Response, Status};
   use tracing::{debug, info};

   use memory_embeddings::{CandleEmbedder, EmbeddingModel};
   use memory_vector::{HnswIndex, VectorIndex, VectorMetadata, DocType};

   use crate::proto::{
       VectorTeleportRequest, VectorTeleportResponse, VectorMatch,
       VectorIndexStatus, VectorTargetType, GetVectorIndexStatusRequest,
   };

   pub struct VectorTeleportHandler {
       embedder: Arc<CandleEmbedder>,
       index: Arc<RwLock<HnswIndex>>,
       metadata: Arc<VectorMetadata>,
   }

   impl VectorTeleportHandler {
       pub fn new(
           embedder: Arc<CandleEmbedder>,
           index: Arc<RwLock<HnswIndex>>,
           metadata: Arc<VectorMetadata>,
       ) -> Self {
           Self { embedder, index, metadata }
       }

       pub fn is_available(&self) -> bool {
           self.index.read().len() > 0
       }

       pub fn get_status(&self) -> VectorIndexStatus {
           let index = self.index.read();
           let stats = index.stats();
           VectorIndexStatus {
               available: stats.available && stats.vector_count > 0,
               vector_count: stats.vector_count as i64,
               dimension: stats.dimension as i32,
               last_indexed: String::new(),
               index_path: index.index_file().to_string_lossy().to_string(),
               size_bytes: stats.size_bytes as i64,
           }
       }

       pub async fn vector_teleport(
           &self,
           request: Request<VectorTeleportRequest>,
       ) -> Result<Response<VectorTeleportResponse>, Status> {
           let req = request.into_inner();
           let query = &req.query;
           let top_k = if req.top_k > 0 { req.top_k as usize } else { 10 };
           let min_score = req.min_score;

           debug!(query = %query, top_k = top_k, "VectorTeleport request");

           let status = self.get_status();
           if !status.available {
               return Ok(Response::new(VectorTeleportResponse {
                   matches: vec![],
                   index_status: Some(status),
               }));
           }

           // Embed query (use spawn_blocking for CPU work)
           let embedder = self.embedder.clone();
           let query_owned = query.to_string();
           let embedding = tokio::task::spawn_blocking(move || {
               embedder.embed(&query_owned)
           }).await
               .map_err(|e| Status::internal(format!("Task error: {}", e)))?
               .map_err(|e| Status::internal(format!("Embedding failed: {}", e)))?;

           // Search index
           let index = self.index.read();
           let results = index.search(&embedding, top_k)
               .map_err(|e| Status::internal(format!("Search failed: {}", e)))?;

           // Convert to matches with metadata
           let mut matches = Vec::new();
           for result in results {
               if result.score < min_score { continue; }

               if let Ok(Some(entry)) = self.metadata.get(result.vector_id) {
                   // Target type filter
                   if !self.matches_target(req.target, entry.doc_type) { continue; }

                   // Time filter
                   if let Some(ref tf) = req.time_filter {
                       if entry.created_at < tf.start_ms || entry.created_at >= tf.end_ms {
                           continue;
                       }
                   }

                   matches.push(VectorMatch {
                       doc_id: entry.doc_id,
                       doc_type: entry.doc_type.as_str().to_string(),
                       score: result.score,
                       text_preview: entry.text_preview,
                       timestamp_ms: entry.created_at,
                   });
               }
           }

           info!(query = %query, results = matches.len(), "VectorTeleport complete");

           Ok(Response::new(VectorTeleportResponse {
               matches,
               index_status: Some(status),
           }))
       }

       pub async fn get_vector_index_status(
           &self,
           _request: Request<GetVectorIndexStatusRequest>,
       ) -> Result<Response<VectorIndexStatus>, Status> {
           Ok(Response::new(self.get_status()))
       }

       fn matches_target(&self, target: i32, doc_type: DocType) -> bool {
           match VectorTargetType::try_from(target) {
               Ok(VectorTargetType::Unspecified) | Ok(VectorTargetType::All) => true,
               Ok(VectorTargetType::TocNode) => doc_type == DocType::TocNode,
               Ok(VectorTargetType::Grip) => doc_type == DocType::Grip,
               Err(_) => true,
           }
       }
   }
   ```

3. Update `crates/memory-service/src/lib.rs`:
   - Add `pub mod vector;`
   - Re-export `VectorTeleportHandler`
  </action>
  <verify>
    cd /Users/richardhightower/clients/spillwave/src/agent-memory && cargo build -p memory-service
  </verify>
  <done>
    VectorTeleportHandler implemented with spawn_blocking for CPU work, filters, and metadata lookup.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement HybridSearch with RRF fusion</name>
  <files>
    crates/memory-service/src/hybrid.rs
    crates/memory-service/src/lib.rs
  </files>
  <action>
Implement hybrid search with Reciprocal Rank Fusion:

1. Create `crates/memory-service/src/hybrid.rs`:
   ```rust
   //! HybridSearch RPC implementation.
   //!
   //! Combines BM25 and vector search using Reciprocal Rank Fusion (RRF).
   //! RRF_score(doc) = sum(weight_i / (k + rank_i(doc)))
   //! where k=60 is the standard constant.

   use std::collections::HashMap;
   use std::sync::Arc;
   use tonic::{Request, Response, Status};
   use tracing::{debug, info};

   use crate::proto::{
       HybridSearchRequest, HybridSearchResponse, VectorMatch, HybridMode,
       VectorTeleportRequest,
   };
   use crate::vector::VectorTeleportHandler;

   const RRF_K: f32 = 60.0;

   pub struct HybridSearchHandler {
       vector_handler: Arc<VectorTeleportHandler>,
       // BM25 integration via feature flag when Phase 11 complete
   }

   impl HybridSearchHandler {
       pub fn new(vector_handler: Arc<VectorTeleportHandler>) -> Self {
           Self { vector_handler }
       }

       pub fn bm25_available(&self) -> bool {
           false // Will be true when Phase 11 integrated
       }

       pub fn vector_available(&self) -> bool {
           self.vector_handler.is_available()
       }

       pub async fn hybrid_search(
           &self,
           request: Request<HybridSearchRequest>,
       ) -> Result<Response<HybridSearchResponse>, Status> {
           let req = request.into_inner();
           let query = &req.query;
           let top_k = if req.top_k > 0 { req.top_k as usize } else { 10 };
           let mode = HybridMode::try_from(req.mode).unwrap_or(HybridMode::Hybrid);
           let bm25_weight = if req.bm25_weight > 0.0 { req.bm25_weight } else { 0.5 };
           let vector_weight = if req.vector_weight > 0.0 { req.vector_weight } else { 0.5 };

           debug!(query = %query, mode = ?mode, "HybridSearch request");

           // Determine actual mode based on availability
           let (actual_mode, matches) = match mode {
               HybridMode::VectorOnly => {
                   (HybridMode::VectorOnly, self.vector_search(query, top_k, &req).await?)
               }
               HybridMode::Bm25Only => {
                   (HybridMode::Bm25Only, self.bm25_search(query, top_k).await?)
               }
               HybridMode::Hybrid | HybridMode::Unspecified => {
                   if self.vector_available() && self.bm25_available() {
                       let fused = self.fuse_rrf(query, top_k, bm25_weight, vector_weight, &req).await?;
                       (HybridMode::Hybrid, fused)
                   } else if self.vector_available() {
                       (HybridMode::VectorOnly, self.vector_search(query, top_k, &req).await?)
                   } else if self.bm25_available() {
                       (HybridMode::Bm25Only, self.bm25_search(query, top_k).await?)
                   } else {
                       (HybridMode::Unspecified, vec![])
                   }
               }
           };

           info!(query = %query, mode = ?actual_mode, results = matches.len(), "HybridSearch complete");

           Ok(Response::new(HybridSearchResponse {
               matches,
               mode_used: actual_mode as i32,
               bm25_available: self.bm25_available(),
               vector_available: self.vector_available(),
           }))
       }

       async fn vector_search(
           &self,
           query: &str,
           top_k: usize,
           req: &HybridSearchRequest,
       ) -> Result<Vec<VectorMatch>, Status> {
           let vector_req = VectorTeleportRequest {
               query: query.to_string(),
               top_k: top_k as i32,
               min_score: 0.0,
               time_filter: req.time_filter.clone(),
               target: req.target,
           };
           let response = self.vector_handler.vector_teleport(Request::new(vector_req)).await?;
           Ok(response.into_inner().matches)
       }

       async fn bm25_search(&self, _query: &str, _top_k: usize) -> Result<Vec<VectorMatch>, Status> {
           // TODO: Integrate with Phase 11 BM25 when complete
           Ok(vec![])
       }

       async fn fuse_rrf(
           &self,
           query: &str,
           top_k: usize,
           bm25_weight: f32,
           vector_weight: f32,
           req: &HybridSearchRequest,
       ) -> Result<Vec<VectorMatch>, Status> {
           let fetch_k = top_k * 2;
           let vector_results = self.vector_search(query, fetch_k, req).await?;
           let bm25_results = self.bm25_search(query, fetch_k).await?;

           let mut rrf: HashMap<String, RrfEntry> = HashMap::new();

           // Accumulate vector RRF scores
           for (rank, m) in vector_results.into_iter().enumerate() {
               let score = vector_weight / (RRF_K + rank as f32 + 1.0);
               let entry = rrf.entry(m.doc_id.clone()).or_insert_with(|| RrfEntry::from(&m));
               entry.rrf_score += score;
           }

           // Accumulate BM25 RRF scores
           for (rank, m) in bm25_results.into_iter().enumerate() {
               let score = bm25_weight / (RRF_K + rank as f32 + 1.0);
               let entry = rrf.entry(m.doc_id.clone()).or_insert_with(|| RrfEntry::from(&m));
               entry.rrf_score += score;
           }

           // Sort and truncate
           let mut entries: Vec<_> = rrf.into_values().collect();
           entries.sort_by(|a, b| b.rrf_score.partial_cmp(&a.rrf_score).unwrap());
           entries.truncate(top_k);

           Ok(entries.into_iter().map(|e| VectorMatch {
               doc_id: e.doc_id,
               doc_type: e.doc_type,
               score: e.rrf_score,
               text_preview: e.text_preview,
               timestamp_ms: e.timestamp_ms,
           }).collect())
       }
   }

   struct RrfEntry {
       doc_id: String,
       doc_type: String,
       text_preview: String,
       timestamp_ms: i64,
       rrf_score: f32,
   }

   impl From<&VectorMatch> for RrfEntry {
       fn from(m: &VectorMatch) -> Self {
           Self {
               doc_id: m.doc_id.clone(),
               doc_type: m.doc_type.clone(),
               text_preview: m.text_preview.clone(),
               timestamp_ms: m.timestamp_ms,
               rrf_score: 0.0,
           }
       }
   }
   ```

2. Update `crates/memory-service/src/lib.rs`:
   - Add `pub mod hybrid;`
   - Re-export `HybridSearchHandler`
  </action>
  <verify>
    cd /Users/richardhightower/clients/spillwave/src/agent-memory && cargo build -p memory-service && cargo test -p memory-service
  </verify>
  <done>
    HybridSearchHandler implements RRF fusion with k=60. Graceful fallback to single-mode search.
  </done>
</task>

</tasks>

<verification>
```bash
cd /Users/richardhightower/clients/spillwave/src/agent-memory

# Proto compiles and generates code
cargo build -p memory-service

# All tests pass
cargo test -p memory-service

# Clippy clean
cargo clippy -p memory-service -- -D warnings

# Proto types documented
cargo doc -p memory-service --no-deps
```
</verification>

<success_criteria>
- [ ] VectorTeleport RPC defined in proto with request/response messages
- [ ] HybridSearch RPC defined in proto with mode enum
- [ ] GetVectorIndexStatus RPC defined in proto
- [ ] VectorTeleportHandler embeds query via spawn_blocking
- [ ] VectorTeleportHandler searches HNSW and looks up metadata
- [ ] VectorMatch includes doc_id, score, text_preview, timestamp
- [ ] HybridSearchHandler supports VECTOR_ONLY, BM25_ONLY, HYBRID modes
- [ ] RRF fusion uses k=60 constant
- [ ] Graceful fallback when only one index available
- [ ] Time and target type filters work correctly
- [ ] All tests pass
- [ ] No clippy warnings
</success_criteria>

<output>
After completion, create `.planning/phases/12-vector-teleport-hnsw/12-03-SUMMARY.md`
</output>
