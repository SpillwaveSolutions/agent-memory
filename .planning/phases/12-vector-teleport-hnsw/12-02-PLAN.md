---
phase: 12-vector-teleport-hnsw
plan: 02
type: execute
wave: 2
depends_on: [12-01]
files_modified:
  - Cargo.toml
  - crates/memory-vector/Cargo.toml
  - crates/memory-vector/src/lib.rs
  - crates/memory-vector/src/error.rs
  - crates/memory-vector/src/index.rs
  - crates/memory-vector/src/hnsw.rs
  - crates/memory-vector/src/metadata.rs
  - crates/memory-types/src/config.rs
autonomous: true

must_haves:
  truths:
    - "Vectors can be added to HNSW index by ID"
    - "K-nearest neighbors can be retrieved for a query vector"
    - "Index persists across restarts via mmap"
    - "Metadata maps vector IDs to TOC node IDs or grip IDs"
  artifacts:
    - path: "crates/memory-vector/Cargo.toml"
      provides: "Vector crate dependencies"
      contains: "usearch"
    - path: "crates/memory-vector/src/index.rs"
      provides: "VectorIndex trait definition"
      exports: ["VectorIndex", "SearchResult"]
    - path: "crates/memory-vector/src/hnsw.rs"
      provides: "usearch HNSW implementation"
      exports: ["HnswIndex", "HnswConfig"]
    - path: "crates/memory-vector/src/metadata.rs"
      provides: "ID to document mapping"
      exports: ["VectorMetadata", "VectorEntry"]
  key_links:
    - from: "crates/memory-vector/src/hnsw.rs"
      to: "usearch::Index"
      via: "wraps usearch for HNSW operations"
      pattern: "Index::new"
    - from: "crates/memory-vector/src/metadata.rs"
      to: "rocksdb"
      via: "stores vector ID to doc ID mapping"
      pattern: "CF_VECTOR_META"
---

<objective>
Create the memory-vector crate with usearch HNSW integration and metadata storage.

Purpose: Enable efficient approximate nearest neighbor search for semantic similarity. The HNSW index provides O(log n) search performance, enabling fast vector teleport even with millions of embeddings.

Output: New memory-vector crate with VectorIndex trait, HnswIndex implementation, and metadata storage in RocksDB.
</objective>

<execution_context>
@/Users/richardhightower/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardhightower/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/12-vector-teleport-hnsw/12-RESEARCH.md
@.planning/phases/12-vector-teleport-hnsw/12-01-SUMMARY.md
@crates/memory-embeddings/src/model.rs
@crates/memory-storage/src/lib.rs
@Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create memory-vector crate structure</name>
  <files>
    crates/memory-vector/Cargo.toml
    crates/memory-vector/src/lib.rs
    crates/memory-vector/src/error.rs
    Cargo.toml
  </files>
  <action>
Create the new memory-vector crate:

1. Create `crates/memory-vector/Cargo.toml`:
   - Package name: memory-vector
   - Inherit workspace.package fields (version, edition, license, repository)
   - Dependencies:
     - usearch = "2"
     - memory-types = { workspace = true }
     - memory-embeddings = { workspace = true }
     - rocksdb = { workspace = true }
     - tokio = { workspace = true }
     - tracing = { workspace = true }
     - thiserror = { workspace = true }
     - serde = { workspace = true }
     - serde_json = { workspace = true }
   - Dev dependencies:
     - tempfile = { workspace = true }
     - rand = { workspace = true }
     - tokio = { workspace = true, features = ["test-util", "macros", "rt-multi-thread"] }

2. Create `crates/memory-vector/src/lib.rs`:
   ```rust
   //! # memory-vector
   //!
   //! Vector index for Agent Memory using HNSW algorithm.
   //!
   //! This crate provides semantic similarity search by storing embeddings
   //! in an HNSW (Hierarchical Navigable Small World) index via usearch.
   //!
   //! ## Features
   //! - usearch-powered HNSW index with mmap persistence
   //! - O(log n) approximate nearest neighbor search
   //! - Metadata storage linking vector IDs to document IDs
   //! - Configurable HNSW parameters (M, ef_construction, ef_search)
   //!
   //! ## Requirements
   //! - FR-02: HNSW index via usearch
   //! - FR-03: VectorTeleport RPC support
   //! - Index lifecycle: prune/rebuild operations

   pub mod error;
   pub mod index;
   pub mod hnsw;
   pub mod metadata;

   pub use error::VectorError;
   pub use index::{VectorIndex, SearchResult};
   pub use hnsw::{HnswIndex, HnswConfig};
   pub use metadata::{VectorMetadata, VectorEntry, DocType};
   ```

3. Create `crates/memory-vector/src/error.rs`:
   ```rust
   //! Vector index error types.

   use thiserror::Error;

   /// Errors that can occur during vector operations.
   #[derive(Debug, Error)]
   pub enum VectorError {
       /// usearch index error
       #[error("Index error: {0}")]
       Index(String),

       /// Dimension mismatch
       #[error("Dimension mismatch: expected {expected}, got {actual}")]
       DimensionMismatch { expected: usize, actual: usize },

       /// Vector not found
       #[error("Vector not found: {0}")]
       NotFound(u64),

       /// IO error
       #[error("IO error: {0}")]
       Io(#[from] std::io::Error),

       /// Serialization error
       #[error("Serialization error: {0}")]
       Serialization(String),

       /// RocksDB error
       #[error("Database error: {0}")]
       Database(#[from] rocksdb::Error),

       /// Index is full
       #[error("Index capacity reached: {0}")]
       CapacityReached(usize),

       /// Index not initialized
       #[error("Index not initialized")]
       NotInitialized,

       /// Embedding error
       #[error("Embedding error: {0}")]
       Embedding(#[from] memory_embeddings::EmbeddingError),
   }
   ```

4. Update workspace `Cargo.toml`:
   - Add "crates/memory-vector" to workspace members
   - Add memory-vector = { path = "crates/memory-vector" } to workspace.dependencies
   - Add usearch = "2" to workspace.dependencies
  </action>
  <verify>
    cd /Users/richardhightower/clients/spillwave/src/agent-memory && cargo check -p memory-vector
  </verify>
  <done>
    Crate compiles, error types defined, workspace includes memory-vector and usearch
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement VectorIndex trait and HnswIndex</name>
  <files>
    crates/memory-vector/src/index.rs
    crates/memory-vector/src/hnsw.rs
  </files>
  <action>
Implement the vector index trait and HNSW implementation:

1. Create `crates/memory-vector/src/index.rs`:
   ```rust
   //! Vector index trait and types.
   //!
   //! Defines the interface for vector similarity search.

   use crate::error::VectorError;
   use memory_embeddings::Embedding;

   /// Result of a vector search
   #[derive(Debug, Clone)]
   pub struct SearchResult {
       /// Internal vector ID
       pub vector_id: u64,
       /// Distance/similarity score (lower = more similar for L2, higher = more similar for cosine)
       pub score: f32,
   }

   impl SearchResult {
       pub fn new(vector_id: u64, score: f32) -> Self {
           Self { vector_id, score }
       }
   }

   /// Index statistics
   #[derive(Debug, Clone, Default)]
   pub struct IndexStats {
       /// Number of vectors in the index
       pub vector_count: usize,
       /// Embedding dimension
       pub dimension: usize,
       /// Index file size in bytes
       pub size_bytes: u64,
       /// Whether index is available for search
       pub available: bool,
   }

   /// Trait for vector indexes.
   ///
   /// Implementations must be thread-safe for concurrent read access.
   pub trait VectorIndex: Send + Sync {
       /// Get the embedding dimension
       fn dimension(&self) -> usize;

       /// Get the number of vectors in the index
       fn len(&self) -> usize;

       /// Check if the index is empty
       fn is_empty(&self) -> bool {
           self.len() == 0
       }

       /// Add a vector with the given ID.
       /// Returns error if ID already exists.
       fn add(&mut self, id: u64, embedding: &Embedding) -> Result<(), VectorError>;

       /// Add multiple vectors in batch.
       fn add_batch(&mut self, vectors: &[(u64, Embedding)]) -> Result<(), VectorError> {
           for (id, emb) in vectors {
               self.add(*id, emb)?;
           }
           Ok(())
       }

       /// Search for k nearest neighbors.
       /// Returns results sorted by similarity (best first).
       fn search(&self, query: &Embedding, k: usize) -> Result<Vec<SearchResult>, VectorError>;

       /// Remove a vector by ID.
       fn remove(&mut self, id: u64) -> Result<bool, VectorError>;

       /// Check if a vector ID exists
       fn contains(&self, id: u64) -> bool;

       /// Get index statistics
       fn stats(&self) -> IndexStats;

       /// Save index to disk
       fn save(&self) -> Result<(), VectorError>;

       /// Clear all vectors from the index
       fn clear(&mut self) -> Result<(), VectorError>;
   }
   ```

2. Create `crates/memory-vector/src/hnsw.rs`:
   ```rust
   //! HNSW index implementation using usearch.
   //!
   //! Parameters tuned for quality over speed:
   //! - M = 16 (connections per layer)
   //! - ef_construction = 200 (build-time quality)
   //! - ef_search = 100 (search-time quality)

   use std::path::{Path, PathBuf};
   use std::sync::RwLock;

   use tracing::{debug, info, warn};
   use usearch::{Index, IndexOptions, MetricKind, ScalarKind};

   use crate::error::VectorError;
   use crate::index::{IndexStats, SearchResult, VectorIndex};
   use memory_embeddings::Embedding;

   /// HNSW index configuration
   #[derive(Debug, Clone)]
   pub struct HnswConfig {
       /// Embedding dimension (must match model)
       pub dimension: usize,
       /// Number of connections per layer (M parameter)
       pub connectivity: usize,
       /// Build-time search depth (ef_construction)
       pub expansion_add: usize,
       /// Query-time search depth (ef_search)
       pub expansion_search: usize,
       /// Index file path
       pub index_path: PathBuf,
       /// Maximum capacity (for pre-allocation)
       pub capacity: usize,
   }

   impl Default for HnswConfig {
       fn default() -> Self {
           Self {
               dimension: 384, // all-MiniLM-L6-v2
               connectivity: 16,
               expansion_add: 200,
               expansion_search: 100,
               index_path: PathBuf::from("./vector-index"),
               capacity: 1_000_000,
           }
       }
   }

   impl HnswConfig {
       pub fn new(dimension: usize, index_path: impl Into<PathBuf>) -> Self {
           Self {
               dimension,
               index_path: index_path.into(),
               ..Default::default()
           }
       }

       pub fn with_connectivity(mut self, m: usize) -> Self {
           self.connectivity = m;
           self
       }

       pub fn with_expansion(mut self, ef_add: usize, ef_search: usize) -> Self {
           self.expansion_add = ef_add;
           self.expansion_search = ef_search;
           self
       }

       pub fn with_capacity(mut self, capacity: usize) -> Self {
           self.capacity = capacity;
           self
       }
   }

   /// HNSW index wrapper around usearch.
   pub struct HnswIndex {
       index: RwLock<Index>,
       config: HnswConfig,
   }

   impl HnswIndex {
       /// Create a new HNSW index or open existing one.
       pub fn open_or_create(config: HnswConfig) -> Result<Self, VectorError> {
           let index_file = config.index_path.join("hnsw.usearch");

           let options = IndexOptions {
               dimensions: config.dimension,
               metric: MetricKind::Cos, // Cosine similarity
               quantization: ScalarKind::F32,
               connectivity: config.connectivity,
               expansion_add: config.expansion_add,
               expansion_search: config.expansion_search,
               multi: false, // Single vector per key
           };

           let index = if index_file.exists() {
               info!(path = ?index_file, "Opening existing vector index");
               let mut idx = Index::new(&options)
                   .map_err(|e| VectorError::Index(e.to_string()))?;
               idx.load(&index_file)
                   .map_err(|e| VectorError::Index(format!("Failed to load: {}", e)))?;
               idx
           } else {
               info!(path = ?index_file, dim = config.dimension, "Creating new vector index");
               std::fs::create_dir_all(&config.index_path)?;
               let idx = Index::new(&options)
                   .map_err(|e| VectorError::Index(e.to_string()))?;
               idx.reserve(config.capacity)
                   .map_err(|e| VectorError::Index(e.to_string()))?;
               idx
           };

           Ok(Self {
               index: RwLock::new(index),
               config,
           })
       }

       /// Get the index file path
       pub fn index_file(&self) -> PathBuf {
           self.config.index_path.join("hnsw.usearch")
       }
   }

   impl VectorIndex for HnswIndex {
       fn dimension(&self) -> usize {
           self.config.dimension
       }

       fn len(&self) -> usize {
           self.index.read().unwrap().size()
       }

       fn add(&mut self, id: u64, embedding: &Embedding) -> Result<(), VectorError> {
           if embedding.dimension() != self.config.dimension {
               return Err(VectorError::DimensionMismatch {
                   expected: self.config.dimension,
                   actual: embedding.dimension(),
               });
           }

           let mut index = self.index.write().unwrap();
           index.add(id, &embedding.values)
               .map_err(|e| VectorError::Index(e.to_string()))?;

           debug!(id = id, "Added vector");
           Ok(())
       }

       fn search(&self, query: &Embedding, k: usize) -> Result<Vec<SearchResult>, VectorError> {
           if query.dimension() != self.config.dimension {
               return Err(VectorError::DimensionMismatch {
                   expected: self.config.dimension,
                   actual: query.dimension(),
               });
           }

           let index = self.index.read().unwrap();
           let results = index.search(&query.values, k)
               .map_err(|e| VectorError::Index(e.to_string()))?;

           let search_results: Vec<SearchResult> = results.keys.iter()
               .zip(results.distances.iter())
               .map(|(&id, &dist)| SearchResult::new(id, 1.0 - dist)) // Convert distance to similarity
               .collect();

           debug!(k = k, found = search_results.len(), "Search complete");
           Ok(search_results)
       }

       fn remove(&mut self, id: u64) -> Result<bool, VectorError> {
           let mut index = self.index.write().unwrap();
           let result = index.remove(id)
               .map_err(|e| VectorError::Index(e.to_string()))?;

           if result > 0 {
               debug!(id = id, "Removed vector");
               Ok(true)
           } else {
               Ok(false)
           }
       }

       fn contains(&self, id: u64) -> bool {
           let index = self.index.read().unwrap();
           index.contains(id)
       }

       fn stats(&self) -> IndexStats {
           let index = self.index.read().unwrap();
           let size_bytes = std::fs::metadata(self.index_file())
               .map(|m| m.len())
               .unwrap_or(0);

           IndexStats {
               vector_count: index.size(),
               dimension: self.config.dimension,
               size_bytes,
               available: true,
           }
       }

       fn save(&self) -> Result<(), VectorError> {
           let index = self.index.read().unwrap();
           let path = self.index_file();
           index.save(&path)
               .map_err(|e| VectorError::Index(format!("Failed to save: {}", e)))?;

           info!(path = ?path, vectors = index.size(), "Saved vector index");
           Ok(())
       }

       fn clear(&mut self) -> Result<(), VectorError> {
           // Recreate empty index
           let options = IndexOptions {
               dimensions: self.config.dimension,
               metric: MetricKind::Cos,
               quantization: ScalarKind::F32,
               connectivity: self.config.connectivity,
               expansion_add: self.config.expansion_add,
               expansion_search: self.config.expansion_search,
               multi: false,
           };

           let new_index = Index::new(&options)
               .map_err(|e| VectorError::Index(e.to_string()))?;
           new_index.reserve(self.config.capacity)
               .map_err(|e| VectorError::Index(e.to_string()))?;

           *self.index.write().unwrap() = new_index;
           info!("Cleared vector index");
           Ok(())
       }
   }

   #[cfg(test)]
   mod tests {
       use super::*;
       use tempfile::TempDir;

       fn random_embedding(dim: usize) -> Embedding {
           use rand::Rng;
           let mut rng = rand::thread_rng();
           let values: Vec<f32> = (0..dim).map(|_| rng.gen()).collect();
           Embedding::new(values)
       }

       #[test]
       fn test_create_index() {
           let temp = TempDir::new().unwrap();
           let config = HnswConfig::new(384, temp.path());
           let index = HnswIndex::open_or_create(config).unwrap();
           assert_eq!(index.dimension(), 384);
           assert_eq!(index.len(), 0);
       }

       #[test]
       fn test_add_and_search() {
           let temp = TempDir::new().unwrap();
           let config = HnswConfig::new(64, temp.path()).with_capacity(100);
           let mut index = HnswIndex::open_or_create(config).unwrap();

           // Add some vectors
           for i in 0..10 {
               let emb = random_embedding(64);
               index.add(i, &emb).unwrap();
           }

           assert_eq!(index.len(), 10);

           // Search
           let query = random_embedding(64);
           let results = index.search(&query, 5).unwrap();
           assert_eq!(results.len(), 5);

           // Results should be sorted by score (descending)
           for i in 1..results.len() {
               assert!(results[i-1].score >= results[i].score);
           }
       }

       #[test]
       fn test_save_and_load() {
           let temp = TempDir::new().unwrap();
           let config = HnswConfig::new(64, temp.path()).with_capacity(100);

           // Create and populate
           {
               let mut index = HnswIndex::open_or_create(config.clone()).unwrap();
               for i in 0..5 {
                   index.add(i, &random_embedding(64)).unwrap();
               }
               index.save().unwrap();
           }

           // Reopen
           let index = HnswIndex::open_or_create(config).unwrap();
           assert_eq!(index.len(), 5);
       }

       #[test]
       fn test_dimension_mismatch() {
           let temp = TempDir::new().unwrap();
           let config = HnswConfig::new(64, temp.path());
           let mut index = HnswIndex::open_or_create(config).unwrap();

           let wrong_dim = random_embedding(32);
           let result = index.add(0, &wrong_dim);
           assert!(matches!(result, Err(VectorError::DimensionMismatch { .. })));
       }

       #[test]
       fn test_remove() {
           let temp = TempDir::new().unwrap();
           let config = HnswConfig::new(64, temp.path()).with_capacity(100);
           let mut index = HnswIndex::open_or_create(config).unwrap();

           index.add(42, &random_embedding(64)).unwrap();
           assert!(index.contains(42));

           let removed = index.remove(42).unwrap();
           assert!(removed);
           assert!(!index.contains(42));
       }
   }
   ```
  </action>
  <verify>
    cd /Users/richardhightower/clients/spillwave/src/agent-memory && cargo test -p memory-vector hnsw
  </verify>
  <done>
    VectorIndex trait defined. HnswIndex wraps usearch with mmap persistence. All tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement metadata storage and config</name>
  <files>
    crates/memory-vector/src/metadata.rs
    crates/memory-types/src/config.rs
  </files>
  <action>
Implement vector metadata storage:

1. Create `crates/memory-vector/src/metadata.rs`:
   ```rust
   //! Vector metadata storage.
   //!
   //! Maps internal vector IDs (u64) to document IDs (node_id or grip_id).
   //! Stored in RocksDB for persistence and atomic updates.

   use std::path::Path;

   use rocksdb::{ColumnFamily, ColumnFamilyDescriptor, Options, DB};
   use serde::{Deserialize, Serialize};
   use tracing::{debug, info};

   use crate::error::VectorError;

   /// Column family name for vector metadata
   pub const CF_VECTOR_META: &str = "vector_meta";

   /// Document type for vectors
   #[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
   pub enum DocType {
       /// TOC node summary
       TocNode,
       /// Grip excerpt
       Grip,
   }

   impl DocType {
       pub fn as_str(&self) -> &'static str {
           match self {
               DocType::TocNode => "toc_node",
               DocType::Grip => "grip",
           }
       }
   }

   /// Vector entry metadata
   #[derive(Debug, Clone, Serialize, Deserialize)]
   pub struct VectorEntry {
       /// Internal vector ID (key in HNSW index)
       pub vector_id: u64,
       /// Document type
       pub doc_type: DocType,
       /// Document ID (node_id or grip_id)
       pub doc_id: String,
       /// Timestamp when vector was created (ms since epoch)
       pub created_at: i64,
       /// Text that was embedded (truncated for storage)
       pub text_preview: String,
   }

   impl VectorEntry {
       pub fn new(
           vector_id: u64,
           doc_type: DocType,
           doc_id: impl Into<String>,
           created_at: i64,
           text: &str,
       ) -> Self {
           const MAX_PREVIEW: usize = 200;
           let text_preview = if text.len() > MAX_PREVIEW {
               format!("{}...", &text[..MAX_PREVIEW])
           } else {
               text.to_string()
           };

           Self {
               vector_id,
               doc_type,
               doc_id: doc_id.into(),
               created_at,
               text_preview,
           }
       }
   }

   /// Vector metadata storage using RocksDB.
   pub struct VectorMetadata {
       db: DB,
   }

   impl VectorMetadata {
       /// Open or create metadata storage.
       pub fn open(path: impl AsRef<Path>) -> Result<Self, VectorError> {
           let path = path.as_ref();

           let mut opts = Options::default();
           opts.create_if_missing(true);
           opts.create_missing_column_families(true);

           let cf_opts = Options::default();
           let cf = ColumnFamilyDescriptor::new(CF_VECTOR_META, cf_opts);

           let db = DB::open_cf_descriptors(&opts, path, vec![cf])?;

           info!(path = ?path, "Opened vector metadata storage");
           Ok(Self { db })
       }

       /// Get the column family handle
       fn cf(&self) -> &ColumnFamily {
           self.db.cf_handle(CF_VECTOR_META).expect("CF_VECTOR_META missing")
       }

       /// Store vector entry metadata.
       pub fn put(&self, entry: &VectorEntry) -> Result<(), VectorError> {
           let key = entry.vector_id.to_be_bytes();
           let value = serde_json::to_vec(entry)
               .map_err(|e| VectorError::Serialization(e.to_string()))?;

           self.db.put_cf(self.cf(), key, value)?;
           debug!(vector_id = entry.vector_id, doc_id = %entry.doc_id, "Stored metadata");
           Ok(())
       }

       /// Get vector entry by vector ID.
       pub fn get(&self, vector_id: u64) -> Result<Option<VectorEntry>, VectorError> {
           let key = vector_id.to_be_bytes();
           match self.db.get_cf(self.cf(), key)? {
               Some(bytes) => {
                   let entry: VectorEntry = serde_json::from_slice(&bytes)
                       .map_err(|e| VectorError::Serialization(e.to_string()))?;
                   Ok(Some(entry))
               }
               None => Ok(None),
           }
       }

       /// Delete vector entry by vector ID.
       pub fn delete(&self, vector_id: u64) -> Result<(), VectorError> {
           let key = vector_id.to_be_bytes();
           self.db.delete_cf(self.cf(), key)?;
           Ok(())
       }

       /// Get all entries for a document type.
       pub fn get_by_type(&self, doc_type: DocType) -> Result<Vec<VectorEntry>, VectorError> {
           let mut entries = Vec::new();
           let iter = self.db.iterator_cf(self.cf(), rocksdb::IteratorMode::Start);

           for item in iter {
               let (_, value) = item?;
               let entry: VectorEntry = serde_json::from_slice(&value)
                   .map_err(|e| VectorError::Serialization(e.to_string()))?;
               if entry.doc_type == doc_type {
                   entries.push(entry);
               }
           }

           Ok(entries)
       }

       /// Find vector ID for a document ID.
       pub fn find_by_doc_id(&self, doc_id: &str) -> Result<Option<VectorEntry>, VectorError> {
           let iter = self.db.iterator_cf(self.cf(), rocksdb::IteratorMode::Start);

           for item in iter {
               let (_, value) = item?;
               let entry: VectorEntry = serde_json::from_slice(&value)
                   .map_err(|e| VectorError::Serialization(e.to_string()))?;
               if entry.doc_id == doc_id {
                   return Ok(Some(entry));
               }
           }

           Ok(None)
       }

       /// Count total entries
       pub fn count(&self) -> Result<usize, VectorError> {
           let iter = self.db.iterator_cf(self.cf(), rocksdb::IteratorMode::Start);
           Ok(iter.count())
       }

       /// Get the next available vector ID
       pub fn next_vector_id(&self) -> Result<u64, VectorError> {
           let iter = self.db.iterator_cf(self.cf(), rocksdb::IteratorMode::End);

           if let Some(Ok((key, _))) = iter.into_iter().next() {
               let id = u64::from_be_bytes(key[..8].try_into().unwrap());
               Ok(id + 1)
           } else {
               Ok(1) // Start from 1
           }
       }
   }

   #[cfg(test)]
   mod tests {
       use super::*;
       use tempfile::TempDir;

       #[test]
       fn test_put_and_get() {
           let temp = TempDir::new().unwrap();
           let meta = VectorMetadata::open(temp.path()).unwrap();

           let entry = VectorEntry::new(
               1,
               DocType::TocNode,
               "toc:day:2024-01-15",
               1705320000000,
               "This is a test summary for the day",
           );

           meta.put(&entry).unwrap();

           let retrieved = meta.get(1).unwrap().unwrap();
           assert_eq!(retrieved.vector_id, 1);
           assert_eq!(retrieved.doc_id, "toc:day:2024-01-15");
           assert_eq!(retrieved.doc_type, DocType::TocNode);
       }

       #[test]
       fn test_find_by_doc_id() {
           let temp = TempDir::new().unwrap();
           let meta = VectorMetadata::open(temp.path()).unwrap();

           for i in 0..5 {
               let entry = VectorEntry::new(
                   i,
                   DocType::Grip,
                   format!("grip:123456:{}", i),
                   1705320000000,
                   "Test excerpt",
               );
               meta.put(&entry).unwrap();
           }

           let found = meta.find_by_doc_id("grip:123456:3").unwrap().unwrap();
           assert_eq!(found.vector_id, 3);
       }

       #[test]
       fn test_next_vector_id() {
           let temp = TempDir::new().unwrap();
           let meta = VectorMetadata::open(temp.path()).unwrap();

           assert_eq!(meta.next_vector_id().unwrap(), 1);

           let entry = VectorEntry::new(42, DocType::TocNode, "test", 0, "test");
           meta.put(&entry).unwrap();

           assert_eq!(meta.next_vector_id().unwrap(), 43);
       }
   }
   ```

2. Update `crates/memory-types/src/config.rs` to add vector index path:
   - Add `vector_index_path: Option<String>` to Settings struct
   - Add default function: `default_vector_index_path()` returning `~/.local/share/agent-memory/vector-index`
   - Document the field as "Path to HNSW vector index directory"
  </action>
  <verify>
    cd /Users/richardhightower/clients/spillwave/src/agent-memory && cargo test -p memory-vector metadata && cargo test -p memory-types config
  </verify>
  <done>
    VectorMetadata stores vector ID to document ID mappings in RocksDB. Settings includes vector_index_path. All tests pass.
  </done>
</task>

</tasks>

<verification>
```bash
cd /Users/richardhightower/clients/spillwave/src/agent-memory

# Crate compiles
cargo build -p memory-vector

# All tests pass
cargo test -p memory-vector

# Index operations work
cargo test -p memory-vector hnsw

# Metadata storage works
cargo test -p memory-vector metadata

# Config includes vector path
cargo test -p memory-types config

# Clippy clean
cargo clippy -p memory-vector -- -D warnings
```
</verification>

<success_criteria>
- [ ] memory-vector crate exists in workspace
- [ ] usearch = "2" added to workspace dependencies
- [ ] VectorIndex trait defines add, search, remove, save, stats methods
- [ ] SearchResult includes vector_id and score
- [ ] HnswIndex wraps usearch with configurable M, ef_construction, ef_search
- [ ] HnswConfig defaults: M=16, ef_construction=200, ef_search=100
- [ ] Index persists via mmap (survives restart)
- [ ] VectorMetadata stores vector_id -> doc_id mapping in RocksDB
- [ ] DocType enum distinguishes TocNode from Grip
- [ ] Settings.vector_index_path configured with default
- [ ] All tests pass
- [ ] No clippy warnings
</success_criteria>

<output>
After completion, create `.planning/phases/12-vector-teleport-hnsw/12-02-SUMMARY.md`
</output>
