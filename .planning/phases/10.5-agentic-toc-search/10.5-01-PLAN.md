---
phase: 10.5-agentic-toc-search
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/memory-toc/src/search.rs
  - crates/memory-toc/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "search_node() returns matches for query terms found in node fields"
    - "term_overlap_score() calculates ratio of matched to total terms"
    - "short terms (<3 chars) are filtered from queries"
    - "matches include field type, text, grip_ids, and score"
  artifacts:
    - path: "crates/memory-toc/src/search.rs"
      provides: "Core search algorithm and types"
      exports: ["SearchField", "SearchMatch", "search_node", "term_overlap_score"]
      min_lines: 150
    - path: "crates/memory-toc/src/lib.rs"
      provides: "Module export"
      contains: "pub mod search"
  key_links:
    - from: "search.rs"
      to: "TocNode, TocBullet"
      via: "memory_types import"
      pattern: "use memory_types::"
---

<objective>
Implement the core search algorithm for TOC nodes with term-overlap scoring.

Purpose: Enable agents to search within TOC node content without external index dependencies. This provides the "always works" foundation that later phases (BM25, vector) build upon.

Output: A `search.rs` module in memory-toc with search types and functions, fully tested.
</objective>

<execution_context>
@/Users/richardhightower/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardhightower/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10.5-agentic-toc-search/10.5-RESEARCH.md

Reference files:
@crates/memory-toc/src/lib.rs
@crates/memory-types/src/toc.rs
@crates/memory-toc/src/summarizer/grip_extractor.rs (term matching pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create search types and term_overlap_score function</name>
  <files>crates/memory-toc/src/search.rs</files>
  <action>
Create `crates/memory-toc/src/search.rs` with:

1. **SearchField enum** - Represents searchable fields:
   ```rust
   #[derive(Debug, Clone, Copy, PartialEq, Eq)]
   pub enum SearchField {
       Title,
       Summary,
       Bullets,
       Keywords,
   }
   ```

2. **SearchMatch struct** - Represents a match result:
   ```rust
   #[derive(Debug, Clone)]
   pub struct SearchMatch {
       pub field: SearchField,
       pub text: String,
       pub grip_ids: Vec<String>,
       pub score: f32,
   }
   ```

3. **term_overlap_score function** - Calculate relevance score:
   ```rust
   /// Calculate term overlap score (0.0-1.0).
   /// Returns None if no terms match.
   pub fn term_overlap_score(text: &str, terms: &[String]) -> Option<f32>
   ```
   - Convert text to lowercase for case-insensitive matching
   - Count how many terms appear in text
   - Return matched_count / total_terms as f32
   - Return None if no matches

Follow the pattern from grip_extractor.rs lines 82-124 but:
- Accept Vec<String> instead of Vec<&str> for term ownership
- Use >= 3 chars filter (not > 3) for broader matches
- Handle empty terms list gracefully (return None)
  </action>
  <verify>
`cargo check -p memory-toc` compiles without errors.
  </verify>
  <done>
SearchField enum and SearchMatch struct defined. term_overlap_score() function implemented with case-insensitive matching.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement search_node function</name>
  <files>crates/memory-toc/src/search.rs</files>
  <action>
Add `search_node()` function to search.rs:

```rust
use memory_types::{TocNode, TocBullet};

/// Search within a single node's fields for matching terms.
///
/// # Arguments
/// * `node` - The TOC node to search
/// * `query` - Space-separated search terms
/// * `fields` - Which fields to search (empty = all fields)
///
/// # Returns
/// Vector of SearchMatch sorted by score descending
pub fn search_node(
    node: &TocNode,
    query: &str,
    fields: &[SearchField],
) -> Vec<SearchMatch>
```

Implementation:
1. Parse query into terms: split on whitespace, filter terms < 3 chars, lowercase
2. Return empty Vec if no valid terms after filtering
3. Search each enabled field (if fields is empty, search all):
   - **Title**: Match against node.title
   - **Summary**: Generate summary from bullets (join bullet.text with " "), match against it
   - **Bullets**: Match each bullet.text individually, include bullet.grip_ids in match
   - **Keywords**: Match each keyword individually (score 1.0 if term matches keyword)
4. Sort matches by score descending
5. Return matches vector

Key behaviors:
- Empty fields slice means "search all fields"
- Each bullet creates a separate SearchMatch if it matches
- Keyword matches get score 1.0 (exact match)
- Summary is derived from bullets.iter().map(|b| b.text.clone()).join(" ")
  </action>
  <verify>
`cargo check -p memory-toc` compiles without errors.
  </verify>
  <done>
search_node() function implemented, searching title, summary, bullets, and keywords with proper scoring.
  </done>
</task>

<task type="auto">
  <name>Task 3: Export search module and add unit tests</name>
  <files>crates/memory-toc/src/search.rs, crates/memory-toc/src/lib.rs</files>
  <action>
1. **Update lib.rs** - Add module export:
   ```rust
   pub mod search;
   pub use search::{SearchField, SearchMatch, search_node, term_overlap_score};
   ```

2. **Add unit tests** to search.rs:

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use chrono::{TimeZone, Utc};
    use memory_types::{TocBullet, TocLevel, TocNode};

    fn make_test_node(title: &str, bullets: Vec<(&str, Vec<&str>)>, keywords: Vec<&str>) -> TocNode {
        let mut node = TocNode::new(
            "test:node:1".to_string(),
            TocLevel::Segment,
            title.to_string(),
            Utc.with_ymd_and_hms(2026, 1, 1, 0, 0, 0).unwrap(),
            Utc.with_ymd_and_hms(2026, 1, 1, 23, 59, 59).unwrap(),
        );
        node.bullets = bullets.into_iter().map(|(text, grips)| TocBullet {
            text: text.to_string(),
            grip_ids: grips.into_iter().map(|s| s.to_string()).collect(),
        }).collect();
        node.keywords = keywords.into_iter().map(|s| s.to_string()).collect();
        node
    }

    #[test]
    fn test_term_overlap_single_match() {
        let terms = vec!["jwt".to_string()];
        let score = term_overlap_score("JWT authentication system", &terms);
        assert!(score.is_some());
        assert_eq!(score.unwrap(), 1.0);
    }

    #[test]
    fn test_term_overlap_partial_match() {
        let terms = vec!["jwt".to_string(), "debugging".to_string()];
        let score = term_overlap_score("JWT authentication", &terms);
        assert!(score.is_some());
        assert_eq!(score.unwrap(), 0.5);
    }

    #[test]
    fn test_term_overlap_no_match() {
        let terms = vec!["vector".to_string(), "embedding".to_string()];
        let score = term_overlap_score("JWT authentication", &terms);
        assert!(score.is_none());
    }

    #[test]
    fn test_term_overlap_empty_terms() {
        let terms: Vec<String> = vec![];
        let score = term_overlap_score("JWT authentication", &terms);
        assert!(score.is_none());
    }

    #[test]
    fn test_search_node_title_match() {
        let node = make_test_node("JWT Token Debugging Session", vec![], vec![]);
        let matches = search_node(&node, "jwt debugging", &[SearchField::Title]);
        assert_eq!(matches.len(), 1);
        assert_eq!(matches[0].field, SearchField::Title);
        assert_eq!(matches[0].score, 1.0); // Both terms match
    }

    #[test]
    fn test_search_node_bullet_with_grips() {
        let node = make_test_node(
            "Session",
            vec![("Fixed JWT expiration bug", vec!["grip:123"])],
            vec![],
        );
        let matches = search_node(&node, "jwt bug", &[SearchField::Bullets]);
        assert_eq!(matches.len(), 1);
        assert_eq!(matches[0].field, SearchField::Bullets);
        assert_eq!(matches[0].grip_ids, vec!["grip:123"]);
    }

    #[test]
    fn test_search_node_keyword_match() {
        let node = make_test_node("Session", vec![], vec!["authentication", "JWT"]);
        let matches = search_node(&node, "jwt", &[SearchField::Keywords]);
        assert_eq!(matches.len(), 1);
        assert_eq!(matches[0].field, SearchField::Keywords);
        assert_eq!(matches[0].score, 1.0);
    }

    #[test]
    fn test_search_node_short_terms_filtered() {
        let node = make_test_node("The JWT Token", vec![], vec![]);
        // "the" is 3 chars so should be kept, but let's verify "to" would be filtered
        let matches = search_node(&node, "to jwt", &[SearchField::Title]);
        // Only "jwt" should be used (3+ chars), and it matches
        assert!(!matches.is_empty());
    }

    #[test]
    fn test_search_node_all_fields() {
        let node = make_test_node(
            "JWT Session",
            vec![("Implemented authentication", vec!["grip:1"])],
            vec!["token"],
        );
        // Empty fields means search all
        let matches = search_node(&node, "jwt token authentication", &[]);
        assert!(!matches.is_empty());
        // Should find matches in title, bullets, and keywords
    }

    #[test]
    fn test_search_node_sorted_by_score() {
        let node = make_test_node(
            "Session", // No match
            vec![
                ("JWT debugging today", vec!["grip:1"]),  // 1 of 2 = 0.5
                ("JWT authentication and token refresh", vec!["grip:2"]), // 2 of 2 = 1.0
            ],
            vec![],
        );
        let matches = search_node(&node, "jwt authentication", &[SearchField::Bullets]);
        assert_eq!(matches.len(), 2);
        // Higher score should be first
        assert!(matches[0].score >= matches[1].score);
    }
}
```

Run tests to verify implementation.
  </action>
  <verify>
`cargo test -p memory-toc search` passes all tests.
  </verify>
  <done>
search module exported from lib.rs. All unit tests pass, covering term matching, field searches, grip ID propagation, and edge cases.
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. `cargo build -p memory-toc` - Crate compiles
2. `cargo test -p memory-toc search` - All search tests pass
3. `cargo doc -p memory-toc --no-deps` - Documentation generates
4. Review: search_node() handles all field types correctly
</verification>

<success_criteria>
- SearchField enum with Title, Summary, Bullets, Keywords variants
- SearchMatch struct with field, text, grip_ids, score fields
- term_overlap_score() calculates ratio of matched terms
- search_node() searches across node fields with scoring
- All tests pass (8+ test cases covering edge cases)
- Module exported from memory-toc lib.rs
</success_criteria>

<output>
After completion, create `.planning/phases/10.5-agentic-toc-search/10.5-01-SUMMARY.md`
</output>
