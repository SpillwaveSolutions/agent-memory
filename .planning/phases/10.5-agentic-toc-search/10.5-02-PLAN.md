---
phase: 10.5-agentic-toc-search
plan: 02
type: execute
wave: 2
depends_on: ["10.5-01"]
files_modified:
  - proto/memory.proto
  - crates/memory-service/src/search_service.rs
  - crates/memory-service/src/lib.rs
  - crates/memory-service/src/server.rs
autonomous: true

must_haves:
  truths:
    - "SearchNode RPC searches within a single node's fields"
    - "SearchChildren RPC searches across all children of a parent"
    - "Proto messages use SEARCH_FIELD_ prefix for enum values"
    - "Matches include grip_ids for provenance verification"
    - "Results are sorted by relevance score"
  artifacts:
    - path: "proto/memory.proto"
      provides: "Search RPC definitions and messages"
      contains: "rpc SearchNode"
    - path: "crates/memory-service/src/search_service.rs"
      provides: "gRPC handler implementations"
      exports: ["search_node", "search_children"]
      min_lines: 100
  key_links:
    - from: "search_service.rs"
      to: "memory_toc::search"
      via: "use statement"
      pattern: "use memory_toc::search::"
    - from: "search_service.rs"
      to: "Storage"
      via: "Arc<Storage> parameter"
      pattern: "Arc<Storage>"
---

<objective>
Add gRPC SearchNode and SearchChildren RPCs for agentic TOC search.

Purpose: Enable agents to call search via gRPC, matching the existing query RPC patterns. This provides the network interface that CLI and plugin commands will use.

Output: Proto definitions and RPC handlers integrated with MemoryService.
</objective>

<execution_context>
@/Users/richardhightower/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardhightower/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/10.5-agentic-toc-search/10.5-01-SUMMARY.md
@.planning/phases/10.5-agentic-toc-search/10.5-RESEARCH.md

Reference files:
@proto/memory.proto (existing proto patterns)
@crates/memory-service/src/query.rs (RPC handler patterns)
@crates/memory-service/src/lib.rs (service wiring)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add search proto definitions</name>
  <files>proto/memory.proto</files>
  <action>
Extend `proto/memory.proto` with search messages and RPCs. Add after existing RPC definitions.

**1. Add SearchField enum** (follow EVENT_ROLE_ prefix pattern):
```protobuf
// Fields to search within a TOC node
enum SearchField {
  SEARCH_FIELD_UNSPECIFIED = 0;
  SEARCH_FIELD_TITLE = 1;
  SEARCH_FIELD_SUMMARY = 2;
  SEARCH_FIELD_BULLETS = 3;
  SEARCH_FIELD_KEYWORDS = 4;
}
```

**2. Add SearchNode messages:**
```protobuf
// Search within a single node
message SearchNodeRequest {
  // Node ID to search within
  string node_id = 1;
  // Search terms (space-separated, case-insensitive)
  string query = 2;
  // Fields to search (empty = all fields)
  repeated SearchField fields = 3;
  // Max matches to return (default: 10)
  int32 limit = 4;
  // Optional token budget for response control
  int32 token_budget = 5;
}

message SearchMatch {
  // Which field matched
  SearchField field = 1;
  // Matching text snippet
  string text = 2;
  // If bullet, the supporting grip IDs
  repeated string grip_ids = 3;
  // Term overlap score (0.0-1.0)
  float score = 4;
}

message SearchNodeResponse {
  // Whether any matches found
  bool matched = 1;
  // Individual matches
  repeated SearchMatch matches = 2;
  // Node that was searched
  string node_id = 3;
  // Level of the searched node
  TocLevel level = 4;
}
```

**3. Add SearchChildren messages:**
```protobuf
// Search children of a parent node
message SearchChildrenRequest {
  // Parent node ID (empty string for root/year level)
  string parent_id = 1;
  // Search terms (space-separated, case-insensitive)
  string query = 2;
  // Level to search at (ignored if parent_id provided - uses children's level)
  TocLevel child_level = 3;
  // Fields to search (empty = all fields)
  repeated SearchField fields = 4;
  // Max nodes to return (default: 10)
  int32 limit = 5;
  // Optional token budget for response control
  int32 token_budget = 6;
}

message SearchNodeResult {
  // Node ID of the matching node
  string node_id = 1;
  // Node title for display
  string title = 2;
  // Level of this node
  TocLevel level = 3;
  // Matches within this node
  repeated SearchMatch matches = 4;
  // Aggregate relevance score
  float relevance_score = 5;
}

message SearchChildrenResponse {
  // Matching nodes with their matches
  repeated SearchNodeResult results = 1;
  // Whether more results available
  bool has_more = 2;
}
```

**4. Add RPCs to MemoryService:**
```protobuf
service MemoryService {
  // ... existing RPCs ...

  // Search within a single TOC node
  rpc SearchNode(SearchNodeRequest) returns (SearchNodeResponse);

  // Search across children of a parent node
  rpc SearchChildren(SearchChildrenRequest) returns (SearchChildrenResponse);
}
```
  </action>
  <verify>
`cargo build -p memory-service` regenerates proto and compiles. Check for any naming conflicts.
  </verify>
  <done>
Proto definitions added for SearchField enum, SearchNode/SearchChildren request/response messages, and RPCs in MemoryService.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement search RPC handlers</name>
  <files>crates/memory-service/src/search_service.rs</files>
  <action>
Create `crates/memory-service/src/search_service.rs` following the query.rs pattern:

```rust
//! Search RPC implementations.
//!
//! Per SEARCH-01, SEARCH-02: TOC node search via term matching.

use std::cmp::Ordering;
use std::sync::Arc;

use tonic::{Request, Response, Status};
use tracing::debug;

use memory_storage::Storage;
use memory_toc::search::{search_node as core_search_node, SearchField as DomainSearchField, SearchMatch as DomainSearchMatch};
use memory_types::TocLevel as DomainTocLevel;

use crate::pb::{
    SearchChildrenRequest, SearchChildrenResponse,
    SearchField as ProtoSearchField,
    SearchMatch as ProtoSearchMatch,
    SearchNodeRequest, SearchNodeResponse,
    SearchNodeResult as ProtoSearchNodeResult,
    TocLevel as ProtoTocLevel,
};
```

**Implement helper functions:**

```rust
/// Convert proto SearchField to domain SearchField
fn proto_to_domain_field(proto: i32) -> Option<DomainSearchField> {
    match ProtoSearchField::try_from(proto) {
        Ok(ProtoSearchField::Title) => Some(DomainSearchField::Title),
        Ok(ProtoSearchField::Summary) => Some(DomainSearchField::Summary),
        Ok(ProtoSearchField::Bullets) => Some(DomainSearchField::Bullets),
        Ok(ProtoSearchField::Keywords) => Some(DomainSearchField::Keywords),
        _ => None, // Unspecified or invalid
    }
}

/// Convert domain SearchField to proto SearchField
fn domain_to_proto_field(domain: DomainSearchField) -> i32 {
    match domain {
        DomainSearchField::Title => ProtoSearchField::Title as i32,
        DomainSearchField::Summary => ProtoSearchField::Summary as i32,
        DomainSearchField::Bullets => ProtoSearchField::Bullets as i32,
        DomainSearchField::Keywords => ProtoSearchField::Keywords as i32,
    }
}

/// Convert domain SearchMatch to proto SearchMatch
fn domain_to_proto_match(m: DomainSearchMatch) -> ProtoSearchMatch {
    ProtoSearchMatch {
        field: domain_to_proto_field(m.field),
        text: m.text,
        grip_ids: m.grip_ids,
        score: m.score,
    }
}

/// Convert domain TocLevel to proto TocLevel
fn domain_to_proto_level(level: DomainTocLevel) -> i32 {
    match level {
        DomainTocLevel::Year => ProtoTocLevel::Year as i32,
        DomainTocLevel::Month => ProtoTocLevel::Month as i32,
        DomainTocLevel::Week => ProtoTocLevel::Week as i32,
        DomainTocLevel::Day => ProtoTocLevel::Day as i32,
        DomainTocLevel::Segment => ProtoTocLevel::Segment as i32,
    }
}
```

**Implement search_node RPC:**

```rust
/// Search within a single TOC node.
///
/// Per SEARCH-01: SearchNode searches node's fields for query terms.
pub async fn search_node(
    storage: Arc<Storage>,
    request: Request<SearchNodeRequest>,
) -> Result<Response<SearchNodeResponse>, Status> {
    let req = request.into_inner();
    debug!("SearchNode request: node_id={}, query={}", req.node_id, req.query);

    if req.node_id.is_empty() {
        return Err(Status::invalid_argument("node_id is required"));
    }

    if req.query.trim().is_empty() {
        return Err(Status::invalid_argument("query is required"));
    }

    // Load the node
    let node = storage.get_toc_node(&req.node_id)
        .map_err(|e| Status::internal(format!("Storage error: {}", e)))?
        .ok_or_else(|| Status::not_found("Node not found"))?;

    // Convert proto fields to domain fields
    let fields: Vec<DomainSearchField> = req.fields
        .iter()
        .filter_map(|f| proto_to_domain_field(*f))
        .collect();

    // Execute search
    let matches = core_search_node(&node, &req.query, &fields);

    // Apply limit
    let limit = if req.limit > 0 { req.limit as usize } else { 10 };
    let matches: Vec<ProtoSearchMatch> = matches
        .into_iter()
        .take(limit)
        .map(domain_to_proto_match)
        .collect();

    Ok(Response::new(SearchNodeResponse {
        matched: !matches.is_empty(),
        matches,
        node_id: req.node_id,
        level: domain_to_proto_level(node.level),
    }))
}
```

**Implement search_children RPC:**

```rust
/// Search across children of a parent node.
///
/// Per SEARCH-02: SearchChildren searches all children of parent.
pub async fn search_children(
    storage: Arc<Storage>,
    request: Request<SearchChildrenRequest>,
) -> Result<Response<SearchChildrenResponse>, Status> {
    let req = request.into_inner();
    debug!("SearchChildren request: parent_id={}, query={}", req.parent_id, req.query);

    if req.query.trim().is_empty() {
        return Err(Status::invalid_argument("query is required"));
    }

    // Get children of parent (empty parent_id = root level years)
    let children = if req.parent_id.is_empty() {
        storage.get_toc_nodes_by_level(DomainTocLevel::Year, None, None)
            .map_err(|e| Status::internal(format!("Storage error: {}", e)))?
    } else {
        storage.get_child_nodes(&req.parent_id)
            .map_err(|e| Status::internal(format!("Storage error: {}", e)))?
    };

    // Convert proto fields to domain fields
    let fields: Vec<DomainSearchField> = req.fields
        .iter()
        .filter_map(|f| proto_to_domain_field(*f))
        .collect();

    // Search each child and collect results
    let mut results: Vec<ProtoSearchNodeResult> = Vec::new();
    for child in children {
        let matches = core_search_node(&child, &req.query, &fields);
        if !matches.is_empty() {
            // Calculate aggregate score (average of match scores)
            let relevance = matches.iter().map(|m| m.score).sum::<f32>() / matches.len() as f32;

            results.push(ProtoSearchNodeResult {
                node_id: child.node_id.clone(),
                title: child.title.clone(),
                level: domain_to_proto_level(child.level),
                matches: matches.into_iter().map(domain_to_proto_match).collect(),
                relevance_score: relevance,
            });
        }
    }

    // Sort by relevance score descending
    results.sort_by(|a, b| b.relevance_score
        .partial_cmp(&a.relevance_score)
        .unwrap_or(Ordering::Equal));

    // Apply limit
    let limit = if req.limit > 0 { req.limit as usize } else { 10 };
    let has_more = results.len() > limit;
    let results: Vec<ProtoSearchNodeResult> = results.into_iter().take(limit).collect();

    Ok(Response::new(SearchChildrenResponse {
        results,
        has_more,
    }))
}
```

Add module-level tests:

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;
    use chrono::{TimeZone, Utc};
    use memory_types::{TocBullet, TocNode};

    fn create_test_storage() -> (Arc<Storage>, TempDir) {
        let temp_dir = TempDir::new().unwrap();
        let storage = Arc::new(Storage::open(temp_dir.path()).unwrap());
        (storage, temp_dir)
    }

    #[tokio::test]
    async fn test_search_node_not_found() {
        let (storage, _temp) = create_test_storage();
        let request = Request::new(SearchNodeRequest {
            node_id: "nonexistent".to_string(),
            query: "test".to_string(),
            fields: vec![],
            limit: 10,
            token_budget: 0,
        });
        let result = search_node(storage, request).await;
        assert!(result.is_err());
    }

    #[tokio::test]
    async fn test_search_node_empty_query() {
        let (storage, _temp) = create_test_storage();
        let request = Request::new(SearchNodeRequest {
            node_id: "toc:year:2026".to_string(),
            query: "".to_string(),
            fields: vec![],
            limit: 10,
            token_budget: 0,
        });
        let result = search_node(storage, request).await;
        assert!(result.is_err());
    }

    #[tokio::test]
    async fn test_search_children_empty_query() {
        let (storage, _temp) = create_test_storage();
        let request = Request::new(SearchChildrenRequest {
            parent_id: "".to_string(),
            query: "   ".to_string(),
            child_level: 0,
            fields: vec![],
            limit: 10,
            token_budget: 0,
        });
        let result = search_children(storage, request).await;
        assert!(result.is_err());
    }
}
```
  </action>
  <verify>
`cargo check -p memory-service` compiles without errors.
  </verify>
  <done>
search_service.rs created with search_node() and search_children() RPC handlers following existing query.rs patterns.
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire search handlers into MemoryService</name>
  <files>crates/memory-service/src/lib.rs, crates/memory-service/src/server.rs</files>
  <action>
**1. Update lib.rs** - Add search_service module:
```rust
pub mod search_service;
```

**2. Update server.rs** - Wire search RPCs to MemoryServiceImpl.

Find the `#[tonic::async_trait]` impl block for `MemoryService` and add:

```rust
async fn search_node(
    &self,
    request: Request<SearchNodeRequest>,
) -> Result<Response<SearchNodeResponse>, Status> {
    crate::search_service::search_node(Arc::clone(&self.storage), request).await
}

async fn search_children(
    &self,
    request: Request<SearchChildrenRequest>,
) -> Result<Response<SearchChildrenResponse>, Status> {
    crate::search_service::search_children(Arc::clone(&self.storage), request).await
}
```

Add necessary imports to server.rs:
```rust
use crate::pb::{
    // ... existing imports ...
    SearchNodeRequest, SearchNodeResponse,
    SearchChildrenRequest, SearchChildrenResponse,
};
```

**3. Build and verify integration:**
- Proto regenerates with new RPCs
- Service compiles with new handlers wired
- Existing tests still pass
  </action>
  <verify>
`cargo build -p memory-service` compiles. `cargo test -p memory-service` passes all tests.
  </verify>
  <done>
Search handlers wired into MemoryServiceImpl. SearchNode and SearchChildren RPCs available via gRPC.
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. `cargo build -p memory-service` - Service compiles with search RPCs
2. `cargo test -p memory-service` - All tests pass (including new search tests)
3. Proto inspection: `grep -n "SearchNode\|SearchChildren" proto/memory.proto` shows RPCs defined
4. Run daemon and verify reflection shows new RPCs (optional manual test)
</verification>

<success_criteria>
- Proto defines SearchField enum, SearchNode/SearchChildren messages and RPCs
- search_service.rs implements both RPC handlers
- Handlers wired into MemoryServiceImpl
- Proto-to-domain conversions follow existing patterns
- All tests pass
- gRPC reflection shows SearchNode and SearchChildren RPCs
</success_criteria>

<output>
After completion, create `.planning/phases/10.5-agentic-toc-search/10.5-02-SUMMARY.md`
</output>
