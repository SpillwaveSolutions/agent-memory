---
phase: 10.5-agentic-toc-search
plan: 03
type: execute
wave: 3
depends_on: ["10.5-02"]
files_modified:
  - crates/memory-daemon/src/cli.rs
  - crates/memory-daemon/src/commands.rs
  - plugins/memory-query-plugin/skills/memory-query/SKILL.md
  - plugins/memory-query-plugin/skills/memory-query/references/command-reference.md
autonomous: true

must_haves:
  truths:
    - "CLI search command searches TOC nodes for matching content"
    - "SKILL.md documents search capability for agents"
    - "Agent can navigate TOC using search to find relevant content"
    - "Search results show node IDs, titles, matches, and scores"
  artifacts:
    - path: "crates/memory-daemon/src/cli.rs"
      provides: "Search CLI command definition"
      contains: "Search {"
    - path: "crates/memory-daemon/src/commands.rs"
      provides: "Search command handler"
      contains: "handle_search"
    - path: "plugins/memory-query-plugin/skills/memory-query/SKILL.md"
      provides: "Updated skill with search documentation"
      contains: "/memory-search"
  key_links:
    - from: "commands.rs"
      to: "SearchNodeRequest/SearchChildrenRequest"
      via: "gRPC client call"
      pattern: "search_node\\|search_children"
---

<objective>
Add CLI search command and update memory-query skill documentation with search capabilities.

Purpose: Enable developers to test search via CLI and provide agents with search-based navigation documentation. This completes the user-facing interface for agentic TOC search.

Output: Working `memory-daemon query search` command and updated SKILL.md with search navigation patterns.
</objective>

<execution_context>
@/Users/richardhightower/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardhightower/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/10.5-agentic-toc-search/10.5-02-SUMMARY.md
@.planning/phases/10.5-agentic-toc-search/10.5-RESEARCH.md

Reference files:
@crates/memory-daemon/src/cli.rs (CLI pattern)
@crates/memory-daemon/src/commands.rs (command handler pattern)
@plugins/memory-query-plugin/skills/memory-query/SKILL.md (skill documentation)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Search command to CLI</name>
  <files>crates/memory-daemon/src/cli.rs</files>
  <action>
Add `Search` variant to `QueryCommands` enum in cli.rs:

```rust
/// Query subcommands
#[derive(Subcommand, Debug, Clone)]
pub enum QueryCommands {
    // ... existing commands: Root, Node, Browse, Events, Expand ...

    /// Search TOC nodes for matching content
    Search {
        /// Search query terms (space-separated)
        #[arg(short, long)]
        query: String,

        /// Search within a specific node (mutually exclusive with --parent)
        #[arg(long, conflicts_with = "parent")]
        node: Option<String>,

        /// Search children of a parent node (empty for root level)
        #[arg(long, conflicts_with = "node")]
        parent: Option<String>,

        /// Fields to search: title, summary, bullets, keywords (comma-separated)
        #[arg(long)]
        fields: Option<String>,

        /// Maximum results to return
        #[arg(short, long, default_value = "10")]
        limit: u32,
    },
}
```

The command supports two modes:
1. `--node <id>` - Search within a single node (SearchNode RPC)
2. `--parent <id>` - Search children of parent (SearchChildren RPC)
3. Neither - Search at root level (years)
  </action>
  <verify>
`cargo check -p memory-daemon` compiles without errors.
  </verify>
  <done>
Search command added to QueryCommands enum with query, node, parent, fields, and limit arguments.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement search command handler</name>
  <files>crates/memory-daemon/src/commands.rs</files>
  <action>
Add search handling to `handle_query()` function in commands.rs.

**1. Add imports** at the top of the file:
```rust
use memory_service::pb::{
    // ... existing imports ...
    SearchNodeRequest, SearchChildrenRequest,
    SearchField as ProtoSearchField,
};
```

**2. Add match arm** in handle_query() function:
```rust
QueryCommands::Search { query, node, parent, fields, limit } => {
    handle_search(&mut client, query, node, parent, fields, limit).await?
}
```

**3. Implement handle_search function:**

```rust
/// Handle search command
async fn handle_search(
    client: &mut MemoryClient<tonic::transport::Channel>,
    query: String,
    node: Option<String>,
    parent: Option<String>,
    fields_str: Option<String>,
    limit: u32,
) -> Result<()> {
    // Parse fields from comma-separated string
    let fields: Vec<i32> = fields_str
        .map(|s| {
            s.split(',')
                .filter_map(|f| match f.trim().to_lowercase().as_str() {
                    "title" => Some(ProtoSearchField::Title as i32),
                    "summary" => Some(ProtoSearchField::Summary as i32),
                    "bullets" => Some(ProtoSearchField::Bullets as i32),
                    "keywords" => Some(ProtoSearchField::Keywords as i32),
                    _ => None,
                })
                .collect()
        })
        .unwrap_or_default();

    if let Some(node_id) = node {
        // Search within single node
        let response = client
            .search_node(SearchNodeRequest {
                node_id: node_id.clone(),
                query: query.clone(),
                fields: fields.clone(),
                limit: limit as i32,
                token_budget: 0,
            })
            .await
            .context("SearchNode RPC failed")?;

        let resp = response.into_inner();
        println!("Search Results for node: {}", node_id);
        println!("Query: \"{}\"", query);
        println!("Matched: {}", resp.matched);
        println!();

        if resp.matches.is_empty() {
            println!("No matches found.");
        } else {
            for (i, m) in resp.matches.iter().enumerate() {
                let field_name = match ProtoSearchField::try_from(m.field) {
                    Ok(ProtoSearchField::Title) => "title",
                    Ok(ProtoSearchField::Summary) => "summary",
                    Ok(ProtoSearchField::Bullets) => "bullets",
                    Ok(ProtoSearchField::Keywords) => "keywords",
                    _ => "unknown",
                };
                println!("{}. [{}] score={:.2}", i + 1, field_name, m.score);
                println!("   Text: {}", truncate_text(&m.text, 100));
                if !m.grip_ids.is_empty() {
                    println!("   Grips: {}", m.grip_ids.join(", "));
                }
            }
        }
    } else {
        // Search children of parent (or root if no parent)
        let parent_id = parent.unwrap_or_default();
        let response = client
            .search_children(SearchChildrenRequest {
                parent_id: parent_id.clone(),
                query: query.clone(),
                child_level: 0, // Ignored when parent_id is provided
                fields: fields.clone(),
                limit: limit as i32,
                token_budget: 0,
            })
            .await
            .context("SearchChildren RPC failed")?;

        let resp = response.into_inner();
        let scope = if parent_id.is_empty() {
            "root level".to_string()
        } else {
            format!("children of {}", parent_id)
        };
        println!("Search Results for {}", scope);
        println!("Query: \"{}\"", query);
        println!("Found: {} nodes", resp.results.len());
        if resp.has_more {
            println!("(more results available, increase --limit)");
        }
        println!();

        if resp.results.is_empty() {
            println!("No matching nodes found.");
        } else {
            for result in resp.results {
                println!("Node: {} (score={:.2})", result.node_id, result.relevance_score);
                println!("  Title: {}", result.title);
                println!("  Matches:");
                for m in result.matches.iter().take(3) {
                    let field_name = match ProtoSearchField::try_from(m.field) {
                        Ok(ProtoSearchField::Title) => "title",
                        Ok(ProtoSearchField::Summary) => "summary",
                        Ok(ProtoSearchField::Bullets) => "bullets",
                        Ok(ProtoSearchField::Keywords) => "keywords",
                        _ => "unknown",
                    };
                    println!("    - [{}] {}", field_name, truncate_text(&m.text, 80));
                }
                if result.matches.len() > 3 {
                    println!("    ... and {} more matches", result.matches.len() - 3);
                }
                println!();
            }
        }
    }

    Ok(())
}

/// Truncate text for display
fn truncate_text(text: &str, max_len: usize) -> String {
    if text.len() <= max_len {
        text.to_string()
    } else {
        format!("{}...", &text[..max_len.saturating_sub(3)])
    }
}
```

Note: If truncate_text already exists in the file, reuse it instead of adding a new one.
  </action>
  <verify>
`cargo build -p memory-daemon` compiles. Test CLI parsing with `cargo run -p memory-daemon -- query search --help`.
  </verify>
  <done>
handle_search() function implemented. Supports both single-node and children search with formatted output showing matches, scores, and grip IDs.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update SKILL.md with search documentation</name>
  <files>plugins/memory-query-plugin/skills/memory-query/SKILL.md, plugins/memory-query-plugin/skills/memory-query/references/command-reference.md</files>
  <action>
**1. Update SKILL.md** - Add search capability and navigation pattern.

Replace the Quick Start table with expanded version:
```markdown
## Quick Start

| Command | Purpose | Example |
|---------|---------|---------|
| `/memory-search <topic>` | Search by topic | `/memory-search authentication` |
| `/memory-recent` | Recent summaries | `/memory-recent --days 7` |
| `/memory-context <grip>` | Expand excerpt | `/memory-context grip:...` |
```

Add new section after "TOC Navigation":
```markdown
## Search-Based Navigation

Use search RPCs to efficiently find relevant content without scanning everything.

### Search Workflow

1. **Search at root level** - Find which time periods are relevant:
   ```bash
   memory-daemon query search --query "JWT authentication"
   # Returns: Year/Month nodes with relevance scores
   ```

2. **Drill into best match** - Search children of matching period:
   ```bash
   memory-daemon query search --parent "toc:month:2026-01" --query "JWT authentication"
   # Returns: Week nodes with matches
   ```

3. **Continue until Segment level** - Extract evidence:
   ```bash
   memory-daemon query search --parent "toc:day:2026-01-30" --query "JWT"
   # Returns: Segment nodes with bullet matches and grip IDs
   ```

4. **Expand grip for verification**:
   ```bash
   memory-daemon query expand --grip-id "grip:..." --before 3 --after 3
   ```

### Search Command Reference

```bash
# Search within a specific node
memory-daemon query search --node "toc:month:2026-01" --query "debugging"

# Search children of a parent
memory-daemon query search --parent "toc:week:2026-W04" --query "JWT token"

# Search root level (years)
memory-daemon query search --query "authentication"

# Filter by fields (title, summary, bullets, keywords)
memory-daemon query search --query "JWT" --fields "title,bullets" --limit 20
```

### Agent Navigation Loop

When answering "find discussions about X":

1. Parse query for time hints ("last week", "in January", "yesterday")
2. Start at appropriate level based on hints, or root if no hints
3. Use `search_children` to find relevant nodes at each level
4. Drill into highest-scoring matches
5. At Segment level, extract bullets with grip IDs
6. Offer to expand grips for full context

Example path:
```
Query: "What JWT discussions happened last week?"
→ SearchChildren(parent="toc:week:2026-W04", query="JWT")
  → Day 2026-01-30 (score: 0.85)
→ SearchChildren(parent="toc:day:2026-01-30", query="JWT")
  → Segment abc123 (score: 0.92)
→ Return bullets from Segment with grip IDs
→ Offer: "Found 2 relevant points. Expand grip:xyz for context?"
```
```

**2. Update command-reference.md** - Add search command documentation.

Add new section:
```markdown
## Search Commands

### search

Search TOC nodes for matching content.

**Usage:**
```bash
memory-daemon query search --query <QUERY> [OPTIONS]
```

**Options:**
| Option | Description | Default |
|--------|-------------|---------|
| `--query`, `-q` | Search terms (required) | - |
| `--node` | Search within specific node | - |
| `--parent` | Search children of parent | - |
| `--fields` | Fields to search (comma-separated) | all |
| `--limit`, `-l` | Maximum results | 10 |

**Fields:**
- `title` - Node title
- `summary` - Derived from bullets
- `bullets` - Individual bullet points (includes grip IDs)
- `keywords` - Extracted keywords

**Examples:**
```bash
# Search at root level
memory-daemon query search --query "authentication debugging"

# Search within month
memory-daemon query search --node "toc:month:2026-01" --query "JWT"

# Search week's children (days)
memory-daemon query search --parent "toc:week:2026-W04" --query "token refresh"

# Search only in bullets and keywords
memory-daemon query search --query "OAuth" --fields "bullets,keywords" --limit 20
```

**Output:**
```
Search Results for children of toc:week:2026-W04
Query: "token refresh"
Found: 2 nodes

Node: toc:day:2026-01-30 (score=0.85)
  Title: Thursday, January 30
  Matches:
    - [bullets] Fixed JWT token refresh rotation
    - [keywords] authentication
```
```
  </action>
  <verify>
Files updated without syntax errors. Documentation is clear and follows existing formatting patterns.
  </verify>
  <done>
SKILL.md updated with search-based navigation workflow. command-reference.md includes search command documentation with examples.
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. `cargo build -p memory-daemon` - Daemon compiles with search command
2. `cargo run -p memory-daemon -- query search --help` - Help text shows search options
3. Manual test (if daemon running with data):
   ```bash
   memory-daemon query search --query "test" --limit 5
   ```
4. Review SKILL.md for clarity and completeness
</verification>

<success_criteria>
- CLI `search` command added to QueryCommands enum
- handle_search() implements both single-node and children search
- Output shows node IDs, titles, matches with field names, scores, and grip IDs
- SKILL.md documents search workflow and navigation pattern
- command-reference.md includes search command documentation
- Agent can follow documented workflow to find content using search
</success_criteria>

<output>
After completion, create `.planning/phases/10.5-agentic-toc-search/10.5-03-SUMMARY.md`
</output>
