# Phase 10.5: Agentic TOC Search - Research

**Researched:** 2026-02-01
**Domain:** Index-free search using simple term matching, TOC navigation, gRPC service patterns
**Confidence:** HIGH

## Summary

Phase 10.5 adds foundational agentic search using TOC navigation with simple term matching - the "always works" layer that requires no external index dependencies. This phase validates the existing comprehensive PRD and technical plan against the actual codebase, ensuring alignment with established patterns.

The codebase already has term-matching logic in `GripExtractor` (using 30%+ term overlap threshold) and well-established patterns for gRPC services, CLI commands, and Storage access. The `TocNode` structure provides all required searchable fields: `title`, `summary` (derived from bullets), `bullets` (with `grip_ids`), and `keywords`. The technical plan's proposed `search_node()` function closely mirrors the existing `find_best_match()` pattern in grip extraction.

Integration points are clear: extend `memory.proto` with new RPCs, add `search.rs` module to `memory-toc` crate, extend `memory-service` query handlers, and add CLI subcommand following the existing `QueryCommands` pattern. The existing `memory-navigator.md` agent already describes the multi-period navigation loop - Phase 10.5 provides the search primitives it needs.

**Primary recommendation:** Implement as planned in the technical spec, following existing codebase patterns. Key additions: SearchField enum, term_overlap_score() function, SearchNode/SearchChildren RPCs, and CLI search command. Update the memory-navigator agent with search-based navigation.

## Standard Stack

The established libraries/tools for this domain:

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| (existing) memory-types | workspace | TocNode, TocBullet, Grip types | Already defines all searchable fields |
| (existing) memory-storage | workspace | Storage::get_toc_node, get_child_nodes | Already provides node access methods |
| (existing) memory-service | workspace | gRPC handlers, proto integration | Established pattern for query RPCs |
| (existing) tonic | workspace | gRPC framework | Already used for all RPCs |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| (existing) tracing | workspace | Logging/spans | For search duration metrics |
| (existing) clap | workspace | CLI parsing | For search command arguments |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Simple term overlap | Regex matching | More complex, not needed for MVP |
| In-memory search | Tantivy (Phase 11) | Adds dependencies, defeats purpose of "always works" |
| Custom scorer | BM25 | Phase 11 concern, not needed for basic navigation |

**Installation:**
No new dependencies needed - uses existing workspace crates.

## Architecture Patterns

### Recommended Project Structure
```
crates/memory-toc/src/
  search.rs             # NEW: search_node(), term_overlap_score()
  lib.rs                # Export search module

crates/memory-service/src/
  search_service.rs     # NEW: SearchNode, SearchChildren handlers (or extend query.rs)

proto/
  memory.proto          # EXTEND: Add SearchNode, SearchChildren RPCs

crates/memory-daemon/src/
  cli.rs                # EXTEND: Add Search command
  commands.rs           # EXTEND: Add handle_search()

plugins/memory-query-plugin/
  agents/memory-navigator.md  # UPDATE: Add search-based navigation
```

### Pattern 1: Term Overlap Scoring (FROM CODEBASE)
**What:** Calculate relevance as matched_terms / total_terms
**When to use:** For all field matching in search_node()
**Source:** `crates/memory-toc/src/summarizer/grip_extractor.rs` lines 82-124
**Example:**
```rust
// Existing pattern from grip_extractor.rs
let key_terms: Vec<&str> = query
    .split_whitespace()
    .filter(|w| w.len() > 3)  // Filter short words
    .collect();

let text_lower = text.to_lowercase();
let score: f32 = key_terms
    .iter()
    .filter(|term| text_lower.contains(&term.to_lowercase()))
    .count() as f32
    / key_terms.len() as f32;
```

### Pattern 2: Proto Enum Prefixing (FROM CODEBASE)
**What:** Use prefixes like `SEARCH_FIELD_` for proto enums
**When to use:** When adding new proto enums
**Source:** `proto/memory.proto` - EventRole uses `EVENT_ROLE_` prefix
**Example:**
```protobuf
// Follow existing pattern from EventRole/EventType
enum SearchField {
  SEARCH_FIELD_UNSPECIFIED = 0;
  SEARCH_FIELD_TITLE = 1;
  SEARCH_FIELD_SUMMARY = 2;
  SEARCH_FIELD_BULLETS = 3;
  SEARCH_FIELD_KEYWORDS = 4;
}
```

### Pattern 3: Query RPC Handler (FROM CODEBASE)
**What:** Async function taking Arc<Storage> and Request, returning Result<Response, Status>
**When to use:** For SearchNode and SearchChildren implementations
**Source:** `crates/memory-service/src/query.rs` lines 31-47
**Example:**
```rust
// Follow get_toc_root pattern from query.rs
pub async fn search_node(
    storage: Arc<Storage>,
    request: Request<SearchNodeRequest>,
) -> Result<Response<SearchNodeResponse>, Status> {
    let req = request.into_inner();
    debug!("SearchNode request: node_id={}, query={}", req.node_id, req.query);

    // Load node via storage
    let node = storage.get_toc_node(&req.node_id)
        .map_err(|e| Status::internal(format!("Storage error: {}", e)))?
        .ok_or_else(|| Status::not_found("Node not found"))?;

    // Execute search logic from memory-toc
    let matches = memory_toc::search::search_node(&node, &req.query, &req.fields);

    // Apply limit and convert to proto
    // ...
}
```

### Pattern 4: CLI Subcommand (FROM CODEBASE)
**What:** QueryCommands enum with subcommands
**When to use:** For adding search command
**Source:** `crates/memory-daemon/src/cli.rs` lines 83-136
**Example:**
```rust
// Add to QueryCommands enum
/// Search TOC nodes for matching content
Search {
    /// Search query terms
    #[arg(long)]
    query: String,

    /// Node ID to search within (for SearchNode)
    #[arg(long)]
    node: Option<String>,

    /// Parent node ID to search children of (for SearchChildren)
    #[arg(long)]
    parent: Option<String>,

    /// Maximum results to return
    #[arg(short, long, default_value = "10")]
    limit: u32,
}
```

### Pattern 5: Domain-to-Proto Conversion (FROM CODEBASE)
**What:** Separate conversion functions for type mapping
**When to use:** For SearchMatch and SearchNodeResult conversion
**Source:** `crates/memory-service/src/query.rs` lines 266-332
**Example:**
```rust
// Follow domain_to_proto_node pattern
fn domain_to_proto_match(m: SearchMatch) -> ProtoSearchMatch {
    ProtoSearchMatch {
        field: match m.field {
            SearchField::Title => ProtoSearchField::Title,
            SearchField::Summary => ProtoSearchField::Summary,
            SearchField::Bullets => ProtoSearchField::Bullets,
            SearchField::Keywords => ProtoSearchField::Keywords,
        } as i32,
        text: m.text,
        grip_ids: m.grip_ids,
        score: m.score,
    }
}
```

### Anti-Patterns to Avoid
- **Blocking async with sync search:** Use `tokio::task::spawn_blocking` only if search becomes expensive (unlikely for simple term matching)
- **Storing search results:** No caching needed - searches are fast and data changes
- **Complex query parsing:** Simple space-separated terms for MVP
- **Searching all nodes:** Always scope to a specific node or parent's children

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Node retrieval | Direct RocksDB access | `Storage::get_toc_node()` | Already handles versioning, error mapping |
| Child enumeration | Manual key iteration | `Storage::get_child_nodes()` | Already loads and sorts children |
| Proto generation | Manual message building | tonic build.rs | Existing proto compilation pipeline |
| Error mapping | Custom error types | `Status::*` constructors | Consistent with existing RPCs |
| Level conversion | String parsing | `TocLevel` enum methods | Existing `parent()`, `child()` methods |

**Key insight:** The codebase has mature patterns for everything needed. Phase 10.5 is glue code connecting existing capabilities, not building new infrastructure.

## Common Pitfalls

### Pitfall 1: Empty Query After Filtering
**What goes wrong:** User searches "the a to" and all terms get filtered (< 3 chars), returning no results
**Why it happens:** Technical plan filters terms `< 3 chars` to reduce noise
**How to avoid:** Check for empty terms after filtering, return early with helpful message
**Warning signs:** Searches with only stop words return empty results silently
**Code pattern:**
```rust
let terms: Vec<&str> = query.split_whitespace()
    .filter(|t| t.len() >= 3)  // Changed from > 2 to >= 3 for consistency
    .collect();

if terms.is_empty() {
    return SearchNodeResponse { matched: false, matches: vec![], ..default() };
}
```

### Pitfall 2: Case Sensitivity in Keywords
**What goes wrong:** Search for "jwt" doesn't match keyword "JWT"
**Why it happens:** Keywords stored with original casing, not lowercased
**How to avoid:** Always lowercase both query terms AND text being searched
**Warning signs:** Known keywords don't match
**Code pattern:**
```rust
// Both sides lowercased
let text_lower = text.to_lowercase();
let term_lower = term.to_lowercase();
text_lower.contains(&term_lower)
```

### Pitfall 3: Missing Summary Generation
**What goes wrong:** SearchField::Summary matches nothing because TocNode.summary is derived from bullets
**Why it happens:** TocNode structure has no explicit `summary` field - PRD assumes one exists
**How to avoid:** Generate summary from bullets for search, matching what query.rs does
**Warning signs:** Summary field searches always return empty
**Code pattern:**
```rust
// From query.rs line 284-288: summary is generated from bullets
let summary = if !bullets.is_empty() {
    Some(bullets.iter().map(|b| b.text.clone()).collect::<Vec<_>>().join(" "))
} else {
    None
};
```

### Pitfall 4: Score Aggregation for SearchChildren
**What goes wrong:** Node with many low-score matches ranks higher than node with one perfect match
**Why it happens:** Using sum of scores vs. max or average
**How to avoid:** Use average score as in technical plan, or consider max
**Warning signs:** Broadly matching nodes outrank specific matches
**Code pattern:**
```rust
// Technical plan uses average
let relevance = matches.iter().map(|m| m.score).sum::<f32>() / matches.len() as f32;
```

### Pitfall 5: Proto Field Numbering Conflicts
**What goes wrong:** Wire format breaks existing clients
**Why it happens:** Reusing field numbers when extending proto
**How to avoid:** Always use new field numbers, never reorder
**Warning signs:** Deserialization errors from existing clients
**Code pattern:**
```protobuf
// Current highest field number in TocNode is 10 (version)
// New search messages should start fresh at 1
```

## Code Examples

Verified patterns from the codebase:

### TocNode Structure (FROM CODEBASE)
```rust
// Source: crates/memory-types/src/toc.rs lines 88-124
pub struct TocNode {
    pub node_id: String,           // "toc:year:2026", "toc:month:2026-01", etc.
    pub level: TocLevel,           // Year, Month, Week, Day, Segment
    pub title: String,             // "January 2026", "Week of Jan 27", etc.
    pub start_time: DateTime<Utc>,
    pub end_time: DateTime<Utc>,
    pub bullets: Vec<TocBullet>,   // Summary points with grip_ids
    pub keywords: Vec<String>,     // Searchable keywords
    pub child_node_ids: Vec<String>,
    pub version: u32,
    pub created_at: DateTime<Utc>,
}
```

### TocBullet with Grip IDs (FROM CODEBASE)
```rust
// Source: crates/memory-types/src/toc.rs lines 59-81
pub struct TocBullet {
    pub text: String,
    pub grip_ids: Vec<String>,  // Links to source evidence
}
```

### Storage Access for Nodes (FROM CODEBASE)
```rust
// Source: crates/memory-storage/src/db.rs lines 231-333
impl Storage {
    pub fn get_toc_node(&self, node_id: &str) -> Result<Option<TocNode>, StorageError>;
    pub fn get_toc_nodes_by_level(...) -> Result<Vec<TocNode>, StorageError>;
    pub fn get_child_nodes(&self, parent_node_id: &str) -> Result<Vec<TocNode>, StorageError>;
}
```

### Grip Extractor Term Matching (FROM CODEBASE)
```rust
// Source: crates/memory-toc/src/summarizer/grip_extractor.rs lines 82-124
fn find_best_match(&self, events: &[Event], bullet: &str, source: &str) -> Option<Grip> {
    let key_terms: Vec<&str> = bullet
        .split_whitespace()
        .filter(|w| w.len() > 3)
        .collect();

    if key_terms.is_empty() {
        return None;
    }

    for (idx, event) in events.iter().enumerate() {
        let text_lower = event.text.to_lowercase();
        let score: f32 = key_terms
            .iter()
            .filter(|term| text_lower.contains(&term.to_lowercase()))
            .count() as f32
            / key_terms.len() as f32;

        if score > 0.3 {  // 30% threshold
            // ... match found
        }
    }
}
```

### Query RPC Pattern (FROM CODEBASE)
```rust
// Source: crates/memory-service/src/query.rs
pub async fn browse_toc(
    storage: Arc<Storage>,
    request: Request<BrowseTocRequest>,
) -> Result<Response<BrowseTocResponse>, Status> {
    let req = request.into_inner();
    debug!("BrowseToc request: parent={}, limit={}", req.parent_id, req.limit);

    let all_children = storage.get_child_nodes(&req.parent_id)
        .map_err(|e| Status::internal(format!("Storage error: {}", e)))?;

    // ... pagination and response building
}
```

### CLI Command Handler (FROM CODEBASE)
```rust
// Source: crates/memory-daemon/src/commands.rs lines 295-423
pub async fn handle_query(endpoint: &str, command: QueryCommands) -> Result<()> {
    let mut client = MemoryClient::connect(endpoint)
        .await
        .context("Failed to connect to daemon")?;

    match command {
        QueryCommands::Root => { /* ... */ }
        QueryCommands::Node { node_id } => { /* ... */ }
        QueryCommands::Browse { parent_id, limit, token } => { /* ... */ }
        // Add: QueryCommands::Search { query, node, parent, limit } => { /* ... */ }
    }
}
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Scan all events | TOC hierarchy search | Phase 2-4 | 10-100x faster for "what did we discuss" queries |
| No search primitives | SearchNode + SearchChildren | Phase 10.5 (this phase) | Enables agent-guided navigation |

**Note:** This phase is intentionally simple. BM25 (Phase 11) and vector search (Phase 12) add sophistication later. Phase 10.5's term matching serves as fallback when indexes are unavailable.

## Integration Points

### Codebase-Specific Details

| Component | Existing Code | Integration Point |
|-----------|---------------|-------------------|
| TocNode fields | `crates/memory-types/src/toc.rs` | Search title, bullets, keywords |
| Storage access | `Storage::get_toc_node()`, `get_child_nodes()` | Use existing methods |
| gRPC service | `crates/memory-service/src/query.rs` | Follow same async handler pattern |
| Proto definitions | `proto/memory.proto` | Add RPCs after line 45 |
| CLI parsing | `crates/memory-daemon/src/cli.rs` | Add to QueryCommands enum |
| CLI handlers | `crates/memory-daemon/src/commands.rs` | Add match arm in handle_query |
| Navigator agent | `plugins/memory-query-plugin/agents/memory-navigator.md` | Add search-based navigation loop |

### Gaps Between Technical Plan and Codebase

| Technical Plan | Codebase Reality | Resolution |
|----------------|------------------|------------|
| `TocNode.summary` field | Derived from bullets in query.rs | Generate summary from bullets for search |
| New `search_service.rs` file | Could extend `query.rs` | Either works; new file keeps concerns separate |
| `search.rs` in memory-toc | Module doesn't exist | Create new module, export from lib.rs |
| `MemoryClient` search methods | Not implemented | Need to extend memory-client crate |

## Navigator Agent Search Loop

The existing `memory-navigator.md` agent describes the navigation process but lacks search primitives. After Phase 10.5, the agent should use:

```markdown
## Updated Process (for Phase 10.5)

1. **Parse query** for time hints and keywords
2. **Start navigation**:
   - If time hint present: SearchChildren(parent=time_node, query=keywords)
   - If no time hint: SearchChildren(parent="", query=keywords) for year-level search
3. **Drill down loop**:
   ```bash
   # Example CLI workflow
   memory-daemon query search --parent "toc:year:2026" --query "JWT authentication" --limit 5
   # Returns: [Month 2026-01 score=0.85, Month 2025-12 score=0.3]

   memory-daemon query search --parent "toc:month:2026-01" --query "JWT authentication" --limit 5
   # Returns: [Week 2026-W04 score=0.92, Week 2026-W03 score=0.6]
   ```
4. **At Segment level**: Return bullets with grip_ids
5. **Offer grip expansion**: For verification via existing ExpandGrip RPC
```

## Open Questions

Things that couldn't be fully resolved:

1. **Token budget estimation**
   - What we know: Technical plan mentions `token_budget` parameter
   - What's unclear: How to estimate tokens from search results
   - Recommendation: Defer to Phase 11+ or use character count as proxy (4 chars ~ 1 token)

2. **Minimum term length**
   - What we know: GripExtractor uses `> 3` (meaning 4+), technical plan uses `> 2` (meaning 3+)
   - What's unclear: Which is better for search quality
   - Recommendation: Use 3+ characters (matching technical plan) for broader matches

3. **Navigate CLI command**
   - What we know: Technical plan proposes `memory-daemon navigate "natural query"`
   - What's unclear: Whether this should be CLI or agent-only
   - Recommendation: Defer to Wave 3; focus on search primitives first

## Sources

### Primary (HIGH confidence)
- `/Users/richardhightower/clients/spillwave/src/agent-memory/crates/memory-types/src/toc.rs` - TocNode, TocBullet definitions
- `/Users/richardhightower/clients/spillwave/src/agent-memory/crates/memory-storage/src/db.rs` - Storage access patterns
- `/Users/richardhightower/clients/spillwave/src/agent-memory/crates/memory-service/src/query.rs` - Query RPC patterns
- `/Users/richardhightower/clients/spillwave/src/agent-memory/crates/memory-toc/src/summarizer/grip_extractor.rs` - Term matching pattern
- `/Users/richardhightower/clients/spillwave/src/agent-memory/crates/memory-daemon/src/cli.rs` - CLI command patterns
- `/Users/richardhightower/clients/spillwave/src/agent-memory/proto/memory.proto` - Proto message patterns

### Secondary (MEDIUM confidence)
- `/Users/richardhightower/clients/spillwave/src/agent-memory/docs/plans/phase-10.5-agentic-toc-search.md` - Technical plan
- `/Users/richardhightower/clients/spillwave/src/agent-memory/docs/prds/agentic-toc-search-prd.md` - PRD

### Tertiary (LOW confidence)
- None - this phase uses only existing codebase patterns

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - Using only existing workspace crates
- Architecture: HIGH - Following established codebase patterns exactly
- Pitfalls: HIGH - Identified from actual code review
- Integration approach: HIGH - Clear mapping to existing code

**Research date:** 2026-02-01
**Valid until:** 2026-03-01 (30 days - codebase patterns are stable)

---

## Recommended Plan Breakdown

Based on this research, Phase 10.5 should follow the technical plan's 3-wave structure:

### Plan 10.5-01: Core Search Logic (Wave 1)
**Focus:** Implement search_node() function and term overlap scoring
**Tasks:**
- Create `crates/memory-toc/src/search.rs` module
- Define `SearchField` enum (Title, Summary, Bullets, Keywords)
- Define `SearchMatch` struct with field, text, grip_ids, score
- Implement `term_overlap_score()` function (port from grip_extractor pattern)
- Implement `search_node()` function for single-node search
- Export from lib.rs
- Add comprehensive unit tests

### Plan 10.5-02: gRPC Integration (Wave 2)
**Focus:** Add SearchNode and SearchChildren RPCs
**Tasks:**
- Extend `proto/memory.proto` with search messages and RPCs
- Add `search_service.rs` to memory-service (or extend query.rs)
- Implement `search_node()` RPC handler
- Implement `search_children()` RPC handler
- Wire handlers into MemoryService trait implementation
- Add integration tests

### Plan 10.5-03: CLI and Agent (Wave 3)
**Focus:** CLI command and navigator agent updates
**Tasks:**
- Add `Search` variant to `QueryCommands` enum
- Implement `handle_search()` in commands.rs
- Extend MemoryClient with search methods
- Update `memory-navigator.md` agent with search-based navigation
- Update `SKILL.md` with search commands
- Add search API reference documentation
- End-to-end test via CLI
