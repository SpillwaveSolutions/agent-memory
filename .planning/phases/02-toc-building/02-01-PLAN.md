---
phase: 02-toc-building
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/memory-types/src/segment.rs
  - crates/memory-types/src/lib.rs
  - crates/memory-toc/Cargo.toml
  - crates/memory-toc/src/lib.rs
  - crates/memory-toc/src/segmenter.rs
  - crates/memory-toc/src/config.rs
  - Cargo.toml
autonomous: true

must_haves:
  truths:
    - "Segment struct exists with events, overlap_events, start/end times, token count"
    - "SegmentationConfig has time_threshold (30min), token_threshold (4K), overlap settings"
    - "SegmentBuilder detects boundaries based on time gaps and token counts"
    - "Overlap events from previous segment included for context continuity"
    - "Token counting works for event text"
  artifacts:
    - path: "crates/memory-types/src/segment.rs"
      provides: "Segment type with overlap support"
      exports: ["Segment"]
    - path: "crates/memory-toc/src/segmenter.rs"
      provides: "Segmentation engine with boundary detection"
      exports: ["SegmentBuilder", "SegmentationConfig"]
    - path: "crates/memory-toc/src/config.rs"
      provides: "TOC configuration types"
      exports: ["TocConfig", "SegmentationConfig"]
  key_links:
    - from: "crates/memory-toc/src/segmenter.rs"
      to: "crates/memory-types/src/event.rs"
      via: "Event processing"
      pattern: "Event"
---

<objective>
Implement the segmentation engine that groups events into segments based on time gaps and token thresholds.

Purpose: Enable TOC building by creating coherent conversation segments that can be summarized.
Output: SegmentBuilder that produces Segment structs with proper overlap handling.
</objective>

<execution_context>
@/Users/richardhightower/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardhightower/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-toc-building/02-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create memory-toc crate and add Segment type</name>
  <files>
    - Cargo.toml
    - crates/memory-toc/Cargo.toml
    - crates/memory-types/src/segment.rs
    - crates/memory-types/src/lib.rs
  </files>
  <action>
Create new memory-toc crate and add Segment type to memory-types.

**Update workspace Cargo.toml to add memory-toc:**
```toml
# Add to [workspace] members
members = [
    "crates/memory-types",
    "crates/memory-storage",
    "crates/memory-service",
    "crates/memory-daemon",
    "crates/memory-toc",
]

# Add to [workspace.dependencies]
tiktoken-rs = "0.5"
async-trait = "0.1"
```

**Create crates/memory-toc/Cargo.toml:**
```toml
[package]
name = "memory-toc"
version.workspace = true
edition.workspace = true
rust-version.workspace = true
license.workspace = true

[dependencies]
memory-types = { path = "../memory-types" }
memory-storage = { path = "../memory-storage" }
tiktoken-rs = { workspace = true }
async-trait = { workspace = true }
chrono = { workspace = true }
ulid = { workspace = true }
serde = { workspace = true }
serde_json = { workspace = true }
tracing = { workspace = true }
thiserror = { workspace = true }
tokio = { workspace = true }

[dev-dependencies]
tempfile = { workspace = true }
tokio = { workspace = true, features = ["rt-multi-thread", "macros"] }
```

**Create crates/memory-types/src/segment.rs:**
```rust
//! Segment type for conversation segmentation.
//!
//! Segments group related events for summarization.
//! Per TOC-03: Created on time threshold (30 min) or token threshold (4K).
//! Per TOC-04: Include overlap for context continuity.

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};

use crate::Event;

/// A segment of conversation events.
///
/// Segments are the leaf nodes of the TOC hierarchy, containing
/// actual events that will be summarized.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Segment {
    /// Unique segment identifier
    pub segment_id: String,

    /// Events in the overlap window (from previous segment for context)
    /// Per TOC-04: Provides context continuity
    #[serde(default)]
    pub overlap_events: Vec<Event>,

    /// Events in this segment (excluding overlap)
    pub events: Vec<Event>,

    /// Start time of the segment (first event, excluding overlap)
    #[serde(with = "chrono::serde::ts_milliseconds")]
    pub start_time: DateTime<Utc>,

    /// End time of the segment (last event)
    #[serde(with = "chrono::serde::ts_milliseconds")]
    pub end_time: DateTime<Utc>,

    /// Token count of events (excluding overlap)
    pub token_count: usize,
}

impl Segment {
    /// Create a new segment
    pub fn new(
        segment_id: String,
        events: Vec<Event>,
        start_time: DateTime<Utc>,
        end_time: DateTime<Utc>,
        token_count: usize,
    ) -> Self {
        Self {
            segment_id,
            overlap_events: Vec::new(),
            events,
            start_time,
            end_time,
            token_count,
        }
    }

    /// Add overlap events from previous segment
    pub fn with_overlap(mut self, overlap_events: Vec<Event>) -> Self {
        self.overlap_events = overlap_events;
        self
    }

    /// Get all events (overlap + main) for summarization
    pub fn all_events(&self) -> Vec<&Event> {
        self.overlap_events.iter().chain(self.events.iter()).collect()
    }

    /// Serialize to JSON bytes
    pub fn to_bytes(&self) -> Result<Vec<u8>, serde_json::Error> {
        serde_json::to_vec(self)
    }

    /// Deserialize from JSON bytes
    pub fn from_bytes(bytes: &[u8]) -> Result<Self, serde_json::Error> {
        serde_json::from_slice(bytes)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::{EventRole, EventType};

    fn create_test_event(text: &str) -> Event {
        Event::new(
            ulid::Ulid::new().to_string(),
            "session-123".to_string(),
            Utc::now(),
            EventType::UserMessage,
            EventRole::User,
            text.to_string(),
        )
    }

    #[test]
    fn test_segment_creation() {
        let events = vec![create_test_event("Hello"), create_test_event("World")];
        let start = events[0].timestamp;
        let end = events[1].timestamp;

        let segment = Segment::new(
            "seg-123".to_string(),
            events.clone(),
            start,
            end,
            100,
        );

        assert_eq!(segment.events.len(), 2);
        assert_eq!(segment.token_count, 100);
    }

    #[test]
    fn test_segment_with_overlap() {
        let overlap = vec![create_test_event("Context")];
        let events = vec![create_test_event("Main")];
        let start = events[0].timestamp;
        let end = events[0].timestamp;

        let segment = Segment::new("seg-123".to_string(), events, start, end, 50)
            .with_overlap(overlap);

        assert_eq!(segment.overlap_events.len(), 1);
        assert_eq!(segment.all_events().len(), 2);
    }

    #[test]
    fn test_segment_serialization() {
        let events = vec![create_test_event("Test")];
        let start = events[0].timestamp;

        let segment = Segment::new("seg-123".to_string(), events, start, start, 25);
        let bytes = segment.to_bytes().unwrap();
        let decoded = Segment::from_bytes(&bytes).unwrap();

        assert_eq!(segment.segment_id, decoded.segment_id);
        assert_eq!(segment.token_count, decoded.token_count);
    }
}
```

**Update crates/memory-types/src/lib.rs to export Segment:**
```rust
//! Domain types for agent-memory.
//!
//! This crate contains the core data structures used throughout
//! the agent-memory system.

mod config;
mod error;
mod event;
mod grip;
mod outbox;
mod segment;
mod toc;

pub use config::{Settings, SummarizerSettings};
pub use error::TypeError;
pub use event::{Event, EventRole, EventType};
pub use grip::Grip;
pub use outbox::{OutboxEntry, OutboxEntryType};
pub use segment::Segment;
pub use toc::{TocBullet, TocLevel, TocNode};
```
  </action>
  <verify>
`cargo build -p memory-types` compiles with Segment type.
`cargo test -p memory-types` passes segment tests.
  </verify>
  <done>
Segment type created with overlap support. memory-toc crate scaffolded.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement SegmentationConfig and token counting</name>
  <files>
    - crates/memory-toc/src/lib.rs
    - crates/memory-toc/src/config.rs
  </files>
  <action>
Create segmentation configuration with threshold settings.

**Create crates/memory-toc/src/lib.rs:**
```rust
//! TOC building library for agent-memory.
//!
//! Provides:
//! - Event segmentation (TOC-03, TOC-04)
//! - Summarization trait (SUMM-01)
//! - TOC hierarchy building (TOC-01, TOC-02, TOC-05)

pub mod config;
pub mod segmenter;

pub use config::{SegmentationConfig, TocConfig};
pub use segmenter::SegmentBuilder;
```

**Create crates/memory-toc/src/config.rs:**
```rust
//! Configuration for TOC building.

use serde::{Deserialize, Serialize};

/// Configuration for event segmentation.
///
/// Per TOC-03: Segment on time threshold (30 min) or token threshold (4K).
/// Per TOC-04: Overlap for context continuity.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SegmentationConfig {
    /// Maximum time gap before starting new segment (milliseconds)
    /// Per TOC-03: Default 30 minutes
    pub time_threshold_ms: i64,

    /// Maximum tokens before starting new segment
    /// Per TOC-03: Default 4000 tokens
    pub token_threshold: usize,

    /// Overlap time to include from previous segment (milliseconds)
    /// Per TOC-04: Default 5 minutes
    pub overlap_time_ms: i64,

    /// Overlap tokens to include from previous segment
    /// Per TOC-04: Default 500 tokens
    pub overlap_tokens: usize,

    /// Maximum text length to count for tool results (to avoid explosion)
    pub max_tool_result_chars: usize,
}

impl Default for SegmentationConfig {
    fn default() -> Self {
        Self {
            time_threshold_ms: 30 * 60 * 1000, // 30 minutes
            token_threshold: 4000,
            overlap_time_ms: 5 * 60 * 1000, // 5 minutes
            overlap_tokens: 500,
            max_tool_result_chars: 1000,
        }
    }
}

/// Overall TOC configuration.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TocConfig {
    /// Segmentation settings
    pub segmentation: SegmentationConfig,

    /// Minimum events to create a segment
    pub min_events_per_segment: usize,
}

impl Default for TocConfig {
    fn default() -> Self {
        Self {
            segmentation: SegmentationConfig::default(),
            min_events_per_segment: 2,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_default_config() {
        let config = SegmentationConfig::default();
        assert_eq!(config.time_threshold_ms, 30 * 60 * 1000);
        assert_eq!(config.token_threshold, 4000);
        assert_eq!(config.overlap_time_ms, 5 * 60 * 1000);
        assert_eq!(config.overlap_tokens, 500);
    }

    #[test]
    fn test_config_serialization() {
        let config = TocConfig::default();
        let json = serde_json::to_string(&config).unwrap();
        let decoded: TocConfig = serde_json::from_str(&json).unwrap();
        assert_eq!(config.segmentation.token_threshold, decoded.segmentation.token_threshold);
    }
}
```
  </action>
  <verify>
`cargo build -p memory-toc` compiles config module.
  </verify>
  <done>
SegmentationConfig created with TOC-03 and TOC-04 thresholds.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement SegmentBuilder with boundary detection</name>
  <files>
    - crates/memory-toc/src/segmenter.rs
  </files>
  <action>
Implement the segmentation engine that detects boundaries.

**Create crates/memory-toc/src/segmenter.rs:**
```rust
//! Event segmentation engine.
//!
//! Per TOC-03: Creates segments on time threshold (30 min) or token threshold (4K).
//! Per TOC-04: Includes overlap for context continuity.

use chrono::{DateTime, Utc};
use tracing::{debug, trace};

use memory_types::{Event, EventType, Segment};

use crate::config::SegmentationConfig;

/// Token counter for events.
pub struct TokenCounter {
    /// Maximum chars for tool results
    max_tool_result_chars: usize,
}

impl TokenCounter {
    pub fn new(max_tool_result_chars: usize) -> Self {
        Self { max_tool_result_chars }
    }

    /// Count tokens in event text.
    ///
    /// Uses tiktoken for accurate OpenAI token counting.
    /// Truncates tool results to avoid token explosion.
    pub fn count_event(&self, event: &Event) -> usize {
        let text = if event.event_type == EventType::ToolResult {
            // Truncate tool results to avoid token explosion
            let len = event.text.len().min(self.max_tool_result_chars);
            &event.text[..len]
        } else {
            &event.text
        };

        // Use tiktoken for accurate counting
        // Fall back to estimate if tiktoken unavailable
        match tiktoken_rs::cl100k_base() {
            Ok(bpe) => bpe.encode_with_special_tokens(text).len(),
            Err(_) => {
                // Rough estimate: ~4 chars per token
                (text.len() / 4).max(1)
            }
        }
    }

    /// Count tokens in multiple events.
    pub fn count_events(&self, events: &[Event]) -> usize {
        events.iter().map(|e| self.count_event(e)).sum()
    }
}

/// Builder for creating segments from a stream of events.
///
/// Detects segment boundaries based on:
/// - Time gaps (TOC-03: 30 min default)
/// - Token thresholds (TOC-03: 4K default)
///
/// Includes overlap from previous segment (TOC-04).
pub struct SegmentBuilder {
    config: SegmentationConfig,
    token_counter: TokenCounter,

    /// Events in current segment being built
    current_events: Vec<Event>,
    /// Token count of current segment
    current_tokens: usize,
    /// Time of last event
    last_event_time: Option<DateTime<Utc>>,

    /// Events to include as overlap in next segment
    overlap_buffer: Vec<Event>,
    /// Tokens in overlap buffer
    overlap_tokens: usize,
}

impl SegmentBuilder {
    /// Create a new segment builder with the given configuration.
    pub fn new(config: SegmentationConfig) -> Self {
        let token_counter = TokenCounter::new(config.max_tool_result_chars);
        Self {
            config,
            token_counter,
            current_events: Vec::new(),
            current_tokens: 0,
            last_event_time: None,
            overlap_buffer: Vec::new(),
            overlap_tokens: 0,
        }
    }

    /// Add an event to the builder.
    ///
    /// Returns Some(Segment) if a boundary was detected and segment completed.
    pub fn add_event(&mut self, event: Event) -> Option<Segment> {
        let event_tokens = self.token_counter.count_event(&event);

        trace!(
            event_id = %event.event_id,
            tokens = event_tokens,
            "Processing event"
        );

        // Check for time gap boundary
        if let Some(last_time) = self.last_event_time {
            let gap_ms = event.timestamp.timestamp_millis() - last_time.timestamp_millis();
            if gap_ms > self.config.time_threshold_ms && !self.current_events.is_empty() {
                debug!(
                    gap_ms = gap_ms,
                    threshold = self.config.time_threshold_ms,
                    "Time gap boundary detected"
                );
                let segment = self.flush_segment();
                self.add_event_internal(event, event_tokens);
                return Some(segment);
            }
        }

        // Check for token threshold boundary
        if self.current_tokens + event_tokens > self.config.token_threshold
            && !self.current_events.is_empty()
        {
            debug!(
                current_tokens = self.current_tokens,
                event_tokens = event_tokens,
                threshold = self.config.token_threshold,
                "Token threshold boundary detected"
            );
            let segment = self.flush_segment();
            self.add_event_internal(event, event_tokens);
            return Some(segment);
        }

        // No boundary, add to current segment
        self.add_event_internal(event, event_tokens);
        None
    }

    /// Internal method to add event to current segment.
    fn add_event_internal(&mut self, event: Event, event_tokens: usize) {
        self.last_event_time = Some(event.timestamp);
        self.current_events.push(event);
        self.current_tokens += event_tokens;
    }

    /// Flush current events as a completed segment.
    fn flush_segment(&mut self) -> Segment {
        let events = std::mem::take(&mut self.current_events);
        let tokens = self.current_tokens;
        self.current_tokens = 0;

        let start_time = events.first().map(|e| e.timestamp).unwrap_or_else(Utc::now);
        let end_time = events.last().map(|e| e.timestamp).unwrap_or_else(Utc::now);

        // Create segment with overlap from previous
        let overlap = std::mem::take(&mut self.overlap_buffer);
        let segment_id = format!("seg:{}", ulid::Ulid::new());

        debug!(
            segment_id = %segment_id,
            events = events.len(),
            overlap = overlap.len(),
            tokens = tokens,
            "Created segment"
        );

        // Build overlap buffer for next segment
        self.build_overlap_buffer(&events);

        Segment::new(segment_id, events, start_time, end_time, tokens).with_overlap(overlap)
    }

    /// Build overlap buffer for next segment from current events.
    fn build_overlap_buffer(&mut self, events: &[Event]) {
        if events.is_empty() {
            return;
        }

        let end_time = events.last().unwrap().timestamp;
        let overlap_start_ms = end_time.timestamp_millis() - self.config.overlap_time_ms;

        let mut overlap_events = Vec::new();
        let mut overlap_tokens = 0;

        // Collect events within overlap time window, up to token limit
        for event in events.iter().rev() {
            if event.timestamp.timestamp_millis() < overlap_start_ms {
                break;
            }

            let tokens = self.token_counter.count_event(event);
            if overlap_tokens + tokens > self.config.overlap_tokens {
                break;
            }

            overlap_events.push(event.clone());
            overlap_tokens += tokens;
        }

        // Reverse to maintain chronological order
        overlap_events.reverse();

        self.overlap_buffer = overlap_events;
        self.overlap_tokens = overlap_tokens;

        trace!(
            overlap_events = self.overlap_buffer.len(),
            overlap_tokens = self.overlap_tokens,
            "Built overlap buffer"
        );
    }

    /// Flush any remaining events as a final segment.
    ///
    /// Call this when processing is complete to get any remaining events.
    pub fn flush(&mut self) -> Option<Segment> {
        if self.current_events.is_empty() {
            return None;
        }
        Some(self.flush_segment())
    }

    /// Check if builder has pending events.
    pub fn has_pending(&self) -> bool {
        !self.current_events.is_empty()
    }

    /// Get current token count.
    pub fn current_token_count(&self) -> usize {
        self.current_tokens
    }

    /// Get current event count.
    pub fn current_event_count(&self) -> usize {
        self.current_events.len()
    }
}

/// Process a batch of events into segments.
pub fn segment_events(events: Vec<Event>, config: SegmentationConfig) -> Vec<Segment> {
    let mut builder = SegmentBuilder::new(config);
    let mut segments = Vec::new();

    for event in events {
        if let Some(segment) = builder.add_event(event) {
            segments.push(segment);
        }
    }

    // Flush any remaining events
    if let Some(segment) = builder.flush() {
        segments.push(segment);
    }

    segments
}

#[cfg(test)]
mod tests {
    use super::*;
    use memory_types::{EventRole, EventType};

    fn create_event_at(text: &str, timestamp_ms: i64) -> Event {
        let ulid = ulid::Ulid::from_parts(timestamp_ms as u64, rand::random());
        Event::new(
            ulid.to_string(),
            "session-123".to_string(),
            chrono::Utc.timestamp_millis_opt(timestamp_ms).unwrap(),
            EventType::UserMessage,
            EventRole::User,
            text.to_string(),
        )
    }

    use chrono::TimeZone;

    #[test]
    fn test_token_counter_basic() {
        let counter = TokenCounter::new(1000);
        let event = create_event_at("Hello, world!", 1000);
        let tokens = counter.count_event(&event);
        assert!(tokens > 0);
        assert!(tokens < 10); // "Hello, world!" should be ~4 tokens
    }

    #[test]
    fn test_token_counter_truncates_tool_results() {
        let counter = TokenCounter::new(100);
        let mut event = create_event_at(&"x".repeat(1000), 1000);
        event.event_type = EventType::ToolResult;

        let tokens = counter.count_event(&event);
        // Should be based on truncated text (100 chars), not full 1000
        assert!(tokens < 50);
    }

    #[test]
    fn test_segment_builder_time_boundary() {
        let config = SegmentationConfig {
            time_threshold_ms: 1000, // 1 second for testing
            token_threshold: 10000,
            overlap_time_ms: 500,
            overlap_tokens: 100,
            max_tool_result_chars: 1000,
        };

        let mut builder = SegmentBuilder::new(config);

        // Events within 1 second - no boundary
        assert!(builder.add_event(create_event_at("First", 1000)).is_none());
        assert!(builder.add_event(create_event_at("Second", 1500)).is_none());

        // Event after 2 second gap - boundary
        let segment = builder.add_event(create_event_at("After gap", 4000));
        assert!(segment.is_some());

        let seg = segment.unwrap();
        assert_eq!(seg.events.len(), 2);
    }

    #[test]
    fn test_segment_builder_token_boundary() {
        let config = SegmentationConfig {
            time_threshold_ms: 1000000, // Very high to not trigger
            token_threshold: 10, // Very low to trigger
            overlap_time_ms: 500,
            overlap_tokens: 5,
            max_tool_result_chars: 1000,
        };

        let mut builder = SegmentBuilder::new(config);

        // First event
        assert!(builder.add_event(create_event_at("Short", 1000)).is_none());

        // Long event should trigger boundary
        let segment = builder.add_event(create_event_at(
            "This is a much longer message that should exceed the token threshold",
            2000,
        ));
        assert!(segment.is_some());
    }

    #[test]
    fn test_segment_builder_overlap() {
        let config = SegmentationConfig {
            time_threshold_ms: 1000,
            token_threshold: 10000,
            overlap_time_ms: 500,
            overlap_tokens: 1000,
            max_tool_result_chars: 1000,
        };

        let mut builder = SegmentBuilder::new(config);

        // Add events
        builder.add_event(create_event_at("Early", 1000));
        builder.add_event(create_event_at("Middle", 1200));
        builder.add_event(create_event_at("Late", 1400));

        // Trigger boundary
        let segment1 = builder.add_event(create_event_at("After gap", 5000)).unwrap();
        assert_eq!(segment1.events.len(), 3);

        // Add more events and flush
        builder.add_event(create_event_at("New event", 5500));
        let segment2 = builder.flush().unwrap();

        // Second segment should have overlap from first
        assert!(!segment2.overlap_events.is_empty());
    }

    #[test]
    fn test_segment_events_batch() {
        let config = SegmentationConfig {
            time_threshold_ms: 1000,
            token_threshold: 10000,
            overlap_time_ms: 100,
            overlap_tokens: 50,
            max_tool_result_chars: 1000,
        };

        let events = vec![
            create_event_at("Event 1", 1000),
            create_event_at("Event 2", 1500),
            create_event_at("Event 3", 5000), // Gap
            create_event_at("Event 4", 5500),
        ];

        let segments = segment_events(events, config);
        assert_eq!(segments.len(), 2);
    }

    #[test]
    fn test_flush_empty_builder() {
        let mut builder = SegmentBuilder::new(SegmentationConfig::default());
        assert!(builder.flush().is_none());
    }
}
```
  </action>
  <verify>
`cargo build -p memory-toc` compiles successfully.
`cargo test -p memory-toc` passes all segmentation tests.
  </verify>
  <done>
SegmentBuilder implements TOC-03 (time/token boundaries) and TOC-04 (overlap).
  </done>
</task>

</tasks>

<verification>
1. `cargo build -p memory-toc` compiles without errors
2. `cargo test -p memory-toc` passes all tests
3. `cargo test -p memory-types` passes segment tests
4. Segment struct exists with overlap_events, events, start/end times, token_count
5. SegmentationConfig has time_threshold (30min default), token_threshold (4K default)
6. SegmentBuilder detects time gap boundaries
7. SegmentBuilder detects token threshold boundaries
8. Overlap events carried to next segment
</verification>

<success_criteria>
- Segment type exists with overlap support (TOC-04)
- SegmentationConfig has correct defaults (TOC-03: 30min, 4K tokens)
- SegmentBuilder detects both time and token boundaries
- Token counting handles tool result truncation
- Overlap buffer correctly populated for context continuity
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-toc-building/02-01-SUMMARY.md`
</output>
