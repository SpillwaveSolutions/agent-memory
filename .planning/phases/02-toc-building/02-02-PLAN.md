---
phase: 02-toc-building
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/memory-toc/src/summarizer.rs
  - crates/memory-toc/src/summarizer/mod.rs
  - crates/memory-toc/src/summarizer/api.rs
  - crates/memory-toc/src/summarizer/mock.rs
  - crates/memory-toc/src/lib.rs
  - crates/memory-toc/Cargo.toml
autonomous: true

must_haves:
  truths:
    - "Summarizer trait exists with summarize_events and summarize_children methods"
    - "Summary struct has title, bullets, keywords fields"
    - "ApiSummarizer implements Summarizer using HTTP API calls"
    - "MockSummarizer exists for testing"
    - "Error handling for API failures with retry capability"
  artifacts:
    - path: "crates/memory-toc/src/summarizer/mod.rs"
      provides: "Summarizer trait and Summary type"
      exports: ["Summarizer", "Summary", "SummarizerError"]
    - path: "crates/memory-toc/src/summarizer/api.rs"
      provides: "API-based summarizer implementation"
      exports: ["ApiSummarizer", "ApiSummarizerConfig"]
    - path: "crates/memory-toc/src/summarizer/mock.rs"
      provides: "Mock summarizer for testing"
      exports: ["MockSummarizer"]
  key_links:
    - from: "crates/memory-toc/src/summarizer/api.rs"
      to: "reqwest"
      via: "HTTP client"
      pattern: "reqwest::Client"
---

<objective>
Implement the pluggable Summarizer trait for generating TOC summaries from events.

Purpose: Enable TOC nodes to have meaningful summaries (title, bullets, keywords) generated from conversation events.
Output: Summarizer trait with API implementation (OpenAI/Claude compatible) and mock for testing.
</objective>

<execution_context>
@/Users/richardhightower/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardhightower/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-toc-building/02-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add summarizer dependencies to memory-toc</name>
  <files>
    - crates/memory-toc/Cargo.toml
    - Cargo.toml
  </files>
  <action>
Add HTTP client and retry dependencies for API summarizer.

**Update workspace Cargo.toml [workspace.dependencies]:**
```toml
# Add these to [workspace.dependencies] if not present
reqwest = { version = "0.12", features = ["json"] }
backoff = { version = "0.4", features = ["tokio"] }
secrecy = { version = "0.10", features = ["serde"] }
```

**Update crates/memory-toc/Cargo.toml:**
```toml
[package]
name = "memory-toc"
version.workspace = true
edition.workspace = true
rust-version.workspace = true
license.workspace = true

[dependencies]
memory-types = { path = "../memory-types" }
memory-storage = { path = "../memory-storage" }
tiktoken-rs = { workspace = true }
async-trait = { workspace = true }
chrono = { workspace = true }
ulid = { workspace = true }
serde = { workspace = true }
serde_json = { workspace = true }
tracing = { workspace = true }
thiserror = { workspace = true }
tokio = { workspace = true }
reqwest = { workspace = true }
backoff = { workspace = true }
secrecy = { workspace = true }

[dev-dependencies]
tempfile = { workspace = true }
tokio = { workspace = true, features = ["rt-multi-thread", "macros"] }
wiremock = "0.6"
```
  </action>
  <verify>
`cargo build -p memory-toc` compiles with new dependencies.
  </verify>
  <done>
Dependencies added for API-based summarization.
  </done>
</task>

<task type="auto">
  <name>Task 2: Define Summarizer trait and Summary type</name>
  <files>
    - crates/memory-toc/src/summarizer/mod.rs
    - crates/memory-toc/src/lib.rs
  </files>
  <action>
Create the Summarizer trait and supporting types.

**Create crates/memory-toc/src/summarizer/mod.rs:**
```rust
//! Summarization trait and implementations.
//!
//! Per SUMM-01: Pluggable Summarizer trait (async, supports API and local LLM).
//! Per SUMM-02: Generates title, bullets, keywords from events.
//! Per SUMM-04: Rollup summarizer aggregates child node summaries.

mod api;
mod mock;

pub use api::{ApiSummarizer, ApiSummarizerConfig};
pub use mock::MockSummarizer;

use async_trait::async_trait;
use serde::{Deserialize, Serialize};
use thiserror::Error;

use memory_types::Event;

/// Error type for summarization operations.
#[derive(Debug, Error)]
pub enum SummarizerError {
    #[error("API request failed: {0}")]
    ApiError(String),

    #[error("Failed to parse API response: {0}")]
    ParseError(String),

    #[error("Rate limit exceeded")]
    RateLimitExceeded,

    #[error("Invalid configuration: {0}")]
    ConfigError(String),

    #[error("Timeout waiting for response")]
    Timeout,

    #[error("No events to summarize")]
    NoEvents,
}

/// Output from summarization.
///
/// Per SUMM-02: Contains title, bullets, and keywords.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Summary {
    /// Brief title capturing the main topic (5-10 words)
    pub title: String,

    /// Key points from the conversation (3-5 bullets)
    pub bullets: Vec<String>,

    /// Keywords for search and filtering (3-7 keywords)
    pub keywords: Vec<String>,
}

impl Summary {
    /// Create a new summary.
    pub fn new(title: String, bullets: Vec<String>, keywords: Vec<String>) -> Self {
        Self {
            title,
            bullets,
            keywords,
        }
    }

    /// Create an empty/placeholder summary.
    pub fn empty() -> Self {
        Self {
            title: String::new(),
            bullets: Vec::new(),
            keywords: Vec::new(),
        }
    }
}

/// Pluggable summarizer trait.
///
/// Per SUMM-01: Async trait supporting API and local LLM.
#[async_trait]
pub trait Summarizer: Send + Sync {
    /// Generate a summary from conversation events.
    ///
    /// Per SUMM-02: Generates title, bullets, keywords.
    async fn summarize_events(&self, events: &[Event]) -> Result<Summary, SummarizerError>;

    /// Generate a rollup summary from child summaries.
    ///
    /// Per SUMM-04: Aggregates child node summaries for parent TOC nodes.
    async fn summarize_children(&self, summaries: &[Summary]) -> Result<Summary, SummarizerError>;
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_summary_creation() {
        let summary = Summary::new(
            "Discussed authentication".to_string(),
            vec!["Implemented JWT".to_string(), "Fixed token refresh".to_string()],
            vec!["auth".to_string(), "jwt".to_string()],
        );

        assert_eq!(summary.title, "Discussed authentication");
        assert_eq!(summary.bullets.len(), 2);
        assert_eq!(summary.keywords.len(), 2);
    }

    #[test]
    fn test_summary_empty() {
        let summary = Summary::empty();
        assert!(summary.title.is_empty());
        assert!(summary.bullets.is_empty());
        assert!(summary.keywords.is_empty());
    }

    #[test]
    fn test_summary_serialization() {
        let summary = Summary::new(
            "Test".to_string(),
            vec!["Bullet 1".to_string()],
            vec!["keyword".to_string()],
        );

        let json = serde_json::to_string(&summary).unwrap();
        let decoded: Summary = serde_json::from_str(&json).unwrap();

        assert_eq!(summary.title, decoded.title);
    }
}
```

**Update crates/memory-toc/src/lib.rs:**
```rust
//! TOC building library for agent-memory.
//!
//! Provides:
//! - Event segmentation (TOC-03, TOC-04)
//! - Summarization trait (SUMM-01, SUMM-02, SUMM-04)
//! - TOC hierarchy building (TOC-01, TOC-02, TOC-05)

pub mod config;
pub mod segmenter;
pub mod summarizer;

pub use config::{SegmentationConfig, TocConfig};
pub use segmenter::SegmentBuilder;
pub use summarizer::{ApiSummarizer, ApiSummarizerConfig, MockSummarizer, Summary, Summarizer, SummarizerError};
```
  </action>
  <verify>
`cargo build -p memory-toc` compiles with summarizer module.
  </verify>
  <done>
Summarizer trait defined with Summary output type.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement MockSummarizer for testing</name>
  <files>
    - crates/memory-toc/src/summarizer/mock.rs
  </files>
  <action>
Create a mock summarizer for testing without API calls.

**Create crates/memory-toc/src/summarizer/mock.rs:**
```rust
//! Mock summarizer for testing.

use async_trait::async_trait;

use memory_types::Event;

use super::{Summary, Summarizer, SummarizerError};

/// Mock summarizer that generates deterministic summaries.
///
/// Useful for testing without making API calls.
pub struct MockSummarizer {
    /// Prefix for generated titles
    title_prefix: String,
}

impl MockSummarizer {
    /// Create a new mock summarizer.
    pub fn new() -> Self {
        Self {
            title_prefix: "Summary of".to_string(),
        }
    }

    /// Create with custom title prefix.
    pub fn with_title_prefix(prefix: impl Into<String>) -> Self {
        Self {
            title_prefix: prefix.into(),
        }
    }
}

impl Default for MockSummarizer {
    fn default() -> Self {
        Self::new()
    }
}

#[async_trait]
impl Summarizer for MockSummarizer {
    async fn summarize_events(&self, events: &[Event]) -> Result<Summary, SummarizerError> {
        if events.is_empty() {
            return Err(SummarizerError::NoEvents);
        }

        // Extract some info from events for mock summary
        let first_event = &events[0];
        let last_event = &events[events.len() - 1];

        let title = format!(
            "{} {} events",
            self.title_prefix,
            events.len()
        );

        let bullets = vec![
            format!("First message: {}", truncate(&first_event.text, 50)),
            format!("Last message: {}", truncate(&last_event.text, 50)),
            format!("Total events: {}", events.len()),
        ];

        // Extract keywords from event text
        let keywords = extract_mock_keywords(events);

        Ok(Summary::new(title, bullets, keywords))
    }

    async fn summarize_children(&self, summaries: &[Summary]) -> Result<Summary, SummarizerError> {
        if summaries.is_empty() {
            return Err(SummarizerError::NoEvents);
        }

        let title = format!(
            "{} {} child summaries",
            self.title_prefix,
            summaries.len()
        );

        // Collect bullets from children (first bullet from each)
        let bullets: Vec<String> = summaries
            .iter()
            .filter_map(|s| s.bullets.first().cloned())
            .take(5)
            .collect();

        // Merge keywords from all children
        let mut all_keywords: Vec<String> = summaries
            .iter()
            .flat_map(|s| s.keywords.clone())
            .collect();
        all_keywords.sort();
        all_keywords.dedup();
        let keywords = all_keywords.into_iter().take(7).collect();

        Ok(Summary::new(title, bullets, keywords))
    }
}

/// Truncate text to max length, adding "..." if truncated.
fn truncate(text: &str, max_len: usize) -> String {
    if text.len() <= max_len {
        text.to_string()
    } else {
        format!("{}...", &text[..max_len.saturating_sub(3)])
    }
}

/// Extract mock keywords from events (simple word extraction).
fn extract_mock_keywords(events: &[Event]) -> Vec<String> {
    let all_text: String = events.iter().map(|e| e.text.as_str()).collect::<Vec<_>>().join(" ");

    // Simple keyword extraction: split by whitespace, filter short words
    let words: Vec<String> = all_text
        .split_whitespace()
        .filter(|w| w.len() > 3)
        .map(|w| w.to_lowercase())
        .filter(|w| !is_stopword(w))
        .collect();

    // Count and sort by frequency
    let mut word_counts: std::collections::HashMap<String, usize> = std::collections::HashMap::new();
    for word in words {
        *word_counts.entry(word).or_insert(0) += 1;
    }

    let mut sorted: Vec<_> = word_counts.into_iter().collect();
    sorted.sort_by(|a, b| b.1.cmp(&a.1));

    sorted.into_iter().take(5).map(|(w, _)| w).collect()
}

/// Check if word is a common stopword.
fn is_stopword(word: &str) -> bool {
    const STOPWORDS: &[&str] = &[
        "the", "and", "for", "that", "this", "with", "from", "have", "has",
        "been", "were", "will", "would", "could", "should", "there", "their",
        "what", "when", "where", "which", "about", "into", "through",
    ];
    STOPWORDS.contains(&word)
}

#[cfg(test)]
mod tests {
    use super::*;
    use chrono::Utc;
    use memory_types::{EventRole, EventType};

    fn create_test_event(text: &str) -> Event {
        Event::new(
            ulid::Ulid::new().to_string(),
            "session-123".to_string(),
            Utc::now(),
            EventType::UserMessage,
            EventRole::User,
            text.to_string(),
        )
    }

    #[tokio::test]
    async fn test_mock_summarize_events() {
        let summarizer = MockSummarizer::new();
        let events = vec![
            create_test_event("How do I implement authentication?"),
            create_test_event("Use JWT tokens for stateless auth"),
        ];

        let summary = summarizer.summarize_events(&events).await.unwrap();

        assert!(summary.title.contains("2 events"));
        assert_eq!(summary.bullets.len(), 3);
        assert!(!summary.keywords.is_empty());
    }

    #[tokio::test]
    async fn test_mock_summarize_empty() {
        let summarizer = MockSummarizer::new();
        let result = summarizer.summarize_events(&[]).await;
        assert!(matches!(result, Err(SummarizerError::NoEvents)));
    }

    #[tokio::test]
    async fn test_mock_summarize_children() {
        let summarizer = MockSummarizer::new();
        let summaries = vec![
            Summary::new(
                "Day 1".to_string(),
                vec!["Worked on auth".to_string()],
                vec!["auth".to_string()],
            ),
            Summary::new(
                "Day 2".to_string(),
                vec!["Fixed bugs".to_string()],
                vec!["bugs".to_string()],
            ),
        ];

        let rollup = summarizer.summarize_children(&summaries).await.unwrap();

        assert!(rollup.title.contains("2 child summaries"));
        assert!(rollup.keywords.contains(&"auth".to_string()));
    }

    #[tokio::test]
    async fn test_mock_custom_prefix() {
        let summarizer = MockSummarizer::with_title_prefix("Overview of");
        let events = vec![create_test_event("Test event")];

        let summary = summarizer.summarize_events(&events).await.unwrap();

        assert!(summary.title.starts_with("Overview of"));
    }
}
```
  </action>
  <verify>
`cargo test -p memory-toc -- --test mock` passes mock summarizer tests.
  </verify>
  <done>
MockSummarizer implemented for testing.
  </done>
</task>

<task type="auto">
  <name>Task 4: Implement ApiSummarizer for OpenAI/Claude API</name>
  <files>
    - crates/memory-toc/src/summarizer/api.rs
  </files>
  <action>
Create API-based summarizer that calls OpenAI-compatible endpoints.

**Create crates/memory-toc/src/summarizer/api.rs:**
```rust
//! API-based summarizer using OpenAI-compatible endpoints.

use async_trait::async_trait;
use backoff::{backoff::Backoff, ExponentialBackoff};
use reqwest::Client;
use secrecy::{ExposeSecret, SecretString};
use serde::{Deserialize, Serialize};
use std::time::Duration;
use tracing::{debug, error, warn};

use memory_types::Event;

use super::{Summary, Summarizer, SummarizerError};

/// Configuration for API-based summarizer.
#[derive(Debug, Clone)]
pub struct ApiSummarizerConfig {
    /// API base URL (e.g., "https://api.openai.com/v1")
    pub base_url: String,

    /// Model to use (e.g., "gpt-4o-mini", "claude-3-haiku-20240307")
    pub model: String,

    /// API key
    pub api_key: SecretString,

    /// Request timeout
    pub timeout: Duration,

    /// Maximum retries on failure
    pub max_retries: u32,
}

impl ApiSummarizerConfig {
    /// Create config for OpenAI API.
    pub fn openai(api_key: impl Into<String>, model: impl Into<String>) -> Self {
        Self {
            base_url: "https://api.openai.com/v1".to_string(),
            model: model.into(),
            api_key: SecretString::from(api_key.into()),
            timeout: Duration::from_secs(60),
            max_retries: 3,
        }
    }

    /// Create config for Claude API.
    pub fn claude(api_key: impl Into<String>, model: impl Into<String>) -> Self {
        Self {
            base_url: "https://api.anthropic.com/v1".to_string(),
            model: model.into(),
            api_key: SecretString::from(api_key.into()),
            timeout: Duration::from_secs(60),
            max_retries: 3,
        }
    }
}

/// API-based summarizer implementation.
pub struct ApiSummarizer {
    client: Client,
    config: ApiSummarizerConfig,
}

impl ApiSummarizer {
    /// Create a new API summarizer.
    pub fn new(config: ApiSummarizerConfig) -> Result<Self, SummarizerError> {
        let client = Client::builder()
            .timeout(config.timeout)
            .build()
            .map_err(|e| SummarizerError::ConfigError(e.to_string()))?;

        Ok(Self { client, config })
    }

    /// Build prompt for event summarization.
    fn build_events_prompt(&self, events: &[Event]) -> String {
        let events_text: String = events
            .iter()
            .map(|e| {
                let timestamp = e.timestamp.format("%Y-%m-%d %H:%M:%S");
                format!("[{}] {}: {}", timestamp, e.role, e.text)
            })
            .collect::<Vec<_>>()
            .join("\n\n");

        format!(
            r#"Summarize this conversation segment for a Table of Contents entry.

CONVERSATION:
{events_text}

Provide your response in JSON format:
{{
  "title": "Brief title (5-10 words)",
  "bullets": ["Key point 1", "Key point 2", "Key point 3"],
  "keywords": ["keyword1", "keyword2", "keyword3"]
}}

Guidelines:
- Title should capture the main topic or activity
- 3-5 bullet points summarizing key discussions or decisions
- 3-7 keywords for search/filtering
- Focus on what would help someone find this conversation later"#
        )
    }

    /// Build prompt for rollup summarization.
    fn build_rollup_prompt(&self, summaries: &[Summary]) -> String {
        let summaries_text: String = summaries
            .iter()
            .enumerate()
            .map(|(i, s)| {
                let bullets = s.bullets.join("\n  - ");
                format!(
                    "### Summary {}\nTitle: {}\nBullets:\n  - {}\nKeywords: {}",
                    i + 1,
                    s.title,
                    bullets,
                    s.keywords.join(", ")
                )
            })
            .collect::<Vec<_>>()
            .join("\n\n");

        format!(
            r#"Create a higher-level summary by aggregating these child summaries.

CHILD SUMMARIES:
{summaries_text}

Provide your response in JSON format:
{{
  "title": "Brief title (5-10 words)",
  "bullets": ["Key point 1", "Key point 2", "Key point 3"],
  "keywords": ["keyword1", "keyword2", "keyword3"]
}}

Guidelines:
- Title should capture the overall theme
- 3-5 bullet points covering the most important topics across all children
- 3-7 keywords representing major themes
- Focus on themes and patterns, not individual details"#
        )
    }

    /// Call the API with retry logic.
    async fn call_api(&self, prompt: &str) -> Result<String, SummarizerError> {
        let mut backoff = ExponentialBackoff {
            max_elapsed_time: Some(Duration::from_secs(120)),
            ..Default::default()
        };

        let mut attempts = 0;

        loop {
            attempts += 1;
            debug!(attempt = attempts, "Calling summarization API");

            match self.make_request(prompt).await {
                Ok(response) => return Ok(response),
                Err(e) => {
                    if attempts >= self.config.max_retries {
                        error!(error = %e, "Max retries exceeded");
                        return Err(e);
                    }

                    match backoff.next_backoff() {
                        Some(duration) => {
                            warn!(
                                error = %e,
                                retry_in_ms = duration.as_millis(),
                                "API call failed, retrying"
                            );
                            tokio::time::sleep(duration).await;
                        }
                        None => {
                            error!(error = %e, "Backoff exhausted");
                            return Err(e);
                        }
                    }
                }
            }
        }
    }

    /// Make a single API request.
    async fn make_request(&self, prompt: &str) -> Result<String, SummarizerError> {
        // Build request based on API type
        let is_anthropic = self.config.base_url.contains("anthropic");

        let response = if is_anthropic {
            self.make_anthropic_request(prompt).await?
        } else {
            self.make_openai_request(prompt).await?
        };

        Ok(response)
    }

    /// Make OpenAI-compatible API request.
    async fn make_openai_request(&self, prompt: &str) -> Result<String, SummarizerError> {
        #[derive(Serialize)]
        struct OpenAIRequest {
            model: String,
            messages: Vec<OpenAIMessage>,
            response_format: OpenAIResponseFormat,
        }

        #[derive(Serialize)]
        struct OpenAIMessage {
            role: String,
            content: String,
        }

        #[derive(Serialize)]
        struct OpenAIResponseFormat {
            #[serde(rename = "type")]
            format_type: String,
        }

        #[derive(Deserialize)]
        struct OpenAIResponse {
            choices: Vec<OpenAIChoice>,
        }

        #[derive(Deserialize)]
        struct OpenAIChoice {
            message: OpenAIMessageResponse,
        }

        #[derive(Deserialize)]
        struct OpenAIMessageResponse {
            content: String,
        }

        let request = OpenAIRequest {
            model: self.config.model.clone(),
            messages: vec![OpenAIMessage {
                role: "user".to_string(),
                content: prompt.to_string(),
            }],
            response_format: OpenAIResponseFormat {
                format_type: "json_object".to_string(),
            },
        };

        let url = format!("{}/chat/completions", self.config.base_url);

        let response = self
            .client
            .post(&url)
            .header("Authorization", format!("Bearer {}", self.config.api_key.expose_secret()))
            .header("Content-Type", "application/json")
            .json(&request)
            .send()
            .await
            .map_err(|e| SummarizerError::ApiError(e.to_string()))?;

        if response.status() == 429 {
            return Err(SummarizerError::RateLimitExceeded);
        }

        if !response.status().is_success() {
            let status = response.status();
            let body = response.text().await.unwrap_or_default();
            return Err(SummarizerError::ApiError(format!(
                "HTTP {}: {}",
                status, body
            )));
        }

        let response_body: OpenAIResponse = response
            .json()
            .await
            .map_err(|e| SummarizerError::ParseError(e.to_string()))?;

        response_body
            .choices
            .first()
            .map(|c| c.message.content.clone())
            .ok_or_else(|| SummarizerError::ParseError("No choices in response".to_string()))
    }

    /// Make Anthropic API request.
    async fn make_anthropic_request(&self, prompt: &str) -> Result<String, SummarizerError> {
        #[derive(Serialize)]
        struct AnthropicRequest {
            model: String,
            max_tokens: u32,
            messages: Vec<AnthropicMessage>,
        }

        #[derive(Serialize)]
        struct AnthropicMessage {
            role: String,
            content: String,
        }

        #[derive(Deserialize)]
        struct AnthropicResponse {
            content: Vec<AnthropicContent>,
        }

        #[derive(Deserialize)]
        struct AnthropicContent {
            text: String,
        }

        let request = AnthropicRequest {
            model: self.config.model.clone(),
            max_tokens: 1024,
            messages: vec![AnthropicMessage {
                role: "user".to_string(),
                content: prompt.to_string(),
            }],
        };

        let url = format!("{}/messages", self.config.base_url);

        let response = self
            .client
            .post(&url)
            .header("x-api-key", self.config.api_key.expose_secret())
            .header("anthropic-version", "2023-06-01")
            .header("Content-Type", "application/json")
            .json(&request)
            .send()
            .await
            .map_err(|e| SummarizerError::ApiError(e.to_string()))?;

        if response.status() == 429 {
            return Err(SummarizerError::RateLimitExceeded);
        }

        if !response.status().is_success() {
            let status = response.status();
            let body = response.text().await.unwrap_or_default();
            return Err(SummarizerError::ApiError(format!(
                "HTTP {}: {}",
                status, body
            )));
        }

        let response_body: AnthropicResponse = response
            .json()
            .await
            .map_err(|e| SummarizerError::ParseError(e.to_string()))?;

        response_body
            .content
            .first()
            .map(|c| c.text.clone())
            .ok_or_else(|| SummarizerError::ParseError("No content in response".to_string()))
    }

    /// Parse JSON response into Summary.
    fn parse_summary(&self, response: &str) -> Result<Summary, SummarizerError> {
        // Try to extract JSON from response (in case there's extra text)
        let json_str = extract_json(response);

        serde_json::from_str(&json_str).map_err(|e| {
            SummarizerError::ParseError(format!("Failed to parse summary JSON: {}", e))
        })
    }
}

/// Extract JSON object from text (handles markdown code blocks).
fn extract_json(text: &str) -> String {
    // Check for markdown code block
    if let Some(start) = text.find("```json") {
        if let Some(end) = text[start + 7..].find("```") {
            return text[start + 7..start + 7 + end].trim().to_string();
        }
    }

    // Check for plain code block
    if let Some(start) = text.find("```") {
        if let Some(end) = text[start + 3..].find("```") {
            return text[start + 3..start + 3 + end].trim().to_string();
        }
    }

    // Find first { and last }
    if let (Some(start), Some(end)) = (text.find('{'), text.rfind('}')) {
        return text[start..=end].to_string();
    }

    text.to_string()
}

#[async_trait]
impl Summarizer for ApiSummarizer {
    async fn summarize_events(&self, events: &[Event]) -> Result<Summary, SummarizerError> {
        if events.is_empty() {
            return Err(SummarizerError::NoEvents);
        }

        let prompt = self.build_events_prompt(events);
        let response = self.call_api(&prompt).await?;
        self.parse_summary(&response)
    }

    async fn summarize_children(&self, summaries: &[Summary]) -> Result<Summary, SummarizerError> {
        if summaries.is_empty() {
            return Err(SummarizerError::NoEvents);
        }

        let prompt = self.build_rollup_prompt(summaries);
        let response = self.call_api(&prompt).await?;
        self.parse_summary(&response)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_extract_json_plain() {
        let text = r#"{"title": "Test", "bullets": [], "keywords": []}"#;
        let json = extract_json(text);
        assert_eq!(json, text);
    }

    #[test]
    fn test_extract_json_code_block() {
        let text = r#"Here's the summary:
```json
{"title": "Test", "bullets": [], "keywords": []}
```"#;
        let json = extract_json(text);
        assert!(json.contains("Test"));
    }

    #[test]
    fn test_extract_json_with_prefix() {
        let text = r#"Sure! Here's your summary: {"title": "Test", "bullets": [], "keywords": []}"#;
        let json = extract_json(text);
        assert!(json.starts_with('{'));
        assert!(json.ends_with('}'));
    }

    #[test]
    fn test_openai_config() {
        let config = ApiSummarizerConfig::openai("test-key", "gpt-4o-mini");
        assert!(config.base_url.contains("openai"));
        assert_eq!(config.model, "gpt-4o-mini");
    }

    #[test]
    fn test_claude_config() {
        let config = ApiSummarizerConfig::claude("test-key", "claude-3-haiku-20240307");
        assert!(config.base_url.contains("anthropic"));
        assert_eq!(config.model, "claude-3-haiku-20240307");
    }
}
```
  </action>
  <verify>
`cargo build -p memory-toc` compiles API summarizer.
`cargo test -p memory-toc -- --test api` passes API summarizer tests.
  </verify>
  <done>
ApiSummarizer implemented with OpenAI/Claude support and retry logic.
  </done>
</task>

</tasks>

<verification>
1. `cargo build -p memory-toc` compiles without errors
2. `cargo test -p memory-toc` passes all summarizer tests
3. Summarizer trait has summarize_events and summarize_children methods
4. Summary struct has title, bullets, keywords
5. ApiSummarizer supports OpenAI and Claude APIs
6. MockSummarizer works for testing
7. Retry logic handles rate limits
</verification>

<success_criteria>
- Summarizer trait exists (SUMM-01)
- Summary has title, bullets, keywords (SUMM-02)
- summarize_children for rollup (SUMM-04)
- API implementation with retry
- Mock implementation for testing
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-toc-building/02-02-SUMMARY.md`
</output>
