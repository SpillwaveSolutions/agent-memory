---
phase: 13-outbox-index-ingestion
plan: 04
type: execute
wave: 3
depends_on: ["13-02"]
files_modified:
  - crates/memory-indexing/src/lib.rs
  - crates/memory-indexing/src/job.rs
  - crates/memory-scheduler/src/jobs/mod.rs
  - crates/memory-scheduler/src/jobs/indexing.rs
  - crates/memory-daemon/src/lib.rs
  - proto/memory.proto
  - crates/memory-service/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "Indexing job runs on configurable cron schedule"
    - "Indexing job processes outbox entries without blocking ingestion"
    - "GetIndexingStatus RPC returns pipeline health and checkpoint info"
    - "Job integrates with existing scheduler infrastructure"
  artifacts:
    - path: "crates/memory-scheduler/src/jobs/indexing.rs"
      provides: "Indexing job creation and scheduling"
      contains: "create_indexing_job"
      min_lines: 50
    - path: "proto/memory.proto"
      provides: "GetIndexingStatus RPC definition"
      contains: "GetIndexingStatus"
  key_links:
    - from: "crates/memory-scheduler/src/jobs/indexing.rs"
      to: "crates/memory-indexing/src/pipeline.rs"
      via: "IndexingPipeline.process_batch()"
      pattern: "pipeline\\.process_batch"
    - from: "crates/memory-daemon/src/lib.rs"
      to: "crates/memory-scheduler/src/jobs/indexing.rs"
      via: "create_indexing_job"
      pattern: "create_indexing_job"
---

<objective>
Integrate indexing pipeline with scheduler and add observability RPC.

Purpose: Enable background async indexing that doesn't block event ingestion, with status visibility for monitoring.
Output: Scheduled indexing job and GetIndexingStatus gRPC endpoint.
</objective>

<execution_context>
@/Users/richardhightower/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardhightower/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-outbox-index-ingestion/13-RESEARCH.md
@.planning/phases/13-outbox-index-ingestion/13-02-SUMMARY.md
@crates/memory-scheduler/src/jobs/rollup.rs
@crates/memory-scheduler/src/lib.rs
@crates/memory-daemon/src/lib.rs
@proto/memory.proto
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create IndexingJobConfig and job module</name>
  <files>crates/memory-scheduler/src/jobs/mod.rs, crates/memory-scheduler/src/jobs/indexing.rs, crates/memory-scheduler/Cargo.toml</files>
  <action>
    1. Add memory-indexing dependency to memory-scheduler Cargo.toml:
       ```toml
       memory-indexing = { workspace = true }
       ```

    2. Create indexing.rs following the rollup.rs pattern:
       - IndexingJobConfig struct:
         - cron: String (default: "*/30 * * * * *" = every 30 seconds)
         - timezone: String (default: "UTC")
         - jitter_secs: u64 (default: 5)
         - batch_size: usize (default: 100)
       - Implement Default trait

       - create_indexing_job() async function:
         ```rust
         pub async fn create_indexing_job(
             scheduler: &SchedulerService,
             pipeline: Arc<IndexingPipeline>,
             config: IndexingJobConfig,
         ) -> Result<(), SchedulerError>
         ```
         Logic:
         - Register job named "index_outbox_consumer"
         - Use OverlapPolicy::Skip (only one consumer at a time)
         - Job closure:
           a. Call pipeline.process_batch().await
           b. On success with stats.total() > 0, log info
           c. On error, log warning, return Err(e.to_string())

    3. Update jobs/mod.rs to add:
       ```rust
       pub mod indexing;
       pub use indexing::{IndexingJobConfig, create_indexing_job};
       ```
  </action>
  <verify>cargo check -p memory-scheduler compiles</verify>
  <done>IndexingJobConfig and create_indexing_job exist with scheduler integration</done>
</task>

<task type="auto">
  <name>Task 2: Add GetIndexingStatus RPC to proto</name>
  <files>proto/memory.proto, crates/memory-service/build.rs</files>
  <action>
    Add to memory.proto:

    1. IndexingStatus message:
       ```protobuf
       message IndexingStatus {
         bool available = 1;              // Is indexing enabled
         bool bm25_enabled = 2;           // Is BM25 indexer configured
         bool vector_enabled = 3;         // Is vector indexer configured
         uint64 last_sequence = 4;        // Last outbox sequence processed
         string last_processed_time = 5;  // ISO8601 timestamp
         uint64 total_processed = 6;      // Total items processed
         uint64 pending_entries = 7;      // Outbox entries waiting to be processed
       }
       ```

    2. GetIndexingStatusRequest (empty):
       ```protobuf
       message GetIndexingStatusRequest {}
       ```

    3. GetIndexingStatusResponse:
       ```protobuf
       message GetIndexingStatusResponse {
         IndexingStatus status = 1;
       }
       ```

    4. Add RPC to MemoryService:
       ```protobuf
       rpc GetIndexingStatus(GetIndexingStatusRequest) returns (GetIndexingStatusResponse);
       ```

    Run cargo build to regenerate proto code.
  </action>
  <verify>cargo build -p memory-service compiles with new proto</verify>
  <done>Proto has GetIndexingStatus RPC with IndexingStatus message</done>
</task>

<task type="auto">
  <name>Task 3: Implement GetIndexingStatus handler and wire daemon</name>
  <files>crates/memory-service/src/lib.rs, crates/memory-daemon/src/lib.rs</files>
  <action>
    1. Add indexing status handler to memory-service:
       - Store Option<Arc<IndexingPipeline>> in MemoryServiceImpl
       - Add with_indexing_pipeline() builder method
       - Implement get_indexing_status() handler:
         a. If pipeline is None, return status with available=false
         b. If pipeline is Some:
            - Load checkpoint from pipeline
            - Get outbox count from storage stats
            - Calculate pending_entries = outbox_count - last_sequence
            - Return populated IndexingStatus

    2. Wire indexing job in daemon startup (memory-daemon/src/lib.rs):
       - In run_server_with_scheduler or equivalent:
         a. Create IndexingPipeline with storage (no actual indexers yet - pass None for both)
         b. Call create_indexing_job() with scheduler and pipeline
         c. Pass pipeline to MemoryServiceImpl::with_indexing_pipeline()
       - Note: Pipeline will process entries but skip actual indexing until Phase 11/12 provide indexers

    3. Add integration test:
       - Start daemon with scheduler
       - Call GetIndexingStatus RPC
       - Verify available=true, bm25_enabled=false, vector_enabled=false (no indexers)
  </action>
  <verify>cargo test -p memory-daemon -- indexing passes</verify>
  <done>GetIndexingStatus RPC returns pipeline status, indexing job registered at startup</done>
</task>

</tasks>

<verification>
1. `cargo build -p memory-scheduler` compiles without warnings
2. `cargo build -p memory-service` compiles with proto changes
3. `cargo build -p memory-daemon` compiles with indexing wiring
4. `cargo test -p memory-scheduler` all tests pass
5. `cargo test -p memory-daemon` all tests pass
6. gRPC GetIndexingStatus returns valid response
</verification>

<success_criteria>
- Indexing job runs every 30 seconds by default
- Job uses OverlapPolicy::Skip to prevent concurrent execution
- GetIndexingStatus RPC returns checkpoint info and pending count
- Daemon starts with indexing job registered
- Indexing is non-blocking for event ingestion
</success_criteria>

<output>
After completion, create `.planning/phases/13-outbox-index-ingestion/13-04-SUMMARY.md`
</output>
