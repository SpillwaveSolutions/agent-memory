---
phase: 13-outbox-index-ingestion
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/memory-indexing/Cargo.toml
  - crates/memory-indexing/src/lib.rs
  - crates/memory-indexing/src/error.rs
  - crates/memory-indexing/src/checkpoint.rs
  - crates/memory-storage/src/db.rs
  - Cargo.toml
autonomous: true

must_haves:
  truths:
    - "Outbox entries can be read in sequence order starting from any sequence number"
    - "Checkpoint tracks last processed sequence per index type"
    - "Checkpoint persists across daemon restarts"
  artifacts:
    - path: "crates/memory-indexing/Cargo.toml"
      provides: "Crate manifest for indexing pipeline"
      contains: "[package]"
    - path: "crates/memory-indexing/src/lib.rs"
      provides: "Public API exports"
      exports: ["IndexCheckpoint", "IndexType", "IndexingError"]
    - path: "crates/memory-indexing/src/checkpoint.rs"
      provides: "Checkpoint type and persistence"
      contains: "IndexCheckpoint"
    - path: "crates/memory-indexing/src/error.rs"
      provides: "Error types for indexing"
      contains: "IndexingError"
  key_links:
    - from: "crates/memory-indexing/src/checkpoint.rs"
      to: "crates/memory-storage/src/db.rs"
      via: "Storage::put_checkpoint/get_checkpoint"
      pattern: "storage\\.(put|get)_checkpoint"
    - from: "crates/memory-storage/src/db.rs"
      to: "CF_OUTBOX"
      via: "get_outbox_entries"
      pattern: "iterator_cf.*CF_OUTBOX"
---

<objective>
Create the memory-indexing crate with outbox reading and checkpoint tracking infrastructure.

Purpose: Establish the foundation for consuming outbox entries and tracking indexing progress with crash recovery.
Output: New memory-indexing crate with checkpoint persistence and outbox entry reading APIs in storage.
</objective>

<execution_context>
@/Users/richardhightower/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardhightower/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-outbox-index-ingestion/13-RESEARCH.md
@crates/memory-storage/src/db.rs
@crates/memory-storage/src/keys.rs
@crates/memory-types/src/outbox.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add memory-indexing crate to workspace</name>
  <files>Cargo.toml, crates/memory-indexing/Cargo.toml</files>
  <action>
    1. Add "memory-indexing" to workspace members in root Cargo.toml
    2. Create crates/memory-indexing/Cargo.toml with:
       - Package name: memory-indexing
       - Version: 0.1.0
       - Edition: 2021
       - Dependencies:
         - memory-storage = { workspace = true }
         - memory-types = { workspace = true }
         - tokio = { workspace = true, features = ["rt-multi-thread", "sync"] }
         - tracing = { workspace = true }
         - serde = { workspace = true, features = ["derive"] }
         - serde_json = { workspace = true }
         - chrono = { workspace = true, features = ["serde"] }
         - thiserror = { workspace = true }
       - Dev dependencies: tempfile (for tests)
    3. Create src/ directory structure

    Do NOT add memory-search or memory-vector dependencies yet - those will be added in Plan 13-02.
  </action>
  <verify>cargo check -p memory-indexing compiles without errors</verify>
  <done>memory-indexing crate exists in workspace and compiles</done>
</task>

<task type="auto">
  <name>Task 2: Implement outbox entry reading in Storage</name>
  <files>crates/memory-storage/src/db.rs</files>
  <action>
    Add two new methods to Storage impl:

    1. `get_outbox_entries(start_sequence: u64, limit: usize) -> Result<Vec<(u64, OutboxEntry)>, StorageError>`
       - Get CF_OUTBOX handle
       - Create OutboxKey::new(start_sequence) for starting position
       - Use iterator_cf with IteratorMode::From(start_key, Direction::Forward)
       - Take up to `limit` entries
       - For each item, decode OutboxKey and OutboxEntry
       - Return Vec of (sequence, entry) tuples

    2. `delete_outbox_entries(up_to_sequence: u64) -> Result<usize, StorageError>`
       - Iterate from start to up_to_sequence
       - Batch delete all entries with WriteBatch
       - Return count of deleted entries

    Follow existing patterns from get_events_in_range for iteration.
    Import OutboxEntry from memory_types in the db.rs file.
    Add unit tests for both methods.
  </action>
  <verify>cargo test -p memory-storage -- outbox passes</verify>
  <done>Storage has get_outbox_entries and delete_outbox_entries methods with tests</done>
</task>

<task type="auto">
  <name>Task 3: Create IndexCheckpoint and error types</name>
  <files>
    crates/memory-indexing/src/lib.rs,
    crates/memory-indexing/src/error.rs,
    crates/memory-indexing/src/checkpoint.rs
  </files>
  <action>
    1. Create error.rs with IndexingError enum:
       - Storage(StorageError) - wrap storage errors
       - Checkpoint(String) - checkpoint load/save issues
       - Serialization(String) - JSON encoding errors
       - Index(String) - generic index operation errors
       Use thiserror derive macro.

    2. Create checkpoint.rs with:
       - IndexType enum: Bm25, Vector, Combined (with Serialize/Deserialize)
       - IndexCheckpoint struct with fields:
         - index_type: IndexType
         - last_sequence: u64 (last outbox sequence processed)
         - last_processed_time: DateTime<Utc> (use chrono::serde::ts_milliseconds)
         - processed_count: u64 (total items processed)
         - created_at: DateTime<Utc>
       - Implement checkpoint_key() returning "index_bm25", "index_vector", or "index_combined"
       - Implement to_bytes() and from_bytes() using serde_json
       - Add unit tests for serialization roundtrip

    3. Create lib.rs that:
       - Declares modules: pub mod error; pub mod checkpoint;
       - Re-exports: IndexingError, IndexCheckpoint, IndexType

    Follow patterns from memory-types/src/outbox.rs for serialization.
  </action>
  <verify>cargo test -p memory-indexing passes</verify>
  <done>IndexCheckpoint, IndexType, and IndexingError types exist with serialization</done>
</task>

</tasks>

<verification>
1. `cargo build -p memory-indexing` compiles without warnings
2. `cargo test -p memory-indexing` all tests pass
3. `cargo test -p memory-storage -- outbox` all outbox tests pass
4. `cargo clippy -p memory-indexing -- -D warnings` no lint errors
</verification>

<success_criteria>
- memory-indexing crate exists and compiles
- Storage has get_outbox_entries() and delete_outbox_entries() methods
- IndexCheckpoint can be serialized/deserialized to/from JSON
- IndexType enum distinguishes BM25, Vector, and Combined indexing
- All unit tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/13-outbox-index-ingestion/13-01-SUMMARY.md`
</output>
