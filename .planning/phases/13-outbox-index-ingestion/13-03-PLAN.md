---
phase: 13-outbox-index-ingestion
plan: 03
type: execute
wave: 2
depends_on: ["13-01"]
files_modified:
  - crates/memory-indexing/src/lib.rs
  - crates/memory-indexing/src/rebuild.rs
  - crates/memory-daemon/src/commands.rs
  - crates/memory-daemon/src/cli.rs
autonomous: true

must_haves:
  truths:
    - "Admin can rebuild all indexes from scratch via CLI command"
    - "Rebuild iterates all TOC nodes and grips from storage"
    - "Rebuild clears existing indexes before re-indexing"
    - "Progress is reported during rebuild"
  artifacts:
    - path: "crates/memory-indexing/src/rebuild.rs"
      provides: "Full index rebuild logic"
      contains: "rebuild_all"
      min_lines: 80
    - path: "crates/memory-daemon/src/commands.rs"
      provides: "CLI command handler for rebuild-indexes"
      contains: "rebuild_indexes"
  key_links:
    - from: "crates/memory-indexing/src/rebuild.rs"
      to: "crates/memory-storage/src/db.rs"
      via: "Storage for TOC node and grip iteration"
      pattern: "storage\\.get_toc_nodes_by_level"
    - from: "crates/memory-daemon/src/commands.rs"
      to: "crates/memory-indexing/src/rebuild.rs"
      via: "rebuild_all"
      pattern: "rebuild_all"
---

<objective>
Implement full index rebuild command for admin recovery scenarios.

Purpose: Enable administrators to rebuild search indexes from primary storage when indexes are corrupted or need regeneration.
Output: Admin CLI command `rebuild-indexes` with options for selective or full rebuild.
</objective>

<execution_context>
@/Users/richardhightower/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardhightower/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-outbox-index-ingestion/13-RESEARCH.md
@.planning/phases/13-outbox-index-ingestion/13-01-SUMMARY.md
@crates/memory-daemon/src/commands.rs
@crates/memory-daemon/src/cli.rs
@crates/memory-storage/src/db.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement rebuild logic in memory-indexing</name>
  <files>crates/memory-indexing/src/rebuild.rs, crates/memory-indexing/src/lib.rs</files>
  <action>
    Create rebuild.rs with RebuildStats struct and rebuild_all() method:

    1. RebuildStats struct:
       - nodes_indexed: u64 (count of TOC nodes processed)
       - grips_indexed: u64 (count of grips processed)
       - duration: std::time::Duration
       - bm25_rebuilt: bool
       - vector_rebuilt: bool

    2. Implement rebuild_all() on IndexingPipeline:
       ```rust
       pub async fn rebuild_all(&self) -> Result<RebuildStats, IndexingError>
       ```
       Logic:
       a. Log "Starting full index rebuild"
       b. Track start time
       c. If bm25_indexer is Some, call clear() trait method (add to trait in pipeline.rs)
       d. If vector_indexer is Some, call clear() trait method
       e. Iterate all TOC levels in order: Year, Month, Week, Day, Segment
          - For each level, call storage.get_toc_nodes_by_level(level, None, None)
          - For each node, call index_toc_node() on both indexers
          - Log progress every 100 nodes
       f. Get all grips (add storage.get_all_grips() if needed)
          - For each grip, call index_grip() on both indexers
       g. Commit both indexers
       h. Reset checkpoint to sequence 0 (or delete checkpoint)
       i. Log completion with stats
       j. Return RebuildStats

    3. Add clear() method to Bm25Indexer and VectorIndexer traits:
       ```rust
       async fn clear(&self) -> Result<(), IndexingError>;
       ```

    4. Update lib.rs to export rebuild module and RebuildStats

    Add storage.get_all_grips() if it doesn't exist - iterate CF_GRIPS from start,
    filter out index entries (skip keys starting with "node:").
  </action>
  <verify>cargo check -p memory-indexing compiles</verify>
  <done>rebuild_all() method exists with TOC and grip iteration logic</done>
</task>

<task type="auto">
  <name>Task 2: Add get_all_grips to Storage if needed</name>
  <files>crates/memory-storage/src/db.rs</files>
  <action>
    Check if Storage::get_all_grips() exists. If not, add it:

    ```rust
    /// Get all grips from storage (excludes index entries).
    pub fn get_all_grips(&self) -> Result<Vec<memory_types::Grip>, StorageError> {
        let grips_cf = self.db.cf_handle(CF_GRIPS)
            .ok_or_else(|| StorageError::ColumnFamilyNotFound(CF_GRIPS.to_string()))?;

        let mut grips = Vec::new();
        let iter = self.db.iterator_cf(&grips_cf, IteratorMode::Start);

        for item in iter {
            let (key, value) = item?;
            let key_str = String::from_utf8_lossy(&key);

            // Skip index entries (node:xxx:yyy)
            if key_str.starts_with("node:") {
                continue;
            }

            // Skip if not a grip entry (starts with "grip:")
            if !key_str.starts_with("grip:") {
                continue;
            }

            let grip = memory_types::Grip::from_bytes(&value)
                .map_err(|e| StorageError::Serialization(e.to_string()))?;
            grips.push(grip);
        }

        Ok(grips)
    }
    ```

    Add unit test for get_all_grips():
    - Create test storage
    - Add 3 grips (some with node links, some without)
    - Call get_all_grips()
    - Verify all 3 grips returned (not index entries)
  </action>
  <verify>cargo test -p memory-storage -- get_all_grips passes</verify>
  <done>Storage has get_all_grips() method with test</done>
</task>

<task type="auto">
  <name>Task 3: Add rebuild-indexes CLI command</name>
  <files>crates/memory-daemon/src/commands.rs, crates/memory-daemon/src/cli.rs</files>
  <action>
    1. Add rebuild-indexes subcommand to admin CLI in cli.rs:
       ```rust
       #[derive(Parser)]
       pub struct RebuildIndexesCmd {
           /// Only rebuild BM25 index
           #[arg(long)]
           bm25_only: bool,

           /// Only rebuild vector index
           #[arg(long)]
           vector_only: bool,

           /// Show what would be rebuilt without actually rebuilding
           #[arg(long)]
           dry_run: bool,
       }
       ```
       Add to AdminCommands enum.

    2. Implement handler in commands.rs:
       - Open storage directly (like other admin commands)
       - If dry_run, print stats about what would be rebuilt:
         - Count TOC nodes by level
         - Count grips
         - Show which indexes would be rebuilt
       - If not dry_run:
         - Note: For now, print "Index rebuilding requires indexers to be configured"
         - The actual rebuild will work once Phase 11/12 provide real indexers
         - Store the stats struct and print summary

    3. Wire up in cli.rs admin match arm

    Note: The actual rebuild execution will print a placeholder message until
    memory-search and memory-vector crates provide real indexer implementations.
    The dry-run mode will work fully since it only reads storage stats.
  </action>
  <verify>cargo build -p memory-daemon && target/debug/memory-daemon admin rebuild-indexes --dry-run works</verify>
  <done>CLI has rebuild-indexes command with --dry-run, --bm25-only, --vector-only flags</done>
</task>

</tasks>

<verification>
1. `cargo build -p memory-indexing` compiles without warnings
2. `cargo build -p memory-daemon` compiles without warnings
3. `cargo test -p memory-indexing` all tests pass
4. `cargo test -p memory-storage` all tests pass
5. `target/debug/memory-daemon admin rebuild-indexes --help` shows correct options
6. `target/debug/memory-daemon admin rebuild-indexes --dry-run` runs without error
</verification>

<success_criteria>
- rebuild_all() method iterates all TOC nodes and grips
- Storage has get_all_grips() if it didn't exist
- CLI command `admin rebuild-indexes` is available
- Dry run mode shows what would be rebuilt
- Progress logging during rebuild
</success_criteria>

<output>
After completion, create `.planning/phases/13-outbox-index-ingestion/13-03-SUMMARY.md`
</output>
