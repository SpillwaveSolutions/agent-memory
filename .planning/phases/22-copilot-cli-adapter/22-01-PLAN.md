---
phase: 22-copilot-cli-adapter
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - plugins/memory-copilot-adapter/.github/hooks/scripts/memory-capture.sh
  - plugins/memory-copilot-adapter/.github/hooks/memory-hooks.json
autonomous: true

must_haves:
  truths:
    - "Copilot CLI lifecycle events are transformed into memory-ingest JSON format and piped to memory-ingest"
    - "Hook script synthesizes a session ID at sessionStart via temp file keyed by CWD hash, reuses it for subsequent events"
    - "Hook script reuses existing session ID if session file already exists at sessionStart (handles Bug #991 per-prompt firing)"
    - "Hook script cleans up session temp file only on sessionEnd with reason user_exit or complete"
    - "Hook script converts timestamps from Unix milliseconds to ISO 8601 with macOS and Linux date fallbacks"
    - "Hook script parses toolArgs as a JSON string (not an object) with double-parse for preToolUse and postToolUse"
    - "Hook script always exits 0 even on errors (fail-open via trap ERR EXIT)"
    - "Hook script backgrounds memory-ingest call to avoid blocking Copilot's hook loop"
    - "memory-hooks.json registers hooks for 5 captured event types with event type passed as $1 argument"
    - "All events include agent:copilot tag in the payload (lowercase, normalized)"
    - "Hook script strips ANSI escape sequences (including OSC sequences) from stdin before JSON parsing"
    - "Hook script redacts sensitive fields (api_key, token, secret, password, credential, authorization) from payloads"
    - "Hook script adds jq version check with fallback for walk function (requires jq 1.6+)"
  artifacts:
    - path: "plugins/memory-copilot-adapter/.github/hooks/scripts/memory-capture.sh"
      provides: "Shell hook handler that synthesizes session IDs and transforms Copilot JSON to memory-ingest format"
      min_lines: 100
    - path: "plugins/memory-copilot-adapter/.github/hooks/memory-hooks.json"
      provides: "Copilot CLI hook configuration for all captured event types"
      contains: "sessionStart"
  key_links:
    - from: "plugins/memory-copilot-adapter/.github/hooks/scripts/memory-capture.sh"
      to: "memory-ingest binary"
      via: "stdin JSON pipe (backgrounded)"
      pattern: "memory-ingest.*>/dev/null"
    - from: "plugins/memory-copilot-adapter/.github/hooks/memory-hooks.json"
      to: "plugins/memory-copilot-adapter/.github/hooks/scripts/memory-capture.sh"
      via: "bash field in hook config entries"
      pattern: "memory-capture\\.sh"
---

<objective>
Create the Copilot CLI event capture infrastructure: a shell hook handler script that synthesizes session IDs (Copilot does not provide them), transforms Copilot lifecycle events into memory-ingest format, and the memory-hooks.json configuration that registers all captured event types.

Purpose: Enable Copilot CLI sessions to be captured into agent-memory with `agent:copilot` tagging, using the existing `memory-ingest` binary. The critical difference from Gemini is that Copilot does NOT include session_id or event type in its JSON -- the script must synthesize session IDs via temp files and receive the event type as a $1 argument.

Output: Working hook script + memory-hooks.json that captures sessionStart, sessionEnd, userPromptSubmitted, preToolUse, and postToolUse events.
</objective>

<execution_context>
@/Users/richardhightower/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardhightower/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/22-copilot-cli-adapter/22-RESEARCH.md
@crates/memory-ingest/src/main.rs
@plugins/memory-gemini-adapter/.gemini/hooks/memory-capture.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create memory-capture.sh hook handler script with session ID synthesis</name>
  <files>plugins/memory-copilot-adapter/.github/hooks/scripts/memory-capture.sh</files>
  <action>
Create the shell script that serves as Copilot CLI's hook handler. This script has CRITICAL differences from the Gemini adapter:

1. **Event type from $1 argument (not JSON):** Copilot does NOT include the event type in the JSON payload. Each hook config entry passes the event type as a script argument: `memory-capture.sh sessionStart`. Read event type from `$1`.

2. **Session ID synthesis (not in JSON):** Copilot does NOT provide session_id. The script must:
   - At `sessionStart`: Check if a session temp file already exists for this CWD (handles Bug #991 where sessionStart fires per-prompt). If exists, reuse it. If not, generate a UUID via `uuidgen` (with fallback to `/proc/sys/kernel/random/uuid` then `date +%s-$$`) and write to `/tmp/copilot-memory-session-{CWD_HASH}`.
   - CWD hash: `printf '%s' "$CWD" | md5sum 2>/dev/null | cut -d' ' -f1` with fallback to `md5` for macOS.
   - At `sessionEnd`: Read session ID from temp file. Only delete the file if `reason` is `"user_exit"` or `"complete"` (preserve for resumed sessions).
   - All other events: Read session ID from temp file, default to `"copilot-unknown"` if missing.

3. **Timestamp conversion:** Copilot sends timestamps as Unix milliseconds (e.g., `1704614400000`). Convert to ISO 8601:
   ```bash
   TS_SEC=$((TS_MS / 1000))
   TIMESTAMP=$(date -r "$TS_SEC" -u +"%Y-%m-%dT%H:%M:%SZ" 2>/dev/null || \
               date -d "@$TS_SEC" -u +"%Y-%m-%dT%H:%M:%SZ" 2>/dev/null || \
               date -u +"%Y-%m-%dT%H:%M:%SZ")
   ```
   Note: `date -r` is macOS, `date -d` is Linux. Handle both.

4. **toolArgs double-parse:** The `toolArgs` field in preToolUse/postToolUse is a JSON-encoded STRING, not an object. Parse it as a string first, then parse the string value as JSON:
   ```bash
   TOOL_ARGS_STR=$(echo "$INPUT" | jq -r '.toolArgs // "{}"')
   TOOL_INPUT=$(echo "$TOOL_ARGS_STR" | jq -c "$REDACT_FILTER" 2>/dev/null || echo '{}')
   ```

5. **Event mapping:**
   - `sessionStart` -> `"SessionStart"` (extract `.source`, `.initialPrompt`)
   - `sessionEnd` -> `"Stop"` (extract `.reason`)
   - `userPromptSubmitted` -> `"UserPromptSubmit"` (extract `.prompt` as message)
   - `preToolUse` -> `"PreToolUse"` (extract `.toolName`, `.toolArgs`)
   - `postToolUse` -> `"PostToolUse"` (extract `.toolName`, `.toolArgs`)
   - Unknown events: skip silently (return 0)

6. **ANSI stripping:** Strip both standard ANSI sequences AND OSC sequences (lesson from Phase 21 review):
   ```bash
   INPUT=$(printf '%s' "$INPUT" | sed $'s/\x1b\[[0-9;]*[a-zA-Z]//g; s/\x1b\][^\x07]*\x07//g; s/\x1b\][^\x1b]*\x1b\\\\//g') || return 0
   ```

7. **Redaction with jq version check:** The `walk` function requires jq 1.6+. Add a version check:
   ```bash
   JQ_VERSION=$(jq --version 2>/dev/null | sed 's/jq-//')
   if printf '%s\n1.6\n' "$JQ_VERSION" | sort -V | head -1 | grep -q '^1\.6'; then
     REDACT_FILTER='walk(if type == "object" then with_entries(select(.key | test("api_key|token|secret|password|credential|authorization"; "i") | not)) else . end)'
   else
     REDACT_FILTER='.'
   fi
   ```
   If jq < 1.6, skip redaction (fallback to passthrough).

8. **Fail-open pattern:** Use the same function wrapping with `trap fail_open ERR EXIT` as the Gemini adapter. The script MUST NOT output anything to stdout (Copilot ignores stdout for all events except preToolUse, but keep it clean).

9. **Environment variables:**
   - `MEMORY_INGEST_PATH`: Override path to memory-ingest binary (default: `memory-ingest`)
   - `MEMORY_INGEST_DRY_RUN`: If "1", skip sending to memory-ingest (for testing)

Use the research Example 2 as the baseline implementation. Reference the Gemini adapter's `memory-capture.sh` for the fail-open wrapper pattern, but adapt ALL event handling for Copilot's different input schema. Build all payloads with `agent: "copilot"`.

Make the script executable (chmod +x). Create parent directories as needed.
  </action>
  <verify>
1. `file plugins/memory-copilot-adapter/.github/hooks/scripts/memory-capture.sh` shows "shell script"
2. `head -1 plugins/memory-copilot-adapter/.github/hooks/scripts/memory-capture.sh` shows `#!/usr/bin/env bash`
3. Script is executable: `test -x plugins/memory-copilot-adapter/.github/hooks/scripts/memory-capture.sh`
4. Test with simulated input (event type as $1):
   - `echo '{"timestamp":1704614400000,"cwd":"/tmp"}' | MEMORY_INGEST_DRY_RUN=1 bash plugins/memory-copilot-adapter/.github/hooks/scripts/memory-capture.sh sessionStart` exits 0
   - `echo '{"timestamp":1704614400000,"cwd":"/tmp","prompt":"Hello"}' | MEMORY_INGEST_DRY_RUN=1 bash plugins/memory-copilot-adapter/.github/hooks/scripts/memory-capture.sh userPromptSubmitted` exits 0
   - `echo '{"timestamp":1704614400000,"cwd":"/tmp","reason":"complete"}' | MEMORY_INGEST_DRY_RUN=1 bash plugins/memory-copilot-adapter/.github/hooks/scripts/memory-capture.sh sessionEnd` exits 0
   - `echo '' | bash plugins/memory-copilot-adapter/.github/hooks/scripts/memory-capture.sh sessionStart` exits 0 (empty input)
   - `echo 'not json' | bash plugins/memory-copilot-adapter/.github/hooks/scripts/memory-capture.sh sessionStart` exits 0 (invalid JSON)
   - `bash plugins/memory-copilot-adapter/.github/hooks/scripts/memory-capture.sh` exits 0 (no args)
5. Script contains `agent.*copilot` in payload construction
6. Script contains `>/dev/null 2>/dev/null &` for backgrounding memory-ingest
7. Script contains session ID synthesis logic: `uuidgen` and `/tmp/copilot-memory-session`
8. Script contains timestamp conversion: `TS_MS` or `1000` (millisecond division)
9. Script contains ANSI stripping logic (sed with escape sequences)
10. Script contains redaction logic for sensitive fields
11. Script contains `toolArgs` or `TOOL_ARGS_STR` (double-parse handling)
12. Clean up temp files: `rm -f /tmp/copilot-memory-session-* 2>/dev/null`
  </verify>
  <done>
Hook handler script exists, is executable, synthesizes session IDs via temp files, handles all 5 mapped event types (sessionStart, sessionEnd, userPromptSubmitted, preToolUse, postToolUse), converts timestamps from milliseconds to ISO 8601, double-parses toolArgs, includes agent:copilot tag, backgrounds memory-ingest, strips ANSI/OSC sequences, redacts sensitive fields, and exits 0 on all inputs including malformed/empty.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create memory-hooks.json hook configuration</name>
  <files>plugins/memory-copilot-adapter/.github/hooks/memory-hooks.json</files>
  <action>
Create the Copilot CLI hook configuration file that registers the memory-capture.sh script for all 5 captured event types. Copilot hooks use a DIFFERENT format from Gemini's settings.json.

The structure is:
```json
{
  "version": 1,
  "hooks": {
    "eventName": [
      {
        "type": "command",
        "bash": "path/to/script.sh eventName",
        "timeoutSec": 10
      }
    ]
  }
}
```

Register hooks for these 5 events (errorOccurred intentionally omitted -- not conversation content):
1. `sessionStart` -> `.github/hooks/scripts/memory-capture.sh sessionStart`
2. `sessionEnd` -> `.github/hooks/scripts/memory-capture.sh sessionEnd`
3. `userPromptSubmitted` -> `.github/hooks/scripts/memory-capture.sh userPromptSubmitted`
4. `preToolUse` -> `.github/hooks/scripts/memory-capture.sh preToolUse`
5. `postToolUse` -> `.github/hooks/scripts/memory-capture.sh postToolUse`

Use relative path `.github/hooks/scripts/memory-capture.sh` (relative to project root where `.github/hooks/` lives). This works for per-project installation. The install skill in Plan 03 will handle path rewriting for different installation modes.

Set `timeoutSec` to 10 for all hooks. The script backgrounds memory-ingest and returns quickly, so 10 seconds is generous.

Add a `comment` field to each hook entry describing what it captures (e.g., "Capture session start into agent-memory"). While not a standard field, Copilot CLI ignores unknown fields in hook config.

This file is the actual configuration file that will be copied to `.github/hooks/` in the target project. It is NOT merged into settings.json like Gemini -- it is a standalone file.
  </action>
  <verify>
1. `cat plugins/memory-copilot-adapter/.github/hooks/memory-hooks.json | python3 -c "import sys,json; json.load(sys.stdin); print('valid JSON')"` succeeds
2. `cat plugins/memory-copilot-adapter/.github/hooks/memory-hooks.json | python3 -c "import sys,json; d=json.load(sys.stdin); print(d['version'])"` outputs `1`
3. `cat plugins/memory-copilot-adapter/.github/hooks/memory-hooks.json | python3 -c "import sys,json; d=json.load(sys.stdin); print(len(d['hooks']))"` outputs `5`
4. All hook entries reference `memory-capture.sh` in the bash field
5. Each hook entry passes the event name as an argument: verify `sessionStart`, `sessionEnd`, `userPromptSubmitted`, `preToolUse`, `postToolUse` all appear in bash commands
  </verify>
  <done>
memory-hooks.json exists with valid JSON, version 1, registers all 5 event types (sessionStart, sessionEnd, userPromptSubmitted, preToolUse, postToolUse), uses correct Copilot hook structure with bash commands passing event type as $1, and references memory-capture.sh with 10-second timeouts.
  </done>
</task>

</tasks>

<verification>
- Hook script handles all 5 Copilot event types with correct memory-ingest mapping
- Hook script synthesizes session IDs via temp files keyed by CWD hash
- Hook script handles Bug #991 (sessionStart per-prompt) by reusing existing session files
- Hook script converts timestamps from milliseconds to ISO 8601
- Hook script double-parses toolArgs (JSON string, not object)
- Hook script is fail-open: never blocks, backgrounds memory-ingest, exits 0
- memory-hooks.json is valid JSON with correct Copilot hook structure (version: 1)
- Agent tag "copilot" included in all payloads
- ANSI and OSC sequences stripped before JSON parsing
- Sensitive fields redacted with jq version check
</verification>

<success_criteria>
- memory-capture.sh exists, is executable, handles all 5 event types with session ID synthesis
- memory-hooks.json has all 5 hook registrations with event type as $1 argument
- Hook script exits 0 for valid, invalid, empty, and no-argument inputs
- memory-ingest call is backgrounded with output suppressed
- Session temp files are created, reused, and cleaned up correctly
</success_criteria>

<output>
After completion, create `.planning/phases/22-copilot-cli-adapter/22-01-SUMMARY.md`
</output>
