---
phase: 04-query-layer
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - proto/memory.proto
  - crates/memory-service/src/query.rs
  - crates/memory-service/src/lib.rs
  - crates/memory-service/src/server.rs
autonomous: true

must_haves:
  truths:
    - "GetTocRoot returns year-level nodes"
    - "GetNode returns node with children and summary"
    - "BrowseToc supports paginated child navigation"
  artifacts:
    - path: "proto/memory.proto"
      provides: "TOC navigation proto messages and RPCs"
      exports: ["TocNode", "TocBullet", "GetTocRoot", "GetNode", "BrowseToc"]
    - path: "crates/memory-service/src/query.rs"
      provides: "Query RPC implementations"
      exports: ["get_toc_root", "get_node", "browse_toc"]
---

<objective>
Add TOC navigation gRPC RPCs for hierarchical memory traversal.

Purpose: Enable agents to navigate the time-based TOC hierarchy to find relevant conversation periods.
Output: GetTocRoot, GetNode, and BrowseToc RPCs implemented and tested.
</objective>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-query-layer/04-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update Proto with TOC Navigation Messages</name>
  <files>
    - proto/memory.proto
  </files>
  <action>
Add TOC-related messages and navigation RPCs to the proto file.

**Update proto/memory.proto:**

Add after the existing messages:

```protobuf
// Level in the TOC hierarchy
enum TocLevel {
    TOC_LEVEL_UNSPECIFIED = 0;
    TOC_LEVEL_YEAR = 1;
    TOC_LEVEL_MONTH = 2;
    TOC_LEVEL_WEEK = 3;
    TOC_LEVEL_DAY = 4;
    TOC_LEVEL_SEGMENT = 5;
}

// A bullet point in a TOC summary
message TocBullet {
    // The bullet text
    string text = 1;
    // Grip IDs that support this bullet (provenance)
    repeated string grip_ids = 2;
}

// A node in the TOC hierarchy
message TocNode {
    // Unique node identifier (e.g., "toc:year:2024")
    string node_id = 1;
    // Hierarchy level
    TocLevel level = 2;
    // Summary title
    string title = 3;
    // Summary bullet points
    repeated TocBullet bullets = 4;
    // Keywords for search
    repeated string keywords = 5;
    // Child node IDs for navigation
    repeated string child_node_ids = 6;
    // Time range start
    int64 start_time_ms = 7;
    // Time range end
    int64 end_time_ms = 8;
}

// Request to get root TOC nodes (years)
message GetTocRootRequest {
    // Optional: filter by specific year
    optional int32 year = 1;
}

// Response with root TOC nodes
message GetTocRootResponse {
    // Year-level nodes
    repeated TocNode nodes = 1;
}

// Request to get a specific TOC node
message GetNodeRequest {
    // Node ID to fetch
    string node_id = 1;
}

// Response with the requested node
message GetNodeResponse {
    // The node (empty if not found)
    TocNode node = 1;
    // True if node was found
    bool found = 2;
}

// Request to browse children with pagination
message BrowseTocRequest {
    // Parent node ID
    string parent_node_id = 1;
    // Number of children per page (default 10, max 100)
    int32 page_size = 2;
    // Continuation token from previous response
    string continuation_token = 3;
}

// Response with paginated children
message BrowseTocResponse {
    // Child nodes for this page
    repeated TocNode children = 1;
    // Token for next page (empty if no more)
    string next_continuation_token = 2;
    // True if more children exist
    bool has_more = 3;
    // Total count of children
    int32 total_count = 4;
}
```

Add RPCs to the MemoryService:

```protobuf
service MemoryService {
    // ... existing RPCs ...

    // Get root TOC nodes (year level)
    rpc GetTocRoot(GetTocRootRequest) returns (GetTocRootResponse);

    // Get a specific TOC node by ID
    rpc GetNode(GetNodeRequest) returns (GetNodeResponse);

    // Browse children of a TOC node with pagination
    rpc BrowseToc(BrowseTocRequest) returns (BrowseTocResponse);
}
```
  </action>
  <verify>
`cargo build -p memory-service` regenerates proto bindings successfully.
  </verify>
</task>

<task type="auto">
  <name>Task 2: Implement Query Module</name>
  <files>
    - crates/memory-service/src/query.rs
    - crates/memory-service/src/lib.rs
  </files>
  <action>
Create the query module with navigation RPC implementations.

**Create crates/memory-service/src/query.rs:**

```rust
//! Query RPCs for TOC navigation.
//!
//! Per QRY-01: GetTocRoot returns top-level time nodes
//! Per QRY-02: GetNode returns node with children and summary
//! Per QRY-03: BrowseToc supports pagination of children

use std::sync::Arc;
use tracing::debug;

use memory_storage::Storage;
use memory_types::{TocLevel as DomainTocLevel, TocNode as DomainTocNode};

use crate::pb::{
    BrowseTocRequest, BrowseTocResponse,
    GetNodeRequest, GetNodeResponse,
    GetTocRootRequest, GetTocRootResponse,
    TocBullet as PbTocBullet, TocLevel as PbTocLevel, TocNode as PbTocNode,
};

/// Convert domain TocLevel to proto TocLevel
fn to_pb_level(level: DomainTocLevel) -> i32 {
    match level {
        DomainTocLevel::Year => PbTocLevel::Year as i32,
        DomainTocLevel::Month => PbTocLevel::Month as i32,
        DomainTocLevel::Week => PbTocLevel::Week as i32,
        DomainTocLevel::Day => PbTocLevel::Day as i32,
        DomainTocLevel::Segment => PbTocLevel::Segment as i32,
    }
}

/// Convert domain TocNode to proto TocNode
fn to_pb_node(node: &DomainTocNode) -> PbTocNode {
    PbTocNode {
        node_id: node.node_id.clone(),
        level: to_pb_level(node.level),
        title: node.title.clone(),
        bullets: node.bullets.iter().map(|b| PbTocBullet {
            text: b.text.clone(),
            grip_ids: b.grip_ids.clone(),
        }).collect(),
        keywords: node.keywords.clone(),
        child_node_ids: node.child_node_ids.clone(),
        start_time_ms: node.start_time.timestamp_millis(),
        end_time_ms: node.end_time.timestamp_millis(),
    }
}

/// Handle GetTocRoot RPC.
///
/// Returns year-level nodes, optionally filtered by year.
pub fn get_toc_root(
    storage: &Storage,
    request: GetTocRootRequest,
) -> Result<GetTocRootResponse, tonic::Status> {
    debug!("GetTocRoot: year={:?}", request.year);

    // Get all year nodes by scanning for toc:year: prefix
    let mut nodes = Vec::new();

    // If specific year requested, try to get that node
    if let Some(year) = request.year {
        let node_id = format!("toc:year:{}", year);
        if let Ok(Some(node)) = storage.get_toc_node(&node_id) {
            nodes.push(to_pb_node(&node));
        }
    } else {
        // Get all year nodes - scan toc_latest for year prefix
        // Note: This requires iterating, which we handle via get_child_nodes trick
        // Years don't have a parent, so we need direct iteration
        if let Ok(year_nodes) = storage.get_all_year_nodes() {
            for node in year_nodes {
                nodes.push(to_pb_node(&node));
            }
        }
    }

    // Sort by start time descending (most recent first)
    nodes.sort_by(|a, b| b.start_time_ms.cmp(&a.start_time_ms));

    Ok(GetTocRootResponse { nodes })
}

/// Handle GetNode RPC.
///
/// Returns a specific node by ID with its children and summary.
pub fn get_node(
    storage: &Storage,
    request: GetNodeRequest,
) -> Result<GetNodeResponse, tonic::Status> {
    debug!("GetNode: node_id={}", request.node_id);

    match storage.get_toc_node(&request.node_id) {
        Ok(Some(node)) => Ok(GetNodeResponse {
            node: Some(to_pb_node(&node)),
            found: true,
        }),
        Ok(None) => Ok(GetNodeResponse {
            node: None,
            found: false,
        }),
        Err(e) => Err(tonic::Status::internal(format!("Storage error: {}", e))),
    }
}

/// Handle BrowseToc RPC.
///
/// Returns paginated children of a node.
pub fn browse_toc(
    storage: &Storage,
    request: BrowseTocRequest,
) -> Result<BrowseTocResponse, tonic::Status> {
    let page_size = if request.page_size <= 0 || request.page_size > 100 {
        10
    } else {
        request.page_size as usize
    };

    debug!(
        "BrowseToc: parent={}, page_size={}, token={:?}",
        request.parent_node_id, page_size, request.continuation_token
    );

    // Get all children
    let all_children = storage.get_child_nodes(&request.parent_node_id)
        .map_err(|e| tonic::Status::internal(format!("Storage error: {}", e)))?;

    let total_count = all_children.len();

    // Parse continuation token as offset
    let offset: usize = if request.continuation_token.is_empty() {
        0
    } else {
        request.continuation_token.parse().unwrap_or(0)
    };

    // Get page of children
    let page_children: Vec<PbTocNode> = all_children
        .iter()
        .skip(offset)
        .take(page_size)
        .map(to_pb_node)
        .collect();

    let next_offset = offset + page_children.len();
    let has_more = next_offset < total_count;
    let next_token = if has_more {
        next_offset.to_string()
    } else {
        String::new()
    };

    Ok(BrowseTocResponse {
        children: page_children,
        next_continuation_token: next_token,
        has_more,
        total_count: total_count as i32,
    })
}

#[cfg(test)]
mod tests {
    use super::*;
    use chrono::{TimeZone, Utc};
    use memory_types::TocNode as DomainTocNode;
    use tempfile::TempDir;

    fn create_test_storage() -> (Arc<Storage>, TempDir) {
        let temp_dir = TempDir::new().unwrap();
        let storage = Arc::new(Storage::open(temp_dir.path()).unwrap());
        (storage, temp_dir)
    }

    fn create_test_node(node_id: &str, level: DomainTocLevel, title: &str) -> DomainTocNode {
        let timestamp = Utc.with_ymd_and_hms(2024, 1, 29, 12, 0, 0).unwrap();
        let mut node = DomainTocNode::new(
            node_id.to_string(),
            level,
            title.to_string(),
            timestamp,
            timestamp,
        );
        node.keywords = vec!["test".to_string()];
        node
    }

    #[test]
    fn test_get_node_found() {
        let (storage, _temp) = create_test_storage();

        let node = create_test_node("toc:year:2024", DomainTocLevel::Year, "2024");
        storage.put_toc_node(&node).unwrap();

        let request = GetNodeRequest {
            node_id: "toc:year:2024".to_string(),
        };

        let response = get_node(&storage, request).unwrap();

        assert!(response.found);
        assert!(response.node.is_some());
        assert_eq!(response.node.unwrap().title, "2024");
    }

    #[test]
    fn test_get_node_not_found() {
        let (storage, _temp) = create_test_storage();

        let request = GetNodeRequest {
            node_id: "toc:year:1999".to_string(),
        };

        let response = get_node(&storage, request).unwrap();

        assert!(!response.found);
        assert!(response.node.is_none());
    }

    #[test]
    fn test_browse_toc_pagination() {
        let (storage, _temp) = create_test_storage();

        // Create parent with children
        let mut parent = create_test_node("toc:year:2024", DomainTocLevel::Year, "2024");
        for month in 1..=12 {
            let child_id = format!("toc:month:2024-{:02}", month);
            parent.child_node_ids.push(child_id.clone());

            let child = create_test_node(&child_id, DomainTocLevel::Month, &format!("Month {}", month));
            storage.put_toc_node(&child).unwrap();
        }
        storage.put_toc_node(&parent).unwrap();

        // First page
        let request = BrowseTocRequest {
            parent_node_id: "toc:year:2024".to_string(),
            page_size: 5,
            continuation_token: String::new(),
        };

        let response = browse_toc(&storage, request).unwrap();

        assert_eq!(response.children.len(), 5);
        assert!(response.has_more);
        assert_eq!(response.total_count, 12);
        assert_eq!(response.next_continuation_token, "5");

        // Second page
        let request = BrowseTocRequest {
            parent_node_id: "toc:year:2024".to_string(),
            page_size: 5,
            continuation_token: "5".to_string(),
        };

        let response = browse_toc(&storage, request).unwrap();

        assert_eq!(response.children.len(), 5);
        assert!(response.has_more);

        // Last page
        let request = BrowseTocRequest {
            parent_node_id: "toc:year:2024".to_string(),
            page_size: 5,
            continuation_token: "10".to_string(),
        };

        let response = browse_toc(&storage, request).unwrap();

        assert_eq!(response.children.len(), 2);
        assert!(!response.has_more);
    }
}
```

**Update crates/memory-service/src/lib.rs:**

Add the query module:

```rust
pub mod query;
```
  </action>
  <verify>
`cargo build -p memory-service` compiles with query module.
`cargo test -p memory-service` passes.
  </verify>
</task>

<task type="auto">
  <name>Task 3: Add get_all_year_nodes to Storage</name>
  <files>
    - crates/memory-storage/src/db.rs
  </files>
  <action>
Add a method to retrieve all year-level TOC nodes.

**Add to crates/memory-storage/src/db.rs:**

```rust
/// Get all year-level TOC nodes.
///
/// Scans toc_latest for nodes with "toc:year:" prefix.
pub fn get_all_year_nodes(&self) -> Result<Vec<memory_types::TocNode>, StorageError> {
    let toc_latest_cf = self.db.cf_handle(CF_TOC_LATEST)
        .ok_or_else(|| StorageError::ColumnFamilyNotFound(CF_TOC_LATEST.to_string()))?;

    let prefix = b"toc:year:";
    let mut opts = rocksdb::ReadOptions::default();
    opts.set_iterate_range(rocksdb::PrefixRange(prefix));

    let iter = self.db.iterator_cf_opt(
        &toc_latest_cf,
        opts,
        rocksdb::IteratorMode::From(prefix, rocksdb::Direction::Forward),
    );

    let mut nodes = Vec::new();
    for item in iter {
        let (key, value) = item.map_err(|e| StorageError::Rocksdb(e))?;

        // Check we're still in the prefix range
        if !key.starts_with(prefix) {
            break;
        }

        let node: memory_types::TocNode = serde_json::from_slice(&value)
            .map_err(|e| StorageError::Serialization(e.to_string()))?;
        nodes.push(node);
    }

    Ok(nodes)
}
```

Add test:

```rust
#[test]
fn test_get_all_year_nodes() {
    let (storage, _temp) = create_test_storage();

    // Create year nodes
    for year in [2022, 2023, 2024] {
        let node = create_test_toc_node(&format!("toc:year:{}", year), "Year");
        storage.put_toc_node(&node).unwrap();
    }

    let years = storage.get_all_year_nodes().unwrap();
    assert_eq!(years.len(), 3);
}
```
  </action>
  <verify>
`cargo test -p memory-storage` passes with new test.
  </verify>
</task>

<task type="auto">
  <name>Task 4: Wire RPCs into Service</name>
  <files>
    - crates/memory-service/src/ingest.rs
  </files>
  <action>
Add the query RPC handlers to the MemoryServiceImpl.

**Update crates/memory-service/src/ingest.rs:**

Add the new RPC implementations to MemoryServiceImpl:

```rust
use crate::query;
use crate::pb::{
    GetTocRootRequest, GetTocRootResponse,
    GetNodeRequest, GetNodeResponse,
    BrowseTocRequest, BrowseTocResponse,
};

// Add to the impl block:

#[tonic::async_trait]
impl MemoryService for MemoryServiceImpl {
    // ... existing IngestEvent implementation ...

    async fn get_toc_root(
        &self,
        request: tonic::Request<GetTocRootRequest>,
    ) -> Result<tonic::Response<GetTocRootResponse>, tonic::Status> {
        let response = query::get_toc_root(&self.storage, request.into_inner())?;
        Ok(tonic::Response::new(response))
    }

    async fn get_node(
        &self,
        request: tonic::Request<GetNodeRequest>,
    ) -> Result<tonic::Response<GetNodeResponse>, tonic::Status> {
        let response = query::get_node(&self.storage, request.into_inner())?;
        Ok(tonic::Response::new(response))
    }

    async fn browse_toc(
        &self,
        request: tonic::Request<BrowseTocRequest>,
    ) -> Result<tonic::Response<BrowseTocResponse>, tonic::Status> {
        let response = query::browse_toc(&self.storage, request.into_inner())?;
        Ok(tonic::Response::new(response))
    }
}
```
  </action>
  <verify>
`cargo build -p memory-service` compiles with wired RPCs.
`cargo test --workspace` passes all tests.
  </verify>
</task>

</tasks>

<verification>
1. `cargo build -p memory-service` compiles successfully
2. `cargo test --workspace` passes all tests
3. Proto file includes TocNode, TocBullet, TocLevel messages
4. GetTocRoot, GetNode, BrowseToc RPCs implemented
5. Pagination works correctly in BrowseToc
6. GetNode returns found=false for missing nodes
</verification>

<success_criteria>
- QRY-01: GetTocRoot returns year-level nodes
- QRY-02: GetNode returns node with children and summary
- QRY-03: BrowseToc supports paginated child navigation
- All existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-query-layer/04-01-SUMMARY.md`
</output>
