---
phase: 04-query-layer
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - proto/memory.proto
  - crates/memory-service/src/query.rs
  - crates/memory-service/src/ingest.rs
autonomous: true

must_haves:
  truths:
    - "GetEvents retrieves raw events by time range"
    - "ExpandGrip retrieves context around grip excerpt"
  artifacts:
    - path: "proto/memory.proto"
      provides: "Event retrieval proto messages and RPCs"
      exports: ["GetEvents", "ExpandGrip", "Grip"]
    - path: "crates/memory-service/src/query.rs"
      provides: "Event retrieval RPC implementations"
      exports: ["get_events", "expand_grip"]
---

<objective>
Add event retrieval gRPC RPCs for direct event access and grip expansion.

Purpose: Enable agents to retrieve raw events for verification and context around summaries.
Output: GetEvents and ExpandGrip RPCs implemented and tested.
</objective>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-query-layer/04-RESEARCH.md
@.planning/phases/04-query-layer/04-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update Proto with Event Retrieval Messages</name>
  <files>
    - proto/memory.proto
  </files>
  <action>
Add event retrieval and grip expansion messages and RPCs.

**Update proto/memory.proto:**

Add after the existing messages:

```protobuf
// A grip (excerpt with provenance pointers)
message Grip {
    // Unique grip identifier
    string grip_id = 1;
    // Excerpt text
    string excerpt = 2;
    // Event ID where excerpt starts
    string event_id_start = 3;
    // Event ID where excerpt ends
    string event_id_end = 4;
    // Timestamp of the excerpt
    int64 timestamp_ms = 5;
    // Source identifier (e.g., TOC node ID)
    string source = 6;
    // Optional TOC node this grip is linked to
    optional string toc_node_id = 7;
}

// Request to get events in a time range
message GetEventsRequest {
    // Start of time range (inclusive)
    int64 start_time_ms = 1;
    // End of time range (inclusive)
    int64 end_time_ms = 2;
    // Maximum number of events to return (default 100, max 1000)
    int32 limit = 3;
}

// Response with events
message GetEventsResponse {
    // Events in the requested range
    repeated Event events = 1;
    // True if more events exist beyond limit
    bool has_more = 2;
}

// Request to expand a grip with context
message ExpandGripRequest {
    // Grip ID to expand
    string grip_id = 1;
    // Number of events before excerpt (default 3)
    int32 events_before = 2;
    // Number of events after excerpt (default 3)
    int32 events_after = 3;
}

// Response with expanded grip context
message ExpandGripResponse {
    // The grip details
    Grip grip = 1;
    // Events before the excerpt
    repeated Event events_before = 2;
    // Events in the excerpt range
    repeated Event excerpt_events = 3;
    // Events after the excerpt
    repeated Event events_after = 4;
    // True if grip was found
    bool found = 5;
}
```

Add RPCs to the MemoryService:

```protobuf
service MemoryService {
    // ... existing RPCs ...

    // Get raw events in a time range
    rpc GetEvents(GetEventsRequest) returns (GetEventsResponse);

    // Expand a grip with surrounding context
    rpc ExpandGrip(ExpandGripRequest) returns (ExpandGripResponse);
}
```
  </action>
  <verify>
`cargo build -p memory-service` regenerates proto bindings successfully.
  </verify>
</task>

<task type="auto">
  <name>Task 2: Implement Event Retrieval Functions</name>
  <files>
    - crates/memory-service/src/query.rs
  </files>
  <action>
Add GetEvents and ExpandGrip implementations to the query module.

**Add to crates/memory-service/src/query.rs:**

```rust
use memory_toc::{ExpandConfig, GripExpander};
use memory_types::{Event as DomainEvent, Grip as DomainGrip};

use crate::pb::{
    GetEventsRequest, GetEventsResponse,
    ExpandGripRequest, ExpandGripResponse,
    Event as PbEvent, EventRole as PbEventRole, EventType as PbEventType,
    Grip as PbGrip,
};

/// Convert domain EventRole to proto EventRole
fn to_pb_role(role: memory_types::EventRole) -> i32 {
    match role {
        memory_types::EventRole::User => PbEventRole::User as i32,
        memory_types::EventRole::Assistant => PbEventRole::Assistant as i32,
        memory_types::EventRole::System => PbEventRole::System as i32,
        memory_types::EventRole::Tool => PbEventRole::Tool as i32,
    }
}

/// Convert domain EventType to proto EventType
fn to_pb_event_type(event_type: memory_types::EventType) -> i32 {
    match event_type {
        memory_types::EventType::SessionStart => PbEventType::SessionStart as i32,
        memory_types::EventType::UserMessage => PbEventType::UserMessage as i32,
        memory_types::EventType::AssistantMessage => PbEventType::AssistantMessage as i32,
        memory_types::EventType::ToolResult => PbEventType::ToolResult as i32,
        memory_types::EventType::AssistantStop => PbEventType::AssistantStop as i32,
        memory_types::EventType::SubagentStart => PbEventType::SubagentStart as i32,
        memory_types::EventType::SubagentStop => PbEventType::SubagentStop as i32,
        memory_types::EventType::SessionEnd => PbEventType::SessionEnd as i32,
    }
}

/// Convert domain Event to proto Event
fn to_pb_event(event: &DomainEvent) -> PbEvent {
    PbEvent {
        event_id: event.event_id.clone(),
        session_id: event.session_id.clone(),
        timestamp_ms: event.timestamp.timestamp_millis(),
        event_type: to_pb_event_type(event.event_type),
        role: to_pb_role(event.role),
        text: event.text.clone(),
        metadata: event.metadata.clone(),
    }
}

/// Convert domain Grip to proto Grip
fn to_pb_grip(grip: &DomainGrip) -> PbGrip {
    PbGrip {
        grip_id: grip.grip_id.clone(),
        excerpt: grip.excerpt.clone(),
        event_id_start: grip.event_id_start.clone(),
        event_id_end: grip.event_id_end.clone(),
        timestamp_ms: grip.timestamp.timestamp_millis(),
        source: grip.source.clone(),
        toc_node_id: grip.toc_node_id.clone(),
    }
}

/// Handle GetEvents RPC.
///
/// Retrieves events in a time range.
pub fn get_events(
    storage: &Storage,
    request: GetEventsRequest,
) -> Result<GetEventsResponse, tonic::Status> {
    let limit = if request.limit <= 0 || request.limit > 1000 {
        100
    } else {
        request.limit as usize
    };

    debug!(
        "GetEvents: start={}, end={}, limit={}",
        request.start_time_ms, request.end_time_ms, limit
    );

    let events_data = storage.get_events_in_range(
        request.start_time_ms,
        request.end_time_ms,
    ).map_err(|e| tonic::Status::internal(format!("Storage error: {}", e)))?;

    let mut events = Vec::new();
    let mut has_more = false;

    for (_key, bytes) in events_data {
        if events.len() >= limit {
            has_more = true;
            break;
        }

        let event: DomainEvent = serde_json::from_slice(&bytes)
            .map_err(|e| tonic::Status::internal(format!("Deserialization error: {}", e)))?;
        events.push(to_pb_event(&event));
    }

    Ok(GetEventsResponse { events, has_more })
}

/// Handle ExpandGrip RPC.
///
/// Expands a grip with surrounding context events.
pub fn expand_grip(
    storage: Arc<Storage>,
    request: ExpandGripRequest,
) -> Result<ExpandGripResponse, tonic::Status> {
    let events_before = if request.events_before <= 0 { 3 } else { request.events_before as usize };
    let events_after = if request.events_after <= 0 { 3 } else { request.events_after as usize };

    debug!(
        "ExpandGrip: grip_id={}, before={}, after={}",
        request.grip_id, events_before, events_after
    );

    let config = ExpandConfig {
        events_before,
        events_after,
        ..Default::default()
    };

    let expander = GripExpander::with_config(storage.clone(), config);

    match expander.expand(&request.grip_id) {
        Ok(expanded) => Ok(ExpandGripResponse {
            grip: Some(to_pb_grip(&expanded.grip)),
            events_before: expanded.events_before.iter().map(to_pb_event).collect(),
            excerpt_events: expanded.excerpt_events.iter().map(to_pb_event).collect(),
            events_after: expanded.events_after.iter().map(to_pb_event).collect(),
            found: true,
        }),
        Err(memory_toc::ExpandError::GripNotFound(_)) => Ok(ExpandGripResponse {
            grip: None,
            events_before: Vec::new(),
            excerpt_events: Vec::new(),
            events_after: Vec::new(),
            found: false,
        }),
        Err(e) => Err(tonic::Status::internal(format!("Expand error: {}", e))),
    }
}
```

Add tests:

```rust
#[test]
fn test_get_events_basic() {
    let (storage, _temp) = create_test_storage();

    // Store some events
    for i in 0..5 {
        let ts = 1706540400000 + i * 60000; // 1 minute apart
        let event = create_test_event("test", ts);
        let event_bytes = serde_json::to_vec(&event).unwrap();
        storage.put_event(&event.event_id, &event_bytes, b"outbox").unwrap();
    }

    let request = GetEventsRequest {
        start_time_ms: 1706540400000,
        end_time_ms: 1706540700000,
        limit: 10,
    };

    let response = get_events(&storage, request).unwrap();

    assert_eq!(response.events.len(), 5);
    assert!(!response.has_more);
}

#[test]
fn test_get_events_with_limit() {
    let (storage, _temp) = create_test_storage();

    // Store 10 events
    for i in 0..10 {
        let ts = 1706540400000 + i * 60000;
        let event = create_test_event("test", ts);
        let event_bytes = serde_json::to_vec(&event).unwrap();
        storage.put_event(&event.event_id, &event_bytes, b"outbox").unwrap();
    }

    let request = GetEventsRequest {
        start_time_ms: 1706540400000,
        end_time_ms: 1706541000000,
        limit: 5,
    };

    let response = get_events(&storage, request).unwrap();

    assert_eq!(response.events.len(), 5);
    assert!(response.has_more);
}
```
  </action>
  <verify>
`cargo build -p memory-service` compiles.
`cargo test -p memory-service` passes with new tests.
  </verify>
</task>

<task type="auto">
  <name>Task 3: Wire Event Retrieval RPCs into Service</name>
  <files>
    - crates/memory-service/src/ingest.rs
  </files>
  <action>
Add the event retrieval RPC handlers to MemoryServiceImpl.

**Update crates/memory-service/src/ingest.rs:**

Add imports and implementations:

```rust
use crate::pb::{
    GetEventsRequest, GetEventsResponse,
    ExpandGripRequest, ExpandGripResponse,
};

// Add to the impl block:

async fn get_events(
    &self,
    request: tonic::Request<GetEventsRequest>,
) -> Result<tonic::Response<GetEventsResponse>, tonic::Status> {
    let response = query::get_events(&self.storage, request.into_inner())?;
    Ok(tonic::Response::new(response))
}

async fn expand_grip(
    &self,
    request: tonic::Request<ExpandGripRequest>,
) -> Result<tonic::Response<ExpandGripResponse>, tonic::Status> {
    let response = query::expand_grip(self.storage.clone(), request.into_inner())?;
    Ok(tonic::Response::new(response))
}
```
  </action>
  <verify>
`cargo build -p memory-service` compiles with wired RPCs.
`cargo test --workspace` passes all tests.
  </verify>
</task>

<task type="auto">
  <name>Task 4: Add memory-toc Dependency to memory-service</name>
  <files>
    - crates/memory-service/Cargo.toml
  </files>
  <action>
Add memory-toc as a dependency for grip expansion.

**Update crates/memory-service/Cargo.toml:**

Add under [dependencies]:

```toml
memory-toc = { path = "../memory-toc" }
```
  </action>
  <verify>
`cargo build -p memory-service` compiles with memory-toc dependency.
  </verify>
</task>

</tasks>

<verification>
1. `cargo build -p memory-service` compiles successfully
2. `cargo test --workspace` passes all tests
3. Proto file includes Grip, GetEventsRequest/Response, ExpandGripRequest/Response
4. GetEvents and ExpandGrip RPCs implemented
5. GetEvents respects limit and indicates has_more
6. ExpandGrip returns context events or found=false
</verification>

<success_criteria>
- QRY-04: GetEvents retrieves raw events by time range
- QRY-05: ExpandGrip retrieves context around grip excerpt
- All existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-query-layer/04-02-SUMMARY.md`
</output>
