# Plan 06-01: Integration Test Harness and Demo Script

## Goal

Create comprehensive integration tests and a demo script that validate the complete workflow from event ingestion through query resolution.

## Success Criteria

1. Integration tests cover full event lifecycle (ingest -> TOC -> query)
2. Tests validate all 5 Phase 6 success criteria
3. Demo script provides runnable example of complete workflow
4. All tests pass with deterministic results

## Tasks

### Task 1: Create Integration Test Module

Create `tests/integration_test.rs` with:

```rust
// tests/integration_test.rs
use std::sync::Arc;
use std::time::Duration;
use tempfile::TempDir;
use tokio::time::sleep;

use memory_client::{MemoryClient, HookEvent, HookEventType, map_hook_event};
use memory_service::{run_server_with_shutdown, MemoryServiceImpl};
use memory_storage::Storage;
use memory_toc::{Segmenter, SegmenterConfig, TocBuilder};
use memory_types::Event;

/// Test harness that manages daemon lifecycle
struct TestHarness {
    _temp_dir: TempDir,
    storage: Arc<Storage>,
    endpoint: String,
    shutdown_tx: Option<tokio::sync::oneshot::Sender<()>>,
}

impl TestHarness {
    async fn new() -> Self {
        let temp_dir = TempDir::new().unwrap();
        let storage = Arc::new(Storage::open(temp_dir.path()).unwrap());

        let addr = "127.0.0.1:0".parse().unwrap();
        let (shutdown_tx, shutdown_rx) = tokio::sync::oneshot::channel();

        let service_storage = storage.clone();
        let server_handle = tokio::spawn(async move {
            let service = MemoryServiceImpl::new(service_storage);
            run_server_with_shutdown(addr, service, shutdown_rx).await.unwrap();
        });

        // Wait for server to start
        sleep(Duration::from_millis(100)).await;

        Self {
            _temp_dir: temp_dir,
            storage,
            endpoint: format!("http://{}", addr),
            shutdown_tx: Some(shutdown_tx),
        }
    }

    async fn client(&self) -> MemoryClient {
        MemoryClient::connect(&self.endpoint).await.unwrap()
    }
}

impl Drop for TestHarness {
    fn drop(&mut self) {
        if let Some(tx) = self.shutdown_tx.take() {
            let _ = tx.send(());
        }
    }
}
```

### Task 2: Add Event Ingestion Tests

```rust
#[tokio::test]
async fn test_event_ingestion_lifecycle() {
    let harness = TestHarness::new().await;
    let mut client = harness.client().await;

    // Create conversation events
    let session_id = "test-session-123";
    let events = vec![
        HookEvent {
            session_id: session_id.to_string(),
            event_type: HookEventType::SessionStart,
            content: "Session started".to_string(),
            timestamp: None,
            tool_name: None,
            metadata: None,
        },
        HookEvent {
            session_id: session_id.to_string(),
            event_type: HookEventType::UserPromptSubmit,
            content: "What is Rust?".to_string(),
            timestamp: None,
            tool_name: None,
            metadata: None,
        },
        HookEvent {
            session_id: session_id.to_string(),
            event_type: HookEventType::AssistantResponse,
            content: "Rust is a systems programming language.".to_string(),
            timestamp: None,
            tool_name: None,
            metadata: None,
        },
    ];

    // Ingest events
    for hook_event in events {
        let event = map_hook_event(hook_event);
        let (event_id, created) = client.ingest(event).await.unwrap();
        assert!(created);
        assert!(!event_id.is_empty());
    }

    // Verify events are stored
    let stats = harness.storage.get_stats().unwrap();
    assert_eq!(stats.event_count, 3);
}
```

### Task 3: Add TOC Navigation Tests

```rust
#[tokio::test]
async fn test_toc_navigation() {
    let harness = TestHarness::new().await;

    // Pre-populate TOC nodes for testing
    // (In real usage, TOC builder would create these)
    create_sample_toc_nodes(&harness.storage);

    let mut client = harness.client().await;

    // Test GetTocRoot
    let root_nodes = client.get_toc_root().await.unwrap();
    assert!(!root_nodes.is_empty());
    assert!(root_nodes[0].level == TocLevel::Year);

    // Test GetNode
    let node = client.get_node(&root_nodes[0].node_id).await.unwrap();
    assert!(node.is_some());

    // Test BrowseToc pagination
    let browse_result = client.browse_toc(
        &root_nodes[0].node_id,
        10,
        None
    ).await.unwrap();
    assert!(!browse_result.children.is_empty());
}
```

### Task 4: Add Grip Expansion Tests

```rust
#[tokio::test]
async fn test_grip_expansion() {
    let harness = TestHarness::new().await;

    // Pre-populate events and grips
    create_sample_events_with_grips(&harness.storage);

    let mut client = harness.client().await;

    // Expand grip to get context
    let result = client.expand_grip(
        "grip:1234567890123:01HXYZ",
        Some(2),  // 2 events before
        Some(2),  // 2 events after
    ).await.unwrap();

    assert!(result.grip.is_some());
    assert!(!result.excerpt_events.is_empty());
}
```

### Task 5: Add Crash Recovery Tests

```rust
#[tokio::test]
async fn test_crash_recovery() {
    let temp_dir = TempDir::new().unwrap();
    let db_path = temp_dir.path();

    // Create storage and ingest events
    {
        let storage = Storage::open(db_path).unwrap();
        let event = Event::new(
            ulid::Ulid::new().to_string(),
            "session-123".to_string(),
            chrono::Utc::now(),
            EventType::UserMessage,
            EventRole::User,
            "Test message".to_string(),
        );
        let bytes = event.to_bytes().unwrap();
        storage.put_event(&event.event_id, &bytes, &[]).unwrap();

        // Checkpoint should be written
        storage.put_checkpoint("test-job", &bytes).unwrap();
    } // Storage closed - simulates crash

    // Reopen storage - should recover
    {
        let storage = Storage::open(db_path).unwrap();

        // Events should still be there
        let stats = storage.get_stats().unwrap();
        assert_eq!(stats.event_count, 1);

        // Checkpoint should be recoverable
        let checkpoint = storage.get_checkpoint("test-job").unwrap();
        assert!(checkpoint.is_some());
    }
}
```

### Task 6: Create Demo Script

Create `scripts/demo.sh`:

```bash
#!/bin/bash
# Demo script for agent-memory system

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_DIR="$(dirname "$SCRIPT_DIR")"
DB_PATH="${PROJECT_DIR}/demo-data"

# Colors for output
GREEN='\033[0;32m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

echo -e "${BLUE}=== Agent Memory Demo ===${NC}"
echo

# Build the project
echo -e "${GREEN}Building project...${NC}"
cargo build --release

# Clean previous demo data
rm -rf "$DB_PATH"

# Start the daemon
echo -e "${GREEN}Starting daemon...${NC}"
cargo run --release --bin memory-daemon -- start --db-path "$DB_PATH" &
DAEMON_PID=$!
sleep 2

# Function to cleanup on exit
cleanup() {
    echo -e "${GREEN}Stopping daemon...${NC}"
    cargo run --release --bin memory-daemon -- stop
    wait $DAEMON_PID 2>/dev/null || true
}
trap cleanup EXIT

# Ingest sample events via gRPC client
echo -e "${GREEN}Ingesting sample conversation...${NC}"
cargo run --release --example ingest_demo

# Show stats
echo -e "${GREEN}Storage stats:${NC}"
cargo run --release --bin memory-daemon -- admin --db-path "$DB_PATH" stats

# Query TOC root
echo -e "${GREEN}Querying TOC root:${NC}"
cargo run --release --bin memory-daemon -- query --endpoint "http://127.0.0.1:50051" root

# Show events from last hour
echo -e "${GREEN}Recent events:${NC}"
NOW=$(date +%s)000
HOUR_AGO=$(( $(date +%s) - 3600 ))000
cargo run --release --bin memory-daemon -- query --endpoint "http://127.0.0.1:50051" events --from "$HOUR_AGO" --to "$NOW" --limit 10

echo
echo -e "${BLUE}=== Demo Complete ===${NC}"
```

### Task 7: Create Ingest Demo Example

Create `examples/ingest_demo.rs`:

```rust
//! Demo: Ingest sample conversation events

use memory_client::{MemoryClient, HookEvent, HookEventType, map_hook_event};
use std::time::Duration;
use tokio::time::sleep;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut client = MemoryClient::connect("http://127.0.0.1:50051").await?;

    let session_id = format!("demo-{}", chrono::Utc::now().timestamp());

    // Simulate a conversation
    let conversation = vec![
        (HookEventType::SessionStart, "Demo session started"),
        (HookEventType::UserPromptSubmit, "What is the agent-memory system?"),
        (HookEventType::AssistantResponse,
         "Agent-memory is a local, append-only storage system for AI agent conversations. \
          It provides TOC-based navigation for efficient recall without scanning everything."),
        (HookEventType::UserPromptSubmit, "How does the TOC work?"),
        (HookEventType::AssistantResponse,
         "The TOC (Table of Contents) organizes events in a time hierarchy: \
          Year -> Month -> Week -> Day -> Segment. Each level has summaries \
          generated from the content below it."),
        (HookEventType::UserPromptSubmit, "What are grips?"),
        (HookEventType::AssistantResponse,
         "Grips are anchors that link summaries back to source evidence. \
          Each grip contains an excerpt and pointers to the original events, \
          providing provenance for summary claims."),
    ];

    for (event_type, content) in conversation {
        let hook_event = HookEvent {
            session_id: session_id.clone(),
            event_type,
            content: content.to_string(),
            timestamp: None,
            tool_name: None,
            metadata: None,
        };

        let event = map_hook_event(hook_event);
        let (event_id, created) = client.ingest(event).await?;

        if created {
            println!("Ingested: {} -> {}", event_type_name(&event_type), &event_id[..8]);
        }

        // Small delay between events
        sleep(Duration::from_millis(50)).await;
    }

    println!("\nIngested {} events for session {}", conversation.len(), &session_id[..16]);
    Ok(())
}

fn event_type_name(t: &HookEventType) -> &'static str {
    match t {
        HookEventType::SessionStart => "SessionStart",
        HookEventType::UserPromptSubmit => "UserPrompt",
        HookEventType::AssistantResponse => "Assistant",
        HookEventType::ToolUse => "ToolUse",
        HookEventType::ToolResult => "ToolResult",
        HookEventType::Stop => "Stop",
        HookEventType::SubagentStart => "SubagentStart",
        HookEventType::SubagentStop => "SubagentStop",
    }
}
```

## Verification

1. `cargo test --test integration_test` passes
2. Demo script runs without errors
3. Events visible through query CLI
4. Storage stats show correct counts

## Dependencies

- All Phase 5 crates (memory-client, memory-service, memory-storage)
- tempfile for isolated test directories
- tokio for async testing

## Notes

- Integration tests use ephemeral storage (TempDir)
- Demo script uses persistent demo-data directory
- MockSummarizer used in tests for determinism
- Real summarizer can be tested separately with API keys
