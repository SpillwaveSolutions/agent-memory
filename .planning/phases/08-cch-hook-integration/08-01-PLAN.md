# Plan 08-01: CCH Hook Handler Binary

**Phase**: 8 - CCH Hook Integration
**Wave**: 1
**Depends on**: Phase 7 complete, memory-client crate

## Goal

Create a `memory-ingest` binary that CCH can invoke to automatically capture conversation events and send them to memory-daemon.

## Context

The `memory-client` crate already provides:
- `HookEvent` type with all CCH event types
- `map_hook_event()` function for conversion
- `MemoryClient` with `ingest()` for gRPC

This plan creates a thin CLI wrapper (~50 lines) that:
1. Reads CCH JSON from stdin
2. Converts to HookEvent
3. Maps to memory Event
4. Sends via gRPC
5. Returns `{"continue": true}` to stdout

## Tasks

### Task 1: Create memory-ingest Crate

**What**: Set up new binary crate in workspace

**Files**:
- `crates/memory-ingest/Cargo.toml`
- `crates/memory-ingest/src/main.rs`

**Cargo.toml**:
```toml
[package]
name = "memory-ingest"
version = "0.1.0"
edition = "2021"

[[bin]]
name = "memory-ingest"
path = "src/main.rs"

[dependencies]
memory-client = { path = "../memory-client" }
memory-types = { path = "../memory-types" }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
tokio = { version = "1.43", features = ["rt"] }
anyhow = "1.0"
chrono = { version = "0.4", features = ["serde"] }
```

**Acceptance Criteria**:
- [x] Crate builds as part of workspace
- [x] Binary name is `memory-ingest`

### Task 2: Implement CCH Event Parsing

**What**: Parse CCH JSON format from stdin

**Implementation**:
```rust
#[derive(Debug, Deserialize)]
struct CchEvent {
    hook_event_name: String,
    session_id: String,
    #[serde(default)]
    message: Option<String>,
    #[serde(default)]
    tool_name: Option<String>,
    #[serde(default)]
    tool_input: Option<serde_json::Value>,
    #[serde(default)]
    timestamp: Option<DateTime<Utc>>,
    #[serde(default)]
    cwd: Option<String>,
}
```

**Acceptance Criteria**:
- [ ] Parses all CCH event types
- [ ] Handles missing optional fields gracefully

### Task 3: Implement Event Mapping

**What**: Convert CchEvent to HookEvent using existing types

**Implementation**:
```rust
fn map_cch_to_hook(cch: &CchEvent) -> HookEvent {
    let event_type = match cch.hook_event_name.as_str() {
        "SessionStart" => HookEventType::SessionStart,
        "UserPromptSubmit" => HookEventType::UserPromptSubmit,
        "PreToolUse" => HookEventType::ToolUse,
        "PostToolUse" => HookEventType::ToolResult,
        "Stop" => HookEventType::Stop,
        "SubagentStart" => HookEventType::SubagentStart,
        "SubagentStop" => HookEventType::SubagentStop,
        _ => HookEventType::UserPromptSubmit, // Default fallback
    };

    let content = cch.message.clone().unwrap_or_default();
    let mut hook = HookEvent::new(&cch.session_id, event_type, content);

    if let Some(ts) = cch.timestamp {
        hook = hook.with_timestamp(ts);
    }
    if let Some(tool) = &cch.tool_name {
        hook = hook.with_tool_name(tool);
    }

    hook
}
```

**Acceptance Criteria**:
- [ ] Maps all CCH event types correctly
- [ ] Preserves timestamp if provided
- [ ] Includes tool_name in metadata

### Task 4: Implement Main Function

**What**: Wire up stdin → parse → map → ingest → stdout

**Implementation**:
```rust
fn main() -> anyhow::Result<()> {
    // Read from stdin
    let stdin = std::io::stdin();
    let mut input = String::new();
    stdin.lock().read_line(&mut input)?;

    // Parse CCH event
    let cch: CchEvent = serde_json::from_str(&input)?;

    // Map to memory event
    let hook_event = map_cch_to_hook(&cch);
    let event = map_hook_event(hook_event);

    // Ingest via gRPC (fail open)
    let rt = tokio::runtime::Runtime::new()?;
    let _ = rt.block_on(async {
        if let Ok(mut client) = MemoryClient::connect_default().await {
            let _ = client.ingest(event).await;
        }
    });

    // Always return success to CCH
    println!(r#"{{"continue":true}}"#);
    Ok(())
}
```

**Acceptance Criteria**:
- [ ] Reads single line from stdin
- [ ] Fails open (returns success even if daemon down)
- [ ] Outputs valid JSON to stdout

### Task 5: Add to Workspace

**What**: Update root Cargo.toml to include new crate

**Edit**: `Cargo.toml` (workspace root)
```toml
[workspace]
members = [
    "crates/memory-daemon",
    "crates/memory-service",
    "crates/memory-client",
    "crates/memory-storage",
    "crates/memory-toc",
    "crates/memory-types",
    "crates/memory-ingest",  # Add this
]
```

**Acceptance Criteria**:
- [ ] `cargo build -p memory-ingest` works
- [ ] `cargo build --release -p memory-ingest` produces optimized binary

### Task 6: Create Example hooks.yaml

**What**: Provide sample CCH configuration

**File**: `examples/hooks.yaml`
```yaml
version: "1.0"

settings:
  fail_open: true
  script_timeout: 5

rules:
  - name: capture-to-memory
    description: Send conversation events to agent-memory daemon
    matchers:
      operations:
        - SessionStart
        - UserPromptSubmit
        - PostToolUse
        - SessionEnd
        - SubagentStart
        - SubagentStop
    actions:
      run: "~/.local/bin/memory-ingest"
```

**Acceptance Criteria**:
- [ ] Example file is valid YAML
- [ ] Comments explain configuration

### Task 7: Write Tests

**What**: Unit tests for event mapping

**Tests**:
- `test_parse_session_start`
- `test_parse_user_prompt`
- `test_parse_tool_use`
- `test_map_all_event_types`
- `test_fail_open_behavior`

**Acceptance Criteria**:
- [ ] All tests pass
- [ ] Coverage for all event types

### Task 8: Update Documentation

**What**: Add installation and usage instructions

**Update**: `docs/README.md` - Add CCH Integration section

**Acceptance Criteria**:
- [ ] Installation instructions
- [ ] hooks.yaml configuration example
- [ ] Troubleshooting section

## Verification

```bash
# Build
cargo build --release -p memory-ingest

# Test with sample event
echo '{"hook_event_name":"UserPromptSubmit","session_id":"test-123","message":"Hello world"}' | ./target/release/memory-ingest
# Expected output: {"continue":true}

# Install
cp target/release/memory-ingest ~/.local/bin/

# Verify installation
~/.local/bin/memory-ingest --version

# Test with daemon running
memory-daemon start
echo '{"hook_event_name":"SessionStart","session_id":"test-123"}' | memory-ingest
memory-daemon query root  # Should show new events
```

## Success Criteria

1. Binary reads CCH JSON from stdin
2. Binary outputs `{"continue":true}` to stdout
3. Events are ingested when daemon is running
4. Binary fails open when daemon is down (no hang, returns success)
5. All CCH event types are mapped correctly
6. Example hooks.yaml provided

## Notes

- Binary must be fast (<100ms) to not slow down Claude
- Always fail open - don't block Claude if memory system is down
- Use existing `memory-client` code - don't duplicate logic
