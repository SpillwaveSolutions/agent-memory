---
phase: 14-topic-graph-memory
plan: 05
type: execute
wave: 5
depends_on: ["14-01", "14-02", "14-03", "14-04"]
files_modified:
  - proto/memory.proto
  - crates/memory-service/src/topic_service.rs
  - crates/memory-service/src/lib.rs
  - crates/memory-service/Cargo.toml
autonomous: true

must_haves:
  truths:
    - "GetTopicGraphStatus RPC returns enabled/healthy status for agent discovery"
    - "GetTopicsByQuery RPC finds topics matching natural language query"
    - "GetTocNodesForTopic RPC returns nodes linked to a topic"
    - "GetTopTopics RPC returns most important topics"
    - "GetRelatedTopics RPC returns similar/parent/child topics"
    - "All RPCs return UNAVAILABLE when topics are disabled"
  artifacts:
    - path: "proto/memory.proto"
      provides: "Topic gRPC message and service definitions"
      contains: "GetTopicGraphStatus"
    - path: "crates/memory-service/src/topic_service.rs"
      provides: "Topic gRPC service implementation"
      exports: ["TopicGrpcService"]
  key_links:
    - from: "crates/memory-service/src/topic_service.rs"
      to: "crates/memory-topics/src/storage.rs"
      via: "queries topic storage"
      pattern: "TopicStorage"
    - from: "crates/memory-service/src/topic_service.rs"
      to: "proto/memory.proto"
      via: "implements generated traits"
      pattern: "GetTopicGraphStatus"
---

<objective>
Implement gRPC service for topic navigation.

Purpose: Expose topic functionality to agents via gRPC. The GetTopicGraphStatus RPC enables agent skills to discover if topics are available. Navigation RPCs let agents explore topics by query, importance, and relationships.

Output: 5 topic RPCs in memory-service: GetTopicGraphStatus, GetTopicsByQuery, GetTocNodesForTopic, GetTopTopics, GetRelatedTopics.
</objective>

<execution_context>
@/Users/richardhightower/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardhightower/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/14-topic-graph-memory/14-RESEARCH.md
@.planning/phases/14-topic-graph-memory/14-01-SUMMARY.md
@proto/memory.proto
@crates/memory-service/src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add topic proto definitions</name>
  <files>
    proto/memory.proto
  </files>
  <action>
Add topic-related message and RPC definitions to memory.proto.

1. Add the following message definitions (ADD to existing proto, do not replace):

   ```protobuf
   // ============ Topic Messages ============

   // Topic entity
   message Topic {
       string topic_id = 1;
       string label = 2;
       double importance_score = 3;
       int32 node_count = 4;
       int64 created_at_ms = 5;
       int64 last_mentioned_at_ms = 6;
       repeated string keywords = 7;
   }

   // Relationship types between topics
   enum TopicRelationshipType {
       TOPIC_RELATIONSHIP_TYPE_UNSPECIFIED = 0;
       TOPIC_RELATIONSHIP_TYPE_SIMILAR = 1;
       TOPIC_RELATIONSHIP_TYPE_PARENT = 2;
       TOPIC_RELATIONSHIP_TYPE_CHILD = 3;
   }

   // Related topic with relationship info
   message RelatedTopic {
       Topic topic = 1;
       TopicRelationshipType relationship_type = 2;
       float score = 3;
   }

   // Link between topic and TOC node
   message TopicNodeLink {
       string node_id = 1;
       string title = 2;
       TocLevel level = 3;
       float relevance = 4;
       int64 timestamp_ms = 5;
   }

   // ============ Topic RPCs ============

   // GetTopicGraphStatus - health and config for agent discovery
   message GetTopicGraphStatusRequest {}

   message GetTopicGraphStatusResponse {
       bool enabled = 1;
       bool healthy = 2;
       int64 topic_count = 3;
       int64 link_count = 4;
       int64 last_extraction_ms = 5;
       string message = 6;
       int32 half_life_days = 7;
       float similarity_threshold = 8;
   }

   // GetTopicsByQuery - find topics matching natural language
   message GetTopicsByQueryRequest {
       string query = 1;
       int32 limit = 2;
       float min_score = 3;
   }

   message GetTopicsByQueryResponse {
       repeated Topic topics = 1;
       repeated float scores = 2;
   }

   // GetTocNodesForTopic - get nodes linked to a topic
   message GetTocNodesForTopicRequest {
       string topic_id = 1;
       int32 limit = 2;
       float min_relevance = 3;
   }

   message GetTocNodesForTopicResponse {
       repeated TopicNodeLink nodes = 1;
       bool has_more = 2;
   }

   // GetTopTopics - most important topics
   message GetTopTopicsRequest {
       int32 limit = 1;
       int64 start_time_ms = 2;
       int64 end_time_ms = 3;
   }

   message GetTopTopicsResponse {
       repeated Topic topics = 1;
   }

   // GetRelatedTopics - similar/parent/child topics
   message GetRelatedTopicsRequest {
       string topic_id = 1;
       repeated TopicRelationshipType relationship_types = 2;
       int32 limit = 3;
   }

   message GetRelatedTopicsResponse {
       repeated RelatedTopic related = 1;
   }
   ```

2. Add RPCs to the MemoryService service definition:

   ```protobuf
   // Add to service MemoryService { ... }

   // Topic Graph RPCs
   rpc GetTopicGraphStatus(GetTopicGraphStatusRequest) returns (GetTopicGraphStatusResponse) {}
   rpc GetTopicsByQuery(GetTopicsByQueryRequest) returns (GetTopicsByQueryResponse) {}
   rpc GetTocNodesForTopic(GetTocNodesForTopicRequest) returns (GetTocNodesForTopicResponse) {}
   rpc GetTopTopics(GetTopTopicsRequest) returns (GetTopTopicsResponse) {}
   rpc GetRelatedTopics(GetRelatedTopicsRequest) returns (GetRelatedTopicsResponse) {}
   ```
  </action>
  <verify>
    cd /Users/richardhightower/clients/spillwave/src/agent-memory && cargo build -p memory-service
  </verify>
  <done>
    Proto definitions added. memory-service compiles with generated topic types.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement topic gRPC service</name>
  <files>
    crates/memory-service/src/topic_service.rs
    crates/memory-service/src/lib.rs
    crates/memory-service/Cargo.toml
  </files>
  <action>
Create the topic gRPC service implementation:

1. Add memory-topics dependency to `crates/memory-service/Cargo.toml`:
   ```toml
   # Add to [dependencies]
   memory-topics = { workspace = true, optional = true }

   # Add to [features]
   topics = ["dep:memory-topics"]
   ```

2. Create `crates/memory-service/src/topic_service.rs`:
   ```rust
   //! Topic gRPC service implementation.
   //!
   //! Provides topic navigation RPCs when topics feature is enabled.

   use std::sync::Arc;

   use tonic::{Request, Response, Status};
   use tracing::{debug, info, instrument};

   use crate::proto::{
       GetRelatedTopicsRequest, GetRelatedTopicsResponse, GetTocNodesForTopicRequest,
       GetTocNodesForTopicResponse, GetTopTopicsRequest, GetTopTopicsResponse,
       GetTopicGraphStatusRequest, GetTopicGraphStatusResponse, GetTopicsByQueryRequest,
       GetTopicsByQueryResponse, RelatedTopic, Topic as ProtoTopic, TopicNodeLink,
       TopicRelationshipType,
   };

   #[cfg(feature = "topics")]
   use memory_topics::{
       similarity::cosine_similarity, RelationshipType, Topic, TopicStats, TopicStorage,
   };

   /// Topic service state.
   pub struct TopicServiceState {
       #[cfg(feature = "topics")]
       storage: Option<Arc<TopicStorage>>,
       #[cfg(feature = "topics")]
       config: memory_topics::TopicsConfig,
       enabled: bool,
   }

   impl TopicServiceState {
       /// Create disabled state (feature not enabled).
       pub fn disabled() -> Self {
           Self {
               #[cfg(feature = "topics")]
               storage: None,
               #[cfg(feature = "topics")]
               config: memory_topics::TopicsConfig::default(),
               enabled: false,
           }
       }

       #[cfg(feature = "topics")]
       /// Create enabled state with storage.
       pub fn enabled(storage: Arc<TopicStorage>, config: memory_topics::TopicsConfig) -> Self {
           Self {
               storage: Some(storage),
               config,
               enabled: true,
           }
       }

       /// Check if topics are enabled.
       pub fn is_enabled(&self) -> bool {
           self.enabled
       }
   }

   /// Topic gRPC service handlers.
   pub struct TopicGrpcService {
       state: Arc<TopicServiceState>,
   }

   impl TopicGrpcService {
       /// Create a new topic gRPC service.
       pub fn new(state: Arc<TopicServiceState>) -> Self {
           Self { state }
       }

       /// Check if enabled, return UNAVAILABLE if not.
       fn check_enabled(&self) -> Result<(), Status> {
           if !self.state.is_enabled() {
               return Err(Status::unavailable("Topic graph is disabled"));
           }
           Ok(())
       }

       /// Get topic graph status.
       #[instrument(skip(self))]
       pub async fn get_topic_graph_status(
           &self,
           _request: Request<GetTopicGraphStatusRequest>,
       ) -> Result<Response<GetTopicGraphStatusResponse>, Status> {
           #[cfg(feature = "topics")]
           {
               let (topic_count, link_count, last_extraction_ms) =
                   if let Some(ref storage) = self.state.storage {
                       let stats = storage.get_stats().unwrap_or_default();
                       (stats.topic_count, stats.link_count, stats.last_extraction_ms)
                   } else {
                       (0, 0, 0)
                   };

               let healthy = self.state.enabled && topic_count > 0;

               Ok(Response::new(GetTopicGraphStatusResponse {
                   enabled: self.state.enabled,
                   healthy,
                   topic_count: topic_count as i64,
                   link_count: link_count as i64,
                   last_extraction_ms,
                   message: if self.state.enabled {
                       format!("{} topics indexed", topic_count)
                   } else {
                       "Topic graph is disabled".to_string()
                   },
                   half_life_days: self.state.config.importance.half_life_days as i32,
                   similarity_threshold: self.state.config.extraction.similarity_threshold,
               }))
           }

           #[cfg(not(feature = "topics"))]
           {
               Ok(Response::new(GetTopicGraphStatusResponse {
                   enabled: false,
                   healthy: false,
                   topic_count: 0,
                   link_count: 0,
                   last_extraction_ms: 0,
                   message: "Topic graph feature not compiled".to_string(),
                   half_life_days: 30,
                   similarity_threshold: 0.75,
               }))
           }
       }

       /// Find topics by query.
       #[instrument(skip(self), fields(query = %request.get_ref().query))]
       pub async fn get_topics_by_query(
           &self,
           request: Request<GetTopicsByQueryRequest>,
       ) -> Result<Response<GetTopicsByQueryResponse>, Status> {
           self.check_enabled()?;

           #[cfg(feature = "topics")]
           {
               let req = request.into_inner();
               let limit = req.limit.max(1).min(100) as usize;
               let min_score = req.min_score.max(0.0);

               let storage = self
                   .state
                   .storage
                   .as_ref()
                   .ok_or_else(|| Status::internal("Storage not initialized"))?;

               // Get all topics and score against query
               // In production, this would use Phase 12 embeddings for semantic search
               let topics = storage
                   .list_topics()
                   .map_err(|e| Status::internal(e.to_string()))?;

               // Simple keyword matching for now
               let query_lower = req.query.to_lowercase();
               let query_words: Vec<&str> = query_lower.split_whitespace().collect();

               let mut scored: Vec<(Topic, f32)> = topics
                   .into_iter()
                   .filter_map(|topic| {
                       let score = calculate_query_score(&topic, &query_words);
                       if score >= min_score {
                           Some((topic, score))
                       } else {
                           None
                       }
                   })
                   .collect();

               // Sort by score descending
               scored.sort_by(|a, b| b.1.partial_cmp(&a.1).unwrap_or(std::cmp::Ordering::Equal));
               scored.truncate(limit);

               let (topics, scores): (Vec<_>, Vec<_>) = scored.into_iter().unzip();

               Ok(Response::new(GetTopicsByQueryResponse {
                   topics: topics.into_iter().map(topic_to_proto).collect(),
                   scores,
               }))
           }

           #[cfg(not(feature = "topics"))]
           {
               Err(Status::unavailable("Topic graph feature not compiled"))
           }
       }

       /// Get TOC nodes for a topic.
       #[instrument(skip(self), fields(topic_id = %request.get_ref().topic_id))]
       pub async fn get_toc_nodes_for_topic(
           &self,
           request: Request<GetTocNodesForTopicRequest>,
       ) -> Result<Response<GetTocNodesForTopicResponse>, Status> {
           self.check_enabled()?;

           #[cfg(feature = "topics")]
           {
               let req = request.into_inner();
               let limit = req.limit.max(1).min(100) as usize;
               let min_relevance = req.min_relevance.max(0.0);

               let storage = self
                   .state
                   .storage
                   .as_ref()
                   .ok_or_else(|| Status::internal("Storage not initialized"))?;

               let links = storage
                   .get_links_for_topic(&req.topic_id)
                   .map_err(|e| Status::internal(e.to_string()))?;

               let nodes: Vec<TopicNodeLink> = links
                   .into_iter()
                   .filter(|l| l.relevance >= min_relevance)
                   .take(limit + 1) // +1 to detect has_more
                   .map(|link| TopicNodeLink {
                       node_id: link.node_id,
                       title: String::new(), // Would be populated from TOC storage
                       level: 0,             // Would be parsed from node_id
                       relevance: link.relevance,
                       timestamp_ms: link.created_at.timestamp_millis(),
                   })
                   .collect();

               let has_more = nodes.len() > limit;
               let nodes: Vec<_> = nodes.into_iter().take(limit).collect();

               Ok(Response::new(GetTocNodesForTopicResponse { nodes, has_more }))
           }

           #[cfg(not(feature = "topics"))]
           {
               Err(Status::unavailable("Topic graph feature not compiled"))
           }
       }

       /// Get top topics by importance.
       #[instrument(skip(self))]
       pub async fn get_top_topics(
           &self,
           request: Request<GetTopTopicsRequest>,
       ) -> Result<Response<GetTopTopicsResponse>, Status> {
           self.check_enabled()?;

           #[cfg(feature = "topics")]
           {
               let req = request.into_inner();
               let limit = req.limit.max(1).min(100) as usize;

               let storage = self
                   .state
                   .storage
                   .as_ref()
                   .ok_or_else(|| Status::internal("Storage not initialized"))?;

               let topics = storage
                   .list_topics_by_importance(limit)
                   .map_err(|e| Status::internal(e.to_string()))?;

               // TODO: Filter by time range if start/end provided

               Ok(Response::new(GetTopTopicsResponse {
                   topics: topics.into_iter().map(topic_to_proto).collect(),
               }))
           }

           #[cfg(not(feature = "topics"))]
           {
               Err(Status::unavailable("Topic graph feature not compiled"))
           }
       }

       /// Get related topics.
       #[instrument(skip(self), fields(topic_id = %request.get_ref().topic_id))]
       pub async fn get_related_topics(
           &self,
           request: Request<GetRelatedTopicsRequest>,
       ) -> Result<Response<GetRelatedTopicsResponse>, Status> {
           self.check_enabled()?;

           #[cfg(feature = "topics")]
           {
               let req = request.into_inner();
               let limit = req.limit.max(1).min(100) as usize;

               let storage = self
                   .state
                   .storage
                   .as_ref()
                   .ok_or_else(|| Status::internal("Storage not initialized"))?;

               // Convert proto relationship types
               let rel_types: Vec<RelationshipType> = req
                   .relationship_types
                   .iter()
                   .filter_map(|&t| match t {
                       1 => Some(RelationshipType::Similar),
                       2 => Some(RelationshipType::Parent),
                       3 => Some(RelationshipType::Child),
                       _ => None,
                   })
                   .collect();

               let mut related = Vec::new();

               // Get relationships for each requested type
               for rel_type in &rel_types {
                   let rels = storage
                       .get_relationships(&req.topic_id, Some(*rel_type))
                       .map_err(|e| Status::internal(e.to_string()))?;

                   for rel in rels {
                       if let Some(topic) = storage
                           .get_topic(&rel.to_topic_id)
                           .map_err(|e| Status::internal(e.to_string()))?
                       {
                           related.push(RelatedTopic {
                               topic: Some(topic_to_proto(topic)),
                               relationship_type: rel_type_to_proto(rel.relationship_type),
                               score: rel.score,
                           });
                       }
                   }
               }

               // Sort by score descending and limit
               related.sort_by(|a, b| {
                   b.score
                       .partial_cmp(&a.score)
                       .unwrap_or(std::cmp::Ordering::Equal)
               });
               related.truncate(limit);

               Ok(Response::new(GetRelatedTopicsResponse { related }))
           }

           #[cfg(not(feature = "topics"))]
           {
               Err(Status::unavailable("Topic graph feature not compiled"))
           }
       }
   }

   // ============ Helper Functions ============

   #[cfg(feature = "topics")]
   fn topic_to_proto(topic: Topic) -> ProtoTopic {
       ProtoTopic {
           topic_id: topic.topic_id,
           label: topic.label,
           importance_score: topic.importance_score,
           node_count: topic.node_count as i32,
           created_at_ms: topic.created_at.timestamp_millis(),
           last_mentioned_at_ms: topic.last_mentioned_at.timestamp_millis(),
           keywords: topic.keywords,
       }
   }

   #[cfg(feature = "topics")]
   fn rel_type_to_proto(rel_type: RelationshipType) -> i32 {
       match rel_type {
           RelationshipType::Similar => TopicRelationshipType::Similar as i32,
           RelationshipType::Parent => TopicRelationshipType::Parent as i32,
           RelationshipType::Child => TopicRelationshipType::Child as i32,
       }
   }

   #[cfg(feature = "topics")]
   fn calculate_query_score(topic: &Topic, query_words: &[&str]) -> f32 {
       // Simple keyword matching score
       let label_lower = topic.label.to_lowercase();
       let keywords_lower: Vec<String> = topic.keywords.iter().map(|k| k.to_lowercase()).collect();

       let mut score = 0.0f32;

       for word in query_words {
           // Label match is worth more
           if label_lower.contains(word) {
               score += 1.0;
           }
           // Keyword match
           if keywords_lower.iter().any(|k| k.contains(word)) {
               score += 0.5;
           }
       }

       // Normalize by query length
       if !query_words.is_empty() {
           score /= query_words.len() as f32;
       }

       score
   }

   #[cfg(test)]
   mod tests {
       use super::*;

       #[test]
       fn test_topic_service_state_disabled() {
           let state = TopicServiceState::disabled();
           assert!(!state.is_enabled());
       }

       #[cfg(feature = "topics")]
       #[test]
       fn test_calculate_query_score() {
           use chrono::Utc;
           use memory_topics::types::TopicStatus;

           let topic = Topic {
               topic_id: "t1".to_string(),
               label: "Authentication Security".to_string(),
               embedding: vec![],
               importance_score: 1.0,
               node_count: 1,
               created_at: Utc::now(),
               last_mentioned_at: Utc::now(),
               status: TopicStatus::Active,
               keywords: vec!["auth".to_string(), "jwt".to_string(), "login".to_string()],
           };

           let score = calculate_query_score(&topic, &["authentication"]);
           assert!(score > 0.0); // Should match label

           let score2 = calculate_query_score(&topic, &["jwt"]);
           assert!(score2 > 0.0); // Should match keyword

           let score3 = calculate_query_score(&topic, &["database"]);
           assert!((score3 - 0.0).abs() < f32::EPSILON); // No match
       }
   }
   ```

3. Update `crates/memory-service/src/lib.rs` to export topic service:
   ```rust
   // Add to existing exports:
   pub mod topic_service;
   pub use topic_service::{TopicGrpcService, TopicServiceState};
   ```

4. Wire topic service into MemoryServiceImpl (in the existing service implementation):
   ```rust
   // In MemoryServiceImpl, add field:
   topic_service: Option<TopicGrpcService>,

   // In handler implementations, delegate to topic_service:
   async fn get_topic_graph_status(&self, request: Request<GetTopicGraphStatusRequest>) -> ... {
       if let Some(ref svc) = self.topic_service {
           svc.get_topic_graph_status(request).await
       } else {
           // Return disabled status
           Ok(Response::new(GetTopicGraphStatusResponse {
               enabled: false,
               healthy: false,
               ...
           }))
       }
   }
   ```
  </action>
  <verify>
    cd /Users/richardhightower/clients/spillwave/src/agent-memory && cargo build -p memory-service --features topics
  </verify>
  <done>
    Topic gRPC service implemented. 5 RPCs: GetTopicGraphStatus, GetTopicsByQuery, GetTocNodesForTopic, GetTopTopics, GetRelatedTopics. Feature-gated with "topics".
  </done>
</task>

</tasks>

<verification>
```bash
cd /Users/richardhightower/clients/spillwave/src/agent-memory

# Proto compiles
cargo build -p memory-service

# With topics feature
cargo build -p memory-service --features topics

# Tests pass
cargo test -p memory-service topic

# Clippy clean
cargo clippy -p memory-service --features topics -- -D warnings
```
</verification>

<success_criteria>
- [ ] Proto definitions added for Topic, RelatedTopic, TopicNodeLink messages
- [ ] 5 RPCs defined in proto: GetTopicGraphStatus, GetTopicsByQuery, GetTocNodesForTopic, GetTopTopics, GetRelatedTopics
- [ ] TopicGrpcService implements all handlers
- [ ] GetTopicGraphStatus returns enabled/healthy status
- [ ] GetTopicsByQuery performs keyword matching (semantic search in future)
- [ ] GetTocNodesForTopic returns linked nodes
- [ ] GetTopTopics returns by importance
- [ ] GetRelatedTopics filters by relationship type
- [ ] RPCs return UNAVAILABLE when topics disabled
- [ ] Feature-gated behind "topics" feature
- [ ] All tests pass
- [ ] No clippy warnings
</success_criteria>

<output>
After completion, create `.planning/phases/14-topic-graph-memory/14-05-SUMMARY.md`
</output>
