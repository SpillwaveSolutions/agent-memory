---
phase: 14-topic-graph-memory
plan: 03
type: execute
wave: 3
depends_on: ["14-01"]
files_modified:
  - crates/memory-topics/src/importance.rs
  - crates/memory-topics/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "Topic importance decays exponentially over time with configurable half-life"
    - "Recent mentions (within 7 days) receive a recency boost"
    - "Importance scores are recalculated during extraction job"
    - "Topics can be ranked by importance for discovery"
    - "Importance formula: sum of decay * weight for each mention"
  artifacts:
    - path: "crates/memory-topics/src/importance.rs"
      provides: "Time-decayed importance scoring"
      exports: ["calculate_importance", "ImportanceCalculator", "recalculate_all_importance"]
  key_links:
    - from: "crates/memory-topics/src/importance.rs"
      to: "chrono"
      via: "timestamp arithmetic"
      pattern: "DateTime::.*now|num_seconds"
    - from: "crates/memory-topics/src/importance.rs"
      to: "crates/memory-topics/src/config.rs"
      via: "ImportanceConfig for half-life and boost"
      pattern: "ImportanceConfig"
---

<objective>
Implement time-decayed importance scoring for topics.

Purpose: Surface recently relevant topics while allowing older topics to fade. This enables agents to discover "what's important now" rather than just "what exists". The exponential decay with recency boost prioritizes fresh activity while respecting historical patterns.

Output: ImportanceCalculator with configurable half-life, recency boost, and batch recalculation.
</objective>

<execution_context>
@/Users/richardhightower/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardhightower/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/14-topic-graph-memory/14-RESEARCH.md
@.planning/phases/14-topic-graph-memory/14-01-SUMMARY.md
@crates/memory-topics/src/config.rs
@crates/memory-topics/src/types.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement time-decayed importance scoring</name>
  <files>
    crates/memory-topics/src/importance.rs
    crates/memory-topics/src/lib.rs
  </files>
  <action>
Create importance scoring with time decay:

1. Create `crates/memory-topics/src/importance.rs`:
   ```rust
   //! Time-decayed importance scoring for topics.
   //!
   //! Topics decay in importance over time using exponential decay.
   //! Formula: importance = sum(weight * 0.5^(age_days / half_life_days))
   //!
   //! Recent mentions (within 7 days) receive a configurable boost.

   use chrono::{DateTime, Duration, Utc};
   use tracing::{debug, info};

   use crate::config::ImportanceConfig;
   use crate::error::TopicsError;
   use crate::storage::TopicStorage;
   use crate::types::Topic;

   /// Default recency window (days) for boost application.
   pub const RECENCY_WINDOW_DAYS: i64 = 7;

   /// Calculate time-decayed importance score for a topic.
   ///
   /// # Arguments
   /// * `mention_timestamps` - Timestamps of each mention/occurrence
   /// * `now` - Current time for decay calculation
   /// * `config` - Importance configuration (half-life, recency boost)
   ///
   /// # Returns
   /// Importance score (sum of decayed weights)
   ///
   /// # Formula
   /// For each mention:
   ///   weight = recency_boost if within 7 days, else 1.0
   ///   decay = 0.5^(age_seconds / half_life_seconds)
   ///   contribution = weight * decay
   ///
   /// Total importance = sum of all contributions
   pub fn calculate_importance(
       mention_timestamps: &[DateTime<Utc>],
       now: DateTime<Utc>,
       config: &ImportanceConfig,
   ) -> f64 {
       if mention_timestamps.is_empty() {
           return 0.0;
       }

       let half_life_secs = (config.half_life_days as f64) * 24.0 * 3600.0;
       let recency_threshold = now - Duration::days(RECENCY_WINDOW_DAYS);

       mention_timestamps
           .iter()
           .map(|ts| {
               let age_secs = (now - *ts).num_seconds().max(0) as f64;
               let days_ago = age_secs / (24.0 * 3600.0);

               // Apply recency boost for recent mentions
               let weight = if *ts >= recency_threshold {
                   config.recency_boost
               } else {
                   1.0
               };

               // Apply exponential decay
               let decay = 0.5_f64.powf(age_secs / half_life_secs);

               weight * decay
           })
           .sum()
   }

   /// Calculate importance from a single timestamp (for new topics).
   pub fn importance_from_single(timestamp: DateTime<Utc>, now: DateTime<Utc>, config: &ImportanceConfig) -> f64 {
       calculate_importance(&[timestamp], now, config)
   }

   /// Importance calculator for batch operations.
   pub struct ImportanceCalculator {
       config: ImportanceConfig,
   }

   impl ImportanceCalculator {
       /// Create a new importance calculator.
       pub fn new(config: ImportanceConfig) -> Self {
           Self { config }
       }

       /// Get the current configuration.
       pub fn config(&self) -> &ImportanceConfig {
           &self.config
       }

       /// Calculate importance for a topic based on its link timestamps.
       ///
       /// This considers each linked node as a "mention" of the topic.
       pub fn calculate_for_topic(
           &self,
           topic: &Topic,
           link_timestamps: &[DateTime<Utc>],
       ) -> f64 {
           let now = Utc::now();

           // Combine topic creation and link timestamps
           let mut timestamps = vec![topic.created_at, topic.last_mentioned_at];
           timestamps.extend(link_timestamps.iter().copied());

           calculate_importance(&timestamps, now, &self.config)
       }

       /// Update importance score for a topic in place.
       pub fn update_topic_importance(
           &self,
           topic: &mut Topic,
           link_timestamps: &[DateTime<Utc>],
       ) {
           topic.importance_score = self.calculate_for_topic(topic, link_timestamps);
       }

       /// Recalculate importance for all topics in storage.
       ///
       /// This should be called periodically (e.g., during extraction job).
       pub async fn recalculate_all(
           &self,
           storage: &TopicStorage,
       ) -> Result<usize, TopicsError> {
           let now = Utc::now();
           let mut topics = storage.list_topics()?;
           let mut updated_count = 0;

           info!(count = topics.len(), "Recalculating importance scores");

           for topic in &mut topics {
               // Get link timestamps for this topic
               let links = storage.get_links_for_topic(&topic.topic_id)?;
               let timestamps: Vec<DateTime<Utc>> = links.iter().map(|l| l.created_at).collect();

               // Calculate new importance
               let new_importance = calculate_importance(&timestamps, now, &self.config);

               // Only update if changed significantly (avoid unnecessary writes)
               if (new_importance - topic.importance_score).abs() > 0.001 {
                   topic.importance_score = new_importance;
                   storage.save_topic(topic)?;
                   updated_count += 1;
               }
           }

           info!(
               total = topics.len(),
               updated = updated_count,
               "Importance recalculation complete"
           );

           Ok(updated_count)
       }

       /// Get decay factor for a given age.
       ///
       /// Useful for understanding decay behavior.
       pub fn decay_factor(&self, days_ago: f64) -> f64 {
           let half_life_days = self.config.half_life_days as f64;
           0.5_f64.powf(days_ago / half_life_days)
       }
   }

   /// Rank topics by importance (descending).
   pub fn rank_by_importance(topics: &mut [Topic]) {
       topics.sort_by(|a, b| {
           b.importance_score
               .partial_cmp(&a.importance_score)
               .unwrap_or(std::cmp::Ordering::Equal)
       });
   }

   #[cfg(test)]
   mod tests {
       use super::*;
       use chrono::Duration;

       fn default_config() -> ImportanceConfig {
           ImportanceConfig {
               half_life_days: 30,
               recency_boost: 2.0,
           }
       }

       #[test]
       fn test_calculate_importance_empty() {
           let config = default_config();
           let importance = calculate_importance(&[], Utc::now(), &config);
           assert!((importance - 0.0).abs() < f64::EPSILON);
       }

       #[test]
       fn test_calculate_importance_single_now() {
           let config = default_config();
           let now = Utc::now();
           let importance = calculate_importance(&[now], now, &config);

           // Recent mention with boost: 2.0 * 1.0 (no decay) = 2.0
           assert!((importance - 2.0).abs() < 0.01);
       }

       #[test]
       fn test_calculate_importance_single_half_life_ago() {
           let config = default_config();
           let now = Utc::now();
           let half_life_ago = now - Duration::days(30);
           let importance = calculate_importance(&[half_life_ago], now, &config);

           // 30 days ago (past recency window): 1.0 * 0.5 = 0.5
           assert!((importance - 0.5).abs() < 0.01);
       }

       #[test]
       fn test_calculate_importance_with_recency_boost() {
           let config = default_config();
           let now = Utc::now();
           let three_days_ago = now - Duration::days(3);
           let importance = calculate_importance(&[three_days_ago], now, &config);

           // Within recency window (7 days): gets 2.0 boost
           // Decay after 3 days: 0.5^(3/30) ≈ 0.933
           // Expected: 2.0 * 0.933 ≈ 1.866
           assert!(importance > 1.5);
           assert!(importance < 2.0);
       }

       #[test]
       fn test_calculate_importance_multiple_mentions() {
           let config = default_config();
           let now = Utc::now();
           let mentions = vec![
               now - Duration::days(1),  // Recent, boosted
               now - Duration::days(10), // Not recent
               now - Duration::days(30), // Half-life ago
           ];

           let importance = calculate_importance(&mentions, now, &config);

           // Should be sum of three contributions
           // Day 1 (boosted): ~2.0 * 0.977 ≈ 1.95
           // Day 10: ~1.0 * 0.794 ≈ 0.79
           // Day 30: ~1.0 * 0.5 = 0.5
           // Total ≈ 3.24
           assert!(importance > 3.0);
           assert!(importance < 4.0);
       }

       #[test]
       fn test_decay_factor() {
           let config = default_config();
           let calc = ImportanceCalculator::new(config);

           // At 0 days: 1.0
           assert!((calc.decay_factor(0.0) - 1.0).abs() < 0.001);

           // At half-life (30 days): 0.5
           assert!((calc.decay_factor(30.0) - 0.5).abs() < 0.001);

           // At 2x half-life (60 days): 0.25
           assert!((calc.decay_factor(60.0) - 0.25).abs() < 0.001);

           // At 3x half-life (90 days): 0.125
           assert!((calc.decay_factor(90.0) - 0.125).abs() < 0.001);
       }

       #[test]
       fn test_rank_by_importance() {
           let mut topics = vec![
               Topic {
                   topic_id: "t1".to_string(),
                   label: "Low".to_string(),
                   embedding: vec![],
                   importance_score: 0.5,
                   node_count: 1,
                   created_at: Utc::now(),
                   last_mentioned_at: Utc::now(),
                   status: crate::types::TopicStatus::Active,
                   keywords: vec![],
               },
               Topic {
                   topic_id: "t2".to_string(),
                   label: "High".to_string(),
                   embedding: vec![],
                   importance_score: 2.0,
                   node_count: 1,
                   created_at: Utc::now(),
                   last_mentioned_at: Utc::now(),
                   status: crate::types::TopicStatus::Active,
                   keywords: vec![],
               },
               Topic {
                   topic_id: "t3".to_string(),
                   label: "Medium".to_string(),
                   embedding: vec![],
                   importance_score: 1.0,
                   node_count: 1,
                   created_at: Utc::now(),
                   last_mentioned_at: Utc::now(),
                   status: crate::types::TopicStatus::Active,
                   keywords: vec![],
               },
           ];

           rank_by_importance(&mut topics);

           assert_eq!(topics[0].topic_id, "t2"); // Highest
           assert_eq!(topics[1].topic_id, "t3"); // Medium
           assert_eq!(topics[2].topic_id, "t1"); // Lowest
       }

       #[test]
       fn test_importance_calculator_update_topic() {
           let config = default_config();
           let calc = ImportanceCalculator::new(config);
           let now = Utc::now();

           let mut topic = Topic::new(
               "test".to_string(),
               "Test Topic".to_string(),
               vec![0.1, 0.2],
           );
           topic.importance_score = 0.0;

           let links = vec![
               now - Duration::days(1),
               now - Duration::days(5),
           ];

           calc.update_topic_importance(&mut topic, &links);

           // Should have non-zero importance now
           assert!(topic.importance_score > 0.0);
       }
   }
   ```

2. Update `crates/memory-topics/src/lib.rs` to export importance module:
   ```rust
   // Add to existing exports:
   pub mod importance;
   pub use importance::{calculate_importance, ImportanceCalculator, rank_by_importance};
   ```
  </action>
  <verify>
    cd /Users/richardhightower/clients/spillwave/src/agent-memory && cargo test -p memory-topics importance
  </verify>
  <done>
    calculate_importance with exponential decay. ImportanceCalculator for batch operations. recalculate_all for storage updates. rank_by_importance for sorting. All tests pass.
  </done>
</task>

</tasks>

<verification>
```bash
cd /Users/richardhightower/clients/spillwave/src/agent-memory

# Crate compiles
cargo build -p memory-topics

# All importance tests pass
cargo test -p memory-topics importance

# Verify decay math
cargo test -p memory-topics test_decay_factor

# Clippy clean
cargo clippy -p memory-topics -- -D warnings
```
</verification>

<success_criteria>
- [ ] calculate_importance implements exponential decay formula
- [ ] Configurable half-life (default 30 days)
- [ ] Recency boost for mentions within 7 days
- [ ] ImportanceCalculator wraps config for reuse
- [ ] recalculate_all updates all topics in storage
- [ ] rank_by_importance sorts topics descending
- [ ] decay_factor utility for understanding decay behavior
- [ ] All tests verify math correctness
- [ ] No clippy warnings
</success_criteria>

<output>
After completion, create `.planning/phases/14-topic-graph-memory/14-03-SUMMARY.md`
</output>
