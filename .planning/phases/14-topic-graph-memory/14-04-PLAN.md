---
phase: 14-topic-graph-memory
plan: 04
type: execute
wave: 4
depends_on: ["14-01", "14-03"]
files_modified:
  - crates/memory-topics/src/relationships.rs
  - crates/memory-topics/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "Similar topics are detected using cosine similarity above threshold"
    - "Parent/child hierarchy inferred from label analysis"
    - "Relationships stored bidirectionally in CF_TOPIC_RELS"
    - "Cycle detection prevents infinite loops in hierarchy"
    - "Relationship scores reflect strength of connection"
  artifacts:
    - path: "crates/memory-topics/src/relationships.rs"
      provides: "Topic relationship detection and storage"
      exports: ["RelationshipDetector", "detect_similar_topics", "infer_hierarchy"]
  key_links:
    - from: "crates/memory-topics/src/relationships.rs"
      to: "crates/memory-topics/src/similarity.rs"
      via: "cosine similarity for topic comparison"
      pattern: "cosine_similarity"
    - from: "crates/memory-topics/src/relationships.rs"
      to: "crates/memory-topics/src/storage.rs"
      via: "saves relationships to CF_TOPIC_RELS"
      pattern: "save_relationship"
---

<objective>
Implement topic relationship detection (similar and parent/child hierarchy).

Purpose: Enable agents to explore conceptual connections between topics. "Security" relates to "Authentication" and "Encryption" as children. "API" relates to "REST" and "GraphQL" as similar topics. This creates a navigable topic graph.

Output: RelationshipDetector with similarity detection, hierarchy inference, and cycle prevention.
</objective>

<execution_context>
@/Users/richardhightower/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardhightower/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/14-topic-graph-memory/14-RESEARCH.md
@.planning/phases/14-topic-graph-memory/14-01-SUMMARY.md
@crates/memory-topics/src/config.rs
@crates/memory-topics/src/types.rs
@crates/memory-topics/src/similarity.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement similarity-based relationship detection</name>
  <files>
    crates/memory-topics/src/relationships.rs
    crates/memory-topics/src/lib.rs
  </files>
  <action>
Create relationship detection module:

1. Create `crates/memory-topics/src/relationships.rs`:
   ```rust
   //! Topic relationship detection.
   //!
   //! Detects similar topics and infers parent/child hierarchy.

   use std::collections::{HashMap, HashSet};

   use tracing::{debug, info, warn};

   use crate::config::RelationshipsConfig;
   use crate::error::TopicsError;
   use crate::similarity::cosine_similarity;
   use crate::storage::TopicStorage;
   use crate::types::{RelationshipType, Topic, TopicRelationship};

   /// Relationship detector for topic graph.
   pub struct RelationshipDetector {
       config: RelationshipsConfig,
   }

   impl RelationshipDetector {
       /// Create a new relationship detector.
       pub fn new(config: RelationshipsConfig) -> Self {
           Self { config }
       }

       /// Get configuration.
       pub fn config(&self) -> &RelationshipsConfig {
           &self.config
       }

       /// Detect similar topics based on embedding similarity.
       ///
       /// Returns pairs of topics with similarity above threshold.
       pub fn detect_similar(&self, topics: &[Topic]) -> Vec<TopicRelationship> {
           let mut relationships = Vec::new();
           let threshold = self.config.similar_threshold;

           info!(
               count = topics.len(),
               threshold = threshold,
               "Detecting similar topics"
           );

           // Compare all pairs
           for i in 0..topics.len() {
               for j in (i + 1)..topics.len() {
                   let sim = cosine_similarity(&topics[i].embedding, &topics[j].embedding);

                   if sim >= threshold {
                       debug!(
                           topic_a = %topics[i].topic_id,
                           topic_b = %topics[j].topic_id,
                           similarity = sim,
                           "Found similar topics"
                       );

                       // Create bidirectional relationships
                       relationships.push(TopicRelationship::new(
                           topics[i].topic_id.clone(),
                           topics[j].topic_id.clone(),
                           RelationshipType::Similar,
                           sim,
                       ));
                       relationships.push(TopicRelationship::new(
                           topics[j].topic_id.clone(),
                           topics[i].topic_id.clone(),
                           RelationshipType::Similar,
                           sim,
                       ));
                   }
               }
           }

           info!(count = relationships.len() / 2, "Similar pairs detected");
           relationships
       }

       /// Infer parent/child hierarchy from labels and keywords.
       ///
       /// Uses simple heuristics:
       /// - Shorter, more general labels are parents
       /// - Topics with subset keywords are children
       pub fn infer_hierarchy(&self, topics: &[Topic]) -> Vec<TopicRelationship> {
           if !self.config.enable_hierarchy {
               return Vec::new();
           }

           let mut relationships = Vec::new();
           let max_depth = self.config.max_hierarchy_depth;

           info!(count = topics.len(), "Inferring topic hierarchy");

           // Build label -> topic mapping
           let label_map: HashMap<String, &Topic> = topics
               .iter()
               .map(|t| (t.label.to_lowercase(), t))
               .collect();

           for topic in topics {
               // Check if this topic's keywords are a subset of another's
               if let Some(parent) = find_potential_parent(topic, topics, &label_map) {
                   // Check depth limit
                   let depth = count_ancestors(&parent.topic_id, topics, max_depth);
                   if depth < max_depth {
                       let score = calculate_hierarchy_score(topic, parent);

                       debug!(
                           child = %topic.topic_id,
                           parent = %parent.topic_id,
                           score = score,
                           "Inferred parent-child relationship"
                       );

                       relationships.push(TopicRelationship::new(
                           parent.topic_id.clone(),
                           topic.topic_id.clone(),
                           RelationshipType::Parent,
                           score,
                       ));
                       relationships.push(TopicRelationship::new(
                           topic.topic_id.clone(),
                           parent.topic_id.clone(),
                           RelationshipType::Child,
                           score,
                       ));
                   }
               }
           }

           info!(count = relationships.len() / 2, "Hierarchy relationships inferred");
           relationships
       }

       /// Detect all relationships and save to storage.
       pub fn detect_and_save(
           &self,
           storage: &TopicStorage,
           topics: &[Topic],
       ) -> Result<usize, TopicsError> {
           // Detect similar topics
           let similar = self.detect_similar(topics);

           // Infer hierarchy
           let hierarchy = self.infer_hierarchy(topics);

           // Combine and deduplicate
           let mut all_relationships = similar;
           all_relationships.extend(hierarchy);

           // Validate no cycles in hierarchy
           if let Err(e) = validate_no_cycles(&all_relationships) {
               warn!(error = %e, "Cycle detected in hierarchy, removing offending relationships");
               all_relationships.retain(|r| {
                   r.relationship_type == RelationshipType::Similar
               });
           }

           // Save to storage
           for rel in &all_relationships {
               storage.save_relationship(rel)?;
           }

           info!(
               total = all_relationships.len(),
               "Relationships saved to storage"
           );

           Ok(all_relationships.len())
       }
   }

   /// Find potential parent topic based on label/keyword analysis.
   fn find_potential_parent<'a>(
       topic: &Topic,
       topics: &'a [Topic],
       label_map: &HashMap<String, &'a Topic>,
   ) -> Option<&'a Topic> {
       let topic_keywords: HashSet<&str> = topic.keywords.iter().map(|s| s.as_str()).collect();

       // Strategy 1: Check if topic label is contained in another topic's label
       // e.g., "JWT Authentication" might be child of "Authentication"
       let topic_label_lower = topic.label.to_lowercase();
       for (label, candidate) in label_map {
           if candidate.topic_id == topic.topic_id {
               continue;
           }

           // Check if topic's label contains candidate's label
           if topic_label_lower.contains(label)
               && topic_label_lower.len() > label.len()
               && label.len() >= 3
           {
               return Some(candidate);
           }
       }

       // Strategy 2: Check keyword subset
       for candidate in topics {
           if candidate.topic_id == topic.topic_id {
               continue;
           }

           let candidate_keywords: HashSet<&str> =
               candidate.keywords.iter().map(|s| s.as_str()).collect();

           // If topic's keywords are a subset of candidate's, candidate might be parent
           // But only if candidate has fewer, more general keywords
           if !topic_keywords.is_empty()
               && candidate_keywords.len() < topic_keywords.len()
               && candidate_keywords.is_subset(&topic_keywords)
           {
               return Some(candidate);
           }
       }

       None
   }

   /// Count ancestors of a topic in the hierarchy.
   fn count_ancestors(topic_id: &str, topics: &[Topic], max_depth: usize) -> usize {
       // Simple implementation - in production would use relationship storage
       // For now, return 0 (no ancestors tracked yet)
       0
   }

   /// Calculate hierarchy score based on keyword/label overlap.
   fn calculate_hierarchy_score(child: &Topic, parent: &Topic) -> f32 {
       let child_keywords: HashSet<&str> = child.keywords.iter().map(|s| s.as_str()).collect();
       let parent_keywords: HashSet<&str> = parent.keywords.iter().map(|s| s.as_str()).collect();

       if child_keywords.is_empty() || parent_keywords.is_empty() {
           return 0.5; // Default score
       }

       let intersection = child_keywords.intersection(&parent_keywords).count();
       let union = child_keywords.union(&parent_keywords).count();

       if union == 0 {
           0.5
       } else {
           intersection as f32 / union as f32
       }
   }

   /// Validate that hierarchy relationships don't form cycles.
   fn validate_no_cycles(relationships: &[TopicRelationship]) -> Result<(), TopicsError> {
       // Build adjacency list for parent relationships only
       let mut children: HashMap<&str, Vec<&str>> = HashMap::new();

       for rel in relationships {
           if rel.relationship_type == RelationshipType::Parent {
               children
                   .entry(rel.from_topic_id.as_str())
                   .or_default()
                   .push(rel.to_topic_id.as_str());
           }
       }

       // DFS to detect cycles
       let mut visited = HashSet::new();
       let mut rec_stack = HashSet::new();

       for &node in children.keys() {
           if has_cycle_dfs(node, &children, &mut visited, &mut rec_stack) {
               return Err(TopicsError::CycleDetected);
           }
       }

       Ok(())
   }

   /// DFS helper for cycle detection.
   fn has_cycle_dfs<'a>(
       node: &'a str,
       children: &HashMap<&'a str, Vec<&'a str>>,
       visited: &mut HashSet<&'a str>,
       rec_stack: &mut HashSet<&'a str>,
   ) -> bool {
       if rec_stack.contains(node) {
           return true; // Cycle found
       }
       if visited.contains(node) {
           return false; // Already processed
       }

       visited.insert(node);
       rec_stack.insert(node);

       if let Some(child_nodes) = children.get(node) {
           for &child in child_nodes {
               if has_cycle_dfs(child, children, visited, rec_stack) {
                   return true;
               }
           }
       }

       rec_stack.remove(node);
       false
   }

   #[cfg(test)]
   mod tests {
       use super::*;
       use chrono::Utc;
       use crate::types::TopicStatus;

       fn make_topic(id: &str, label: &str, embedding: Vec<f32>, keywords: Vec<&str>) -> Topic {
           Topic {
               topic_id: id.to_string(),
               label: label.to_string(),
               embedding,
               importance_score: 1.0,
               node_count: 1,
               created_at: Utc::now(),
               last_mentioned_at: Utc::now(),
               status: TopicStatus::Active,
               keywords: keywords.into_iter().map(String::from).collect(),
           }
       }

       #[test]
       fn test_detect_similar_above_threshold() {
           let config = RelationshipsConfig {
               similar_threshold: 0.9,
               max_hierarchy_depth: 3,
               enable_hierarchy: false,
           };
           let detector = RelationshipDetector::new(config);

           // Very similar embeddings
           let topics = vec![
               make_topic("t1", "Topic A", vec![1.0, 0.0, 0.0], vec![]),
               make_topic("t2", "Topic B", vec![0.99, 0.1, 0.0], vec![]), // Very similar to t1
               make_topic("t3", "Topic C", vec![0.0, 1.0, 0.0], vec![]),  // Different
           ];

           let rels = detector.detect_similar(&topics);

           // Should find t1-t2 pair (bidirectional = 2 relationships)
           assert_eq!(rels.len(), 2);
           assert!(rels.iter().any(|r| r.from_topic_id == "t1" && r.to_topic_id == "t2"));
           assert!(rels.iter().any(|r| r.from_topic_id == "t2" && r.to_topic_id == "t1"));
       }

       #[test]
       fn test_detect_similar_below_threshold() {
           let config = RelationshipsConfig {
               similar_threshold: 0.95,
               max_hierarchy_depth: 3,
               enable_hierarchy: false,
           };
           let detector = RelationshipDetector::new(config);

           // Orthogonal embeddings
           let topics = vec![
               make_topic("t1", "Topic A", vec![1.0, 0.0], vec![]),
               make_topic("t2", "Topic B", vec![0.0, 1.0], vec![]),
           ];

           let rels = detector.detect_similar(&topics);
           assert!(rels.is_empty());
       }

       #[test]
       fn test_infer_hierarchy_label_containment() {
           let config = RelationshipsConfig {
               similar_threshold: 0.8,
               max_hierarchy_depth: 3,
               enable_hierarchy: true,
           };
           let detector = RelationshipDetector::new(config);

           let topics = vec![
               make_topic("t1", "Authentication", vec![1.0, 0.0], vec!["auth"]),
               make_topic("t2", "JWT Authentication", vec![0.9, 0.1], vec!["auth", "jwt"]),
           ];

           let rels = detector.infer_hierarchy(&topics);

           // t1 (Authentication) should be parent of t2 (JWT Authentication)
           assert!(!rels.is_empty());
           assert!(rels.iter().any(|r| {
               r.from_topic_id == "t1"
                   && r.to_topic_id == "t2"
                   && r.relationship_type == RelationshipType::Parent
           }));
       }

       #[test]
       fn test_infer_hierarchy_disabled() {
           let config = RelationshipsConfig {
               similar_threshold: 0.8,
               max_hierarchy_depth: 3,
               enable_hierarchy: false, // Disabled
           };
           let detector = RelationshipDetector::new(config);

           let topics = vec![
               make_topic("t1", "Auth", vec![1.0, 0.0], vec!["auth"]),
               make_topic("t2", "JWT Auth", vec![0.9, 0.1], vec!["auth", "jwt"]),
           ];

           let rels = detector.infer_hierarchy(&topics);
           assert!(rels.is_empty());
       }

       #[test]
       fn test_validate_no_cycles_clean() {
           let rels = vec![
               TopicRelationship::new("a".to_string(), "b".to_string(), RelationshipType::Parent, 1.0),
               TopicRelationship::new("b".to_string(), "c".to_string(), RelationshipType::Parent, 1.0),
           ];

           assert!(validate_no_cycles(&rels).is_ok());
       }

       #[test]
       fn test_validate_no_cycles_with_cycle() {
           let rels = vec![
               TopicRelationship::new("a".to_string(), "b".to_string(), RelationshipType::Parent, 1.0),
               TopicRelationship::new("b".to_string(), "c".to_string(), RelationshipType::Parent, 1.0),
               TopicRelationship::new("c".to_string(), "a".to_string(), RelationshipType::Parent, 1.0), // Cycle!
           ];

           assert!(validate_no_cycles(&rels).is_err());
       }

       #[test]
       fn test_calculate_hierarchy_score() {
           let child = make_topic("c", "Child", vec![], vec!["auth", "jwt", "security"]);
           let parent = make_topic("p", "Parent", vec![], vec!["auth", "security"]);

           let score = calculate_hierarchy_score(&child, &parent);

           // Intersection: {auth, security} = 2
           // Union: {auth, jwt, security} = 3
           // Score: 2/3 â‰ˆ 0.667
           assert!(score > 0.6);
           assert!(score < 0.7);
       }
   }
   ```

2. Update `crates/memory-topics/src/lib.rs` to export relationships module:
   ```rust
   // Add to existing exports:
   pub mod relationships;
   pub use relationships::RelationshipDetector;
   ```
  </action>
  <verify>
    cd /Users/richardhightower/clients/spillwave/src/agent-memory && cargo test -p memory-topics relationships
  </verify>
  <done>
    RelationshipDetector with similarity detection. Hierarchy inference from labels/keywords. Cycle detection prevents invalid graphs. All tests pass.
  </done>
</task>

</tasks>

<verification>
```bash
cd /Users/richardhightower/clients/spillwave/src/agent-memory

# Crate compiles
cargo build -p memory-topics

# All relationship tests pass
cargo test -p memory-topics relationships

# Verify cycle detection works
cargo test -p memory-topics test_validate_no_cycles

# Clippy clean
cargo clippy -p memory-topics -- -D warnings
```
</verification>

<success_criteria>
- [ ] detect_similar finds topics above similarity threshold
- [ ] Bidirectional relationships created for similar pairs
- [ ] infer_hierarchy detects parent/child from label containment
- [ ] Keyword subset analysis for hierarchy inference
- [ ] validate_no_cycles prevents circular relationships
- [ ] Configurable similarity threshold and max hierarchy depth
- [ ] enable_hierarchy flag controls hierarchy detection
- [ ] detect_and_save combines detection and storage
- [ ] All tests pass
- [ ] No clippy warnings
</success_criteria>

<output>
After completion, create `.planning/phases/14-topic-graph-memory/14-04-SUMMARY.md`
</output>
