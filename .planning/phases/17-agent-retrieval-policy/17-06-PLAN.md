---
phase: 17-agent-retrieval-policy
plan: 06
type: execute
wave: 4
depends_on: ["17-03", "17-05"]
files_modified:
  - crates/memory-service/src/retrieval_service.rs
  - crates/memory-service/src/lib.rs
  - crates/memory-daemon/src/cli.rs
  - crates/memory-daemon/src/commands.rs
  - proto/memory.proto
autonomous: true

must_haves:
  truths:
    - "GetRetrievalCapabilities RPC returns current tier, layer status, and recommendations"
    - "CLI `retrieval status` command shows human-readable tier and layer info"
    - "CLI `retrieval classify` command classifies a query intent"
    - "Service integrates with existing memory-service handlers"
  artifacts:
    - path: "crates/memory-service/src/retrieval_service.rs"
      provides: "gRPC handler for retrieval policy RPCs"
      exports: ["RetrievalHandler", "handle_get_retrieval_capabilities"]
    - path: "crates/memory-daemon/src/commands.rs"
      provides: "CLI commands for retrieval policy"
      contains: "retrieval status"
  key_links:
    - from: "crates/memory-service/src/lib.rs"
      to: "crates/memory-service/src/retrieval_service.rs"
      via: "pub mod retrieval_service"
      pattern: "pub mod retrieval_service"
---

<objective>
Implement gRPC service and CLI commands for the retrieval policy.

Purpose: Per PRD FR-01 through FR-03, skills need an RPC to check current capabilities. This plan implements the GetRetrievalCapabilities RPC and CLI commands for debugging and validation. The service integrates with existing vector, BM25, and topics status handlers.

Output: RetrievalHandler in memory-service providing GetRetrievalCapabilities RPC; CLI commands `retrieval status` and `retrieval classify`.
</objective>

<execution_context>
@/Users/richardhightower/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardhightower/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-agent-retrieval-policy/17-03-SUMMARY.md
@.planning/phases/17-agent-retrieval-policy/17-05-SUMMARY.md

# Technical reference
@docs/prds/agent-retrieval-policy-prd.md
@crates/memory-service/src/vector.rs
@crates/memory-service/src/topics.rs
@crates/memory-service/src/lib.rs
@crates/memory-daemon/src/cli.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create retrieval service handler</name>
  <files>crates/memory-service/src/retrieval_service.rs, crates/memory-service/src/lib.rs</files>
  <action>
Create `crates/memory-service/src/retrieval_service.rs`:

```rust
//! Retrieval policy gRPC handlers.
//!
//! Implements FR-01 (combined status check), FR-02 (tier detection),
//! and FR-03 (capability advertisement).

use std::sync::Arc;

use memory_retrieval::{
    detect_tier, classify_intent, layer_order_for_intent,
    CombinedStatus, TierDetector,
};
use memory_types::retrieval::{CapabilityTier, ExecutionMode, LayerStatus, QueryIntent};
use tonic::{Request, Response, Status};
use tracing::{debug, info};

use crate::pb::{
    CombinedLayerStatus, GetRetrievalCapabilitiesRequest, GetRetrievalCapabilitiesResponse,
    LayerStatus as ProtoLayerStatus,
    CapabilityTier as ProtoCapabilityTier,
    ExecutionMode as ProtoExecutionMode,
    QueryIntent as ProtoQueryIntent,
};

/// Handler for retrieval policy operations.
pub struct RetrievalHandler {
    /// Tier detector for capability assessment
    tier_detector: TierDetector,
    /// Optional: cached status (refreshed periodically)
    cached_status: Option<CombinedStatus>,
}

impl RetrievalHandler {
    /// Create a new retrieval handler.
    pub fn new() -> Self {
        Self {
            tier_detector: TierDetector::new(),
            cached_status: None,
        }
    }

    /// Update cached status.
    pub fn update_cache(&mut self, status: CombinedStatus) {
        self.cached_status = Some(status);
    }

    /// Get capabilities by querying actual layer status.
    ///
    /// This is the main implementation of FR-01, FR-02, FR-03.
    pub fn detect_capabilities(
        &self,
        bm25_status: LayerStatus,
        vector_status: LayerStatus,
        topics_status: LayerStatus,
    ) -> CombinedStatus {
        self.tier_detector.detect(bm25_status, vector_status, topics_status)
    }
}

impl Default for RetrievalHandler {
    fn default() -> Self {
        Self::new()
    }
}

/// Handle GetRetrievalCapabilities RPC.
///
/// Combines status from all layers and returns current tier + recommendations.
pub async fn handle_get_retrieval_capabilities(
    handler: &RetrievalHandler,
    bm25_status: LayerStatus,
    vector_status: LayerStatus,
    topics_status: LayerStatus,
    request: Request<GetRetrievalCapabilitiesRequest>,
) -> Result<Response<GetRetrievalCapabilitiesResponse>, Status> {
    let req = request.into_inner();

    debug!(force_refresh = req.force_refresh, "GetRetrievalCapabilities request");

    // Detect capabilities
    let status = handler.detect_capabilities(bm25_status, vector_status, topics_status);

    info!(
        tier = ?status.tier,
        bm25_ready = status.bm25_ready(),
        vector_ready = status.vector_ready(),
        topics_ready = status.topics_ready(),
        "Retrieval capabilities detected"
    );

    // Convert to proto types
    let proto_tier = tier_to_proto(status.tier);
    let proto_mode = recommended_mode_to_proto(status.tier);

    let layer_status = CombinedLayerStatus {
        bm25: Some(layer_status_to_proto(&status.bm25)),
        vector: Some(layer_status_to_proto(&status.vector)),
        topics: Some(layer_status_to_proto(&status.topics)),
    };

    let available_layers: Vec<String> = TierDetector::tier_layers(status.tier)
        .into_iter()
        .map(String::from)
        .collect();

    Ok(Response::new(GetRetrievalCapabilitiesResponse {
        tier: proto_tier as i32,
        layer_status: Some(layer_status),
        available_layers,
        description: status.description,
        recommended_mode: proto_mode as i32,
    }))
}

/// Convert domain tier to proto tier.
fn tier_to_proto(tier: CapabilityTier) -> ProtoCapabilityTier {
    match tier {
        CapabilityTier::Tier1Full => ProtoCapabilityTier::Full,
        CapabilityTier::Tier2Hybrid => ProtoCapabilityTier::Hybrid,
        CapabilityTier::Tier3Semantic => ProtoCapabilityTier::Semantic,
        CapabilityTier::Tier4Keyword => ProtoCapabilityTier::Keyword,
        CapabilityTier::Tier5Agentic => ProtoCapabilityTier::Agentic,
    }
}

/// Get recommended execution mode for a tier.
fn recommended_mode_to_proto(tier: CapabilityTier) -> ProtoExecutionMode {
    match tier {
        CapabilityTier::Tier1Full | CapabilityTier::Tier2Hybrid => {
            // Higher tiers can benefit from parallel execution
            ProtoExecutionMode::Sequential // Default to sequential for explainability
        }
        _ => ProtoExecutionMode::Sequential,
    }
}

/// Convert domain layer status to proto.
fn layer_status_to_proto(status: &LayerStatus) -> ProtoLayerStatus {
    ProtoLayerStatus {
        enabled: status.enabled,
        healthy: status.healthy,
        doc_count: status.doc_count,
    }
}

/// Classify a query intent (FR-04).
///
/// Returns the classified intent for a given query string.
pub fn classify_query_intent(query: &str) -> QueryIntent {
    classify_intent(query)
}

/// Get layer order for an intent (FR-05).
///
/// Returns the preferred layer order for routing.
pub fn get_layer_order(intent: QueryIntent) -> Vec<String> {
    layer_order_for_intent(intent)
        .into_iter()
        .map(String::from)
        .collect()
}

/// Convert domain intent to proto intent.
pub fn intent_to_proto(intent: QueryIntent) -> ProtoQueryIntent {
    match intent {
        QueryIntent::Explore => ProtoQueryIntent::Explore,
        QueryIntent::Answer => ProtoQueryIntent::Answer,
        QueryIntent::Locate => ProtoQueryIntent::Locate,
        QueryIntent::TimeBoxed => ProtoQueryIntent::TimeBoxed,
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn ready_status() -> LayerStatus {
        LayerStatus {
            enabled: true,
            healthy: true,
            doc_count: 100,
        }
    }

    fn disabled_status() -> LayerStatus {
        LayerStatus {
            enabled: false,
            healthy: false,
            doc_count: 0,
        }
    }

    #[test]
    fn test_handler_detect_capabilities_full() {
        let handler = RetrievalHandler::new();
        let status = handler.detect_capabilities(ready_status(), ready_status(), ready_status());

        assert_eq!(status.tier, CapabilityTier::Tier1Full);
        assert!(status.bm25_ready());
        assert!(status.vector_ready());
        assert!(status.topics_ready());
    }

    #[test]
    fn test_handler_detect_capabilities_agentic_only() {
        let handler = RetrievalHandler::new();
        let status = handler.detect_capabilities(
            disabled_status(),
            disabled_status(),
            disabled_status(),
        );

        assert_eq!(status.tier, CapabilityTier::Tier5Agentic);
    }

    #[test]
    fn test_tier_to_proto() {
        assert_eq!(tier_to_proto(CapabilityTier::Tier1Full), ProtoCapabilityTier::Full);
        assert_eq!(tier_to_proto(CapabilityTier::Tier5Agentic), ProtoCapabilityTier::Agentic);
    }

    #[test]
    fn test_classify_query_intent() {
        assert_eq!(classify_query_intent("What have I been working on?"), QueryIntent::Explore);
        assert_eq!(classify_query_intent("Where is the config?"), QueryIntent::Locate);
        assert_eq!(classify_query_intent("How did we fix the bug?"), QueryIntent::Answer);
    }

    #[test]
    fn test_get_layer_order() {
        let explore_order = get_layer_order(QueryIntent::Explore);
        assert_eq!(explore_order[0], "topics");

        let locate_order = get_layer_order(QueryIntent::Locate);
        assert_eq!(locate_order[0], "bm25");
    }

    #[test]
    fn test_intent_to_proto() {
        assert_eq!(intent_to_proto(QueryIntent::Explore), ProtoQueryIntent::Explore);
        assert_eq!(intent_to_proto(QueryIntent::Answer), ProtoQueryIntent::Answer);
    }
}
```

Update `crates/memory-service/src/lib.rs` to add:
```rust
pub mod retrieval_service;
```

Also update `crates/memory-service/Cargo.toml` to add dependency:
```toml
memory-retrieval = { path = "../memory-retrieval" }
```
  </action>
  <verify>
```bash
cargo build -p memory-service
cargo test -p memory-service retrieval
```
  </verify>
  <done>RetrievalHandler exists with capability detection; all tests pass</done>
</task>

<task type="auto">
  <name>Task 2: Add CLI commands for retrieval policy</name>
  <files>crates/memory-daemon/src/cli.rs, crates/memory-daemon/src/commands.rs</files>
  <action>
Update `crates/memory-daemon/src/cli.rs` to add retrieval subcommand:

Add to the existing Args struct / subcommands:
```rust
/// Retrieval policy commands
#[derive(Debug, Args)]
pub struct RetrievalArgs {
    #[command(subcommand)]
    pub command: RetrievalCommand,
}

#[derive(Debug, Subcommand)]
pub enum RetrievalCommand {
    /// Show current retrieval capabilities and tier
    Status,

    /// Classify a query's intent
    Classify {
        /// Query to classify
        query: String,
    },

    /// Show layer order for an intent
    Route {
        /// Intent type: explore, answer, locate, time-boxed
        #[arg(default_value = "answer")]
        intent: String,
    },
}
```

Add `Retrieval(RetrievalArgs)` to the main Command enum.

Update `crates/memory-daemon/src/commands.rs` to add retrieval command handler:

```rust
use memory_retrieval::{
    classify_intent, layer_order_for_intent, detect_tier,
    TierDetector, CombinedStatus,
};
use memory_types::retrieval::{LayerStatus, QueryIntent};

/// Handle retrieval commands.
pub async fn handle_retrieval_command(args: &RetrievalArgs, client: &mut MemoryClient) -> Result<()> {
    match &args.command {
        RetrievalCommand::Status => handle_retrieval_status(client).await,
        RetrievalCommand::Classify { query } => handle_retrieval_classify(query),
        RetrievalCommand::Route { intent } => handle_retrieval_route(intent),
    }
}

/// Show current retrieval capabilities.
async fn handle_retrieval_status(client: &mut MemoryClient) -> Result<()> {
    println!("Retrieval Capabilities Status");
    println!("=============================\n");

    // Get status from daemon via RPC
    let response = client
        .get_retrieval_capabilities(GetRetrievalCapabilitiesRequest { force_refresh: false })
        .await?;

    let resp = response.into_inner();

    // Tier
    let tier_name = match resp.tier {
        1 => "Tier 1 (Full)",
        2 => "Tier 2 (Hybrid)",
        3 => "Tier 3 (Semantic)",
        4 => "Tier 4 (Keyword)",
        5 => "Tier 5 (Agentic)",
        _ => "Unknown",
    };
    println!("Current Tier: {}", tier_name);
    println!("Description: {}\n", resp.description);

    // Layer status
    println!("Layer Status:");
    if let Some(status) = &resp.layer_status {
        print_layer_status("  BM25", status.bm25.as_ref());
        print_layer_status("  Vector", status.vector.as_ref());
        print_layer_status("  Topics", status.topics.as_ref());
    }

    // Available layers
    println!("\nAvailable Layers: {}", resp.available_layers.join(", "));

    // Recommended mode
    let mode_name = match resp.recommended_mode {
        1 => "Sequential",
        2 => "Parallel",
        3 => "Hybrid",
        _ => "Sequential",
    };
    println!("Recommended Mode: {}", mode_name);

    Ok(())
}

/// Print a single layer status.
fn print_layer_status(name: &str, status: Option<&ProtoLayerStatus>) {
    if let Some(s) = status {
        let state = if s.enabled && s.healthy {
            "[READY]"
        } else if s.enabled {
            "[UNHEALTHY]"
        } else {
            "[DISABLED]"
        };
        println!("{}: {} ({} docs)", name, state, s.doc_count);
    } else {
        println!("{}: [UNKNOWN]", name);
    }
}

/// Classify a query's intent.
fn handle_retrieval_classify(query: &str) -> Result<()> {
    println!("Query Intent Classification");
    println!("===========================\n");
    println!("Query: \"{}\"\n", query);

    let intent = classify_intent(query);

    let (intent_name, description) = match intent {
        QueryIntent::Explore => ("Explore", "Discover patterns, themes, related concepts"),
        QueryIntent::Answer => ("Answer", "Get evidence-backed result fast"),
        QueryIntent::Locate => ("Locate", "Find exact snippet, quote, or definition"),
        QueryIntent::TimeBoxed => ("Time-boxed", "Return best partial in N ms"),
    };

    println!("Intent: {}", intent_name);
    println!("Description: {}\n", description);

    // Show layer order for this intent
    let layers = layer_order_for_intent(intent);
    println!("Preferred Layer Order:");
    for (i, layer) in layers.iter().enumerate() {
        println!("  {}. {}", i + 1, layer);
    }

    Ok(())
}

/// Show layer order for an intent.
fn handle_retrieval_route(intent_str: &str) -> Result<()> {
    println!("Layer Routing for Intent");
    println!("========================\n");

    let intent = match intent_str.to_lowercase().as_str() {
        "explore" => QueryIntent::Explore,
        "answer" => QueryIntent::Answer,
        "locate" => QueryIntent::Locate,
        "time-boxed" | "timeboxed" => QueryIntent::TimeBoxed,
        _ => {
            eprintln!("Unknown intent: {}. Valid values: explore, answer, locate, time-boxed", intent_str);
            return Ok(());
        }
    };

    println!("Intent: {:?}\n", intent);

    let layers = layer_order_for_intent(intent);
    println!("Layer Order (try in sequence until success):");
    for (i, layer) in layers.iter().enumerate() {
        let desc = match *layer {
            "topics" => "Topic graph discovery",
            "hybrid" => "BM25 + Vector fusion",
            "bm25" => "Keyword search",
            "vector" => "Semantic similarity",
            "agentic" => "TOC navigation (always works)",
            "best_available" => "Best available accelerator",
            _ => "",
        };
        println!("  {}. {} - {}", i + 1, layer, desc);
    }

    println!("\nNote: Agentic is always the final fallback (never fails).");

    Ok(())
}
```

Also update `crates/memory-daemon/Cargo.toml` to add dependency:
```toml
memory-retrieval = { path = "../memory-retrieval" }
```
  </action>
  <verify>
```bash
cargo build -p memory-daemon
# Test CLI commands (may need running daemon for full test)
cargo run -p memory-daemon -- retrieval classify "What have I been working on?"
cargo run -p memory-daemon -- retrieval route explore
```
  </verify>
  <done>CLI retrieval commands exist (status, classify, route); build succeeds</done>
</task>

<task type="auto">
  <name>Task 3: Wire RetrievalHandler into MemoryServiceImpl</name>
  <files>crates/memory-service/src/server.rs</files>
  <action>
Update `crates/memory-service/src/server.rs` to integrate RetrievalHandler.

Find the MemoryServiceImpl struct and add:
```rust
use crate::retrieval_service::{RetrievalHandler, handle_get_retrieval_capabilities};
```

Add field to MemoryServiceImpl:
```rust
/// Retrieval policy handler
retrieval_handler: RetrievalHandler,
```

Update MemoryServiceImpl::new() or builder to initialize:
```rust
retrieval_handler: RetrievalHandler::new(),
```

Implement the GetRetrievalCapabilities RPC:
```rust
async fn get_retrieval_capabilities(
    &self,
    request: Request<GetRetrievalCapabilitiesRequest>,
) -> Result<Response<GetRetrievalCapabilitiesResponse>, Status> {
    // Get current layer statuses from existing handlers
    let bm25_status = self.get_bm25_layer_status();
    let vector_status = self.get_vector_layer_status();
    let topics_status = self.get_topics_layer_status();

    handle_get_retrieval_capabilities(
        &self.retrieval_handler,
        bm25_status,
        vector_status,
        topics_status,
        request,
    ).await
}
```

Add helper methods to get layer status from existing handlers:
```rust
/// Get BM25 layer status from teleport searcher.
fn get_bm25_layer_status(&self) -> LayerStatus {
    if let Some(searcher) = &self.teleport_searcher {
        LayerStatus {
            enabled: true,
            healthy: searcher.num_docs() > 0,
            doc_count: searcher.num_docs(),
        }
    } else {
        LayerStatus::default()
    }
}

/// Get Vector layer status from vector handler.
fn get_vector_layer_status(&self) -> LayerStatus {
    if let Some(handler) = &self.vector_handler {
        let status = handler.get_status();
        LayerStatus {
            enabled: status.available,
            healthy: status.vector_count > 0,
            doc_count: status.vector_count as u64,
        }
    } else {
        LayerStatus::default()
    }
}

/// Get Topics layer status from topic handler.
fn get_topics_layer_status(&self) -> LayerStatus {
    if let Some(handler) = &self.topic_handler {
        LayerStatus {
            enabled: handler.is_available(),
            healthy: handler.is_available(),
            doc_count: 0, // Topic count could be added
        }
    } else {
        LayerStatus::default()
    }
}
```

Note: The exact integration will depend on the current structure of MemoryServiceImpl. Adapt the field names to match existing patterns (e.g., teleport_searcher, vector_handler, topic_handler).
  </action>
  <verify>
```bash
cargo build -p memory-service
cargo test -p memory-service
```
  </verify>
  <done>MemoryServiceImpl has GetRetrievalCapabilities RPC integrated; build succeeds</done>
</task>

</tasks>

<verification>
After all tasks complete:

```bash
# Full workspace build
cargo build --workspace

# All tests
cargo test --workspace

# Clippy check
cargo clippy --workspace -- -D warnings

# Test CLI (if daemon is running)
# cargo run -p memory-daemon -- retrieval status
# cargo run -p memory-daemon -- retrieval classify "What were we discussing?"
# cargo run -p memory-daemon -- retrieval route explore
```
</verification>

<success_criteria>
1. GetRetrievalCapabilities RPC returns tier, layer status, available layers, description
2. RPC integrates with existing BM25, Vector, Topics status handlers
3. CLI `retrieval status` shows human-readable tier and layer info
4. CLI `retrieval classify` classifies query intent correctly
5. CLI `retrieval route` shows layer order for intent
6. Service compiles and integrates with existing memory-service
7. All unit tests pass
8. Clippy passes with no warnings
</success_criteria>

<output>
After completion, create `.planning/phases/17-agent-retrieval-policy/17-06-SUMMARY.md`
</output>
