---
phase: 17-agent-retrieval-policy
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/memory-retrieval/Cargo.toml
  - crates/memory-retrieval/src/lib.rs
  - crates/memory-retrieval/src/intent.rs
  - Cargo.toml
autonomous: true

must_haves:
  truths:
    - "IntentClassifier correctly classifies queries into Explore/Answer/Locate/TimeBoxed"
    - "Classification uses keyword-based heuristics without external API calls"
    - "Classification completes in under 1ms (no network calls)"
    - "Time constraint extraction identifies temporal hints in queries"
  artifacts:
    - path: "crates/memory-retrieval/src/intent.rs"
      provides: "Intent classification logic"
      exports: ["IntentClassifier", "classify_intent", "extract_time_constraint"]
    - path: "crates/memory-retrieval/Cargo.toml"
      provides: "New memory-retrieval crate"
      contains: "name = \"memory-retrieval\""
  key_links:
    - from: "crates/memory-retrieval/src/lib.rs"
      to: "crates/memory-retrieval/src/intent.rs"
      via: "pub mod intent"
      pattern: "pub mod intent"
---

<objective>
Create the intent classification module that categorizes queries without external API calls.

Purpose: Per PRD Section 3, intent classification enables intent-aware routing. The classifier uses keyword-based heuristics to map queries to Explore/Answer/Locate/TimeBoxed intents. This must be fast (<1ms) and deterministic. FR-04 requires classification; FR-05 requires intent-aware routing; FR-06 requires time constraint extraction.

Output: New memory-retrieval crate with IntentClassifier that categorizes queries using pattern matching on keywords and question structure.
</objective>

<execution_context>
@/Users/richardhightower/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardhightower/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Technical reference
@docs/prds/agent-retrieval-policy-prd.md
@crates/memory-types/src/retrieval.rs (will be created by 17-01)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create memory-retrieval crate structure</name>
  <files>Cargo.toml, crates/memory-retrieval/Cargo.toml, crates/memory-retrieval/src/lib.rs</files>
  <action>
1. Update workspace Cargo.toml to add memory-retrieval to members:
   ```toml
   members = [
       # ... existing members ...
       "crates/memory-retrieval",
   ]
   ```

2. Create `crates/memory-retrieval/Cargo.toml`:
   ```toml
   [package]
   name = "memory-retrieval"
   version = "2.0.0"
   edition = "2021"
   description = "Retrieval policy implementation for agent-memory"
   license = "MIT"

   [dependencies]
   memory-types = { path = "../memory-types" }
   tracing = { workspace = true }
   regex = { workspace = true }
   chrono = { workspace = true }

   [dev-dependencies]
   tokio = { workspace = true, features = ["rt-multi-thread", "macros"] }
   ```

3. Create `crates/memory-retrieval/src/lib.rs`:
   ```rust
   //! Retrieval policy implementation for agent-memory.
   //!
   //! This crate provides:
   //! - Intent classification (Explore/Answer/Locate/TimeBoxed)
   //! - Capability tier detection
   //! - Fallback chain execution
   //! - Skill contract patterns
   //!
   //! # Overview
   //!
   //! The retrieval policy acts as the "brainstem" for how skills select
   //! retrieval layers. Skills MUST check availability before using any layer.
   //!
   //! # Example
   //!
   //! ```ignore
   //! use memory_retrieval::intent::IntentClassifier;
   //!
   //! let classifier = IntentClassifier::new();
   //! let intent = classifier.classify("What have I been working on?");
   //! // intent == QueryIntent::Explore
   //! ```

   pub mod intent;

   // Re-exports
   pub use intent::{IntentClassifier, classify_intent, extract_time_constraint, TimeConstraint};
   ```
  </action>
  <verify>
```bash
cargo build -p memory-retrieval
```
  </verify>
  <done>memory-retrieval crate exists with proper Cargo.toml and lib.rs structure</done>
</task>

<task type="auto">
  <name>Task 2: Implement IntentClassifier with keyword heuristics</name>
  <files>crates/memory-retrieval/src/intent.rs</files>
  <action>
Create `crates/memory-retrieval/src/intent.rs`:

```rust
//! Query intent classification.
//!
//! Classifies queries into intent types using keyword-based heuristics
//! without external API calls. Per PRD Section 3, intents are:
//! - Explore: Discover patterns, themes
//! - Answer: Evidence-backed result (default)
//! - Locate: Find exact snippet
//! - TimeBoxed: Return partial in N ms

use memory_types::retrieval::QueryIntent;
use regex::Regex;
use std::sync::LazyLock;
use tracing::debug;

/// Patterns indicating Explore intent (discovery, themes, patterns)
static EXPLORE_PATTERNS: LazyLock<Vec<Regex>> = LazyLock::new(|| {
    vec![
        Regex::new(r"(?i)\bwhat have (i|we) been\b").unwrap(),
        Regex::new(r"(?i)\bworking on\b").unwrap(),
        Regex::new(r"(?i)\bthemes?\b").unwrap(),
        Regex::new(r"(?i)\btopics?\b").unwrap(),
        Regex::new(r"(?i)\bpatterns?\b").unwrap(),
        Regex::new(r"(?i)\brecurring\b").unwrap(),
        Regex::new(r"(?i)\boverview\b").unwrap(),
        Regex::new(r"(?i)\bsummari(ze|y)\b").unwrap(),
        Regex::new(r"(?i)\bwhat('s| is) going on\b").unwrap(),
        Regex::new(r"(?i)\bshow me\b.*\b(all|everything)\b").unwrap(),
        Regex::new(r"(?i)\bexplore\b").unwrap(),
        Regex::new(r"(?i)\bdiscover\b").unwrap(),
    ]
});

/// Patterns indicating Locate intent (exact finding)
static LOCATE_PATTERNS: LazyLock<Vec<Regex>> = LazyLock::new(|| {
    vec![
        Regex::new(r"(?i)\bwhere\b.*\b(did|do|is|was|define|talk)\b").unwrap(),
        Regex::new(r"(?i)\bfind\b").unwrap(),
        Regex::new(r"(?i)\blocate\b").unwrap(),
        Regex::new(r"(?i)\bexact\b").unwrap(),
        Regex::new(r"(?i)\bspecific\b.*\b(line|snippet|quote)\b").unwrap(),
        Regex::new(r"(?i)\bwhat file\b").unwrap(),
        Regex::new(r"(?i)\bwhere is\b").unwrap(),
        Regex::new(r"(?i)\bshow me the\b.*\b(definition|code|config)\b").unwrap(),
        Regex::new(r"(?i)\b(grep|search for)\b").unwrap(),
    ]
});

/// Patterns indicating Answer intent (evidence-backed fact)
static ANSWER_PATTERNS: LazyLock<Vec<Regex>> = LazyLock::new(|| {
    vec![
        Regex::new(r"(?i)\bhow did (we|i|you)\b").unwrap(),
        Regex::new(r"(?i)\bwhat was\b.*\bdecided\b").unwrap(),
        Regex::new(r"(?i)\bwhy did\b").unwrap(),
        Regex::new(r"(?i)\bexplain\b").unwrap(),
        Regex::new(r"(?i)\bhow (do|does|to)\b").unwrap(),
        Regex::new(r"(?i)\bwhat (is|are|was|were)\b").unwrap(),
        Regex::new(r"(?i)\bwhen did\b").unwrap(),
        Regex::new(r"(?i)\bwho\b").unwrap(),
    ]
});

/// Time constraint extracted from query
#[derive(Debug, Clone)]
pub struct TimeConstraint {
    /// Target duration in milliseconds (if specified)
    pub timeout_ms: Option<u64>,
    /// Human-readable description
    pub description: String,
}

/// Intent classifier using keyword-based heuristics.
///
/// No external API calls - classification is deterministic and fast (<1ms).
#[derive(Debug, Clone, Default)]
pub struct IntentClassifier {
    /// Whether to enable debug logging
    debug_enabled: bool,
}

impl IntentClassifier {
    /// Create a new intent classifier with default settings.
    pub fn new() -> Self {
        Self {
            debug_enabled: false,
        }
    }

    /// Create a classifier with debug logging enabled.
    pub fn with_debug(mut self) -> Self {
        self.debug_enabled = true;
        self
    }

    /// Classify a query into an intent type.
    ///
    /// Classification priority:
    /// 1. Check for TimeBoxed indicators (explicit timeout)
    /// 2. Check for Locate patterns (exact finding)
    /// 3. Check for Explore patterns (discovery)
    /// 4. Check for Answer patterns (evidence-backed)
    /// 5. Default to Answer (most common case)
    ///
    /// # Example
    ///
    /// ```
    /// use memory_retrieval::IntentClassifier;
    /// use memory_types::retrieval::QueryIntent;
    ///
    /// let classifier = IntentClassifier::new();
    /// assert_eq!(classifier.classify("What have I been working on?"), QueryIntent::Explore);
    /// assert_eq!(classifier.classify("Where did I define that config?"), QueryIntent::Locate);
    /// assert_eq!(classifier.classify("How did we fix the JWT bug?"), QueryIntent::Answer);
    /// ```
    pub fn classify(&self, query: &str) -> QueryIntent {
        let query_lower = query.to_lowercase();

        // Check for explicit time constraint first
        if let Some(constraint) = extract_time_constraint(query) {
            if constraint.timeout_ms.is_some() {
                debug!(query = %query, intent = "TimeBoxed", "Time constraint detected");
                return QueryIntent::TimeBoxed;
            }
        }

        // Check Locate patterns (highest specificity)
        for pattern in LOCATE_PATTERNS.iter() {
            if pattern.is_match(query) {
                if self.debug_enabled {
                    debug!(query = %query, pattern = %pattern, intent = "Locate", "Matched locate pattern");
                }
                return QueryIntent::Locate;
            }
        }

        // Check Explore patterns
        for pattern in EXPLORE_PATTERNS.iter() {
            if pattern.is_match(query) {
                if self.debug_enabled {
                    debug!(query = %query, pattern = %pattern, intent = "Explore", "Matched explore pattern");
                }
                return QueryIntent::Explore;
            }
        }

        // Check Answer patterns
        for pattern in ANSWER_PATTERNS.iter() {
            if pattern.is_match(query) {
                if self.debug_enabled {
                    debug!(query = %query, pattern = %pattern, intent = "Answer", "Matched answer pattern");
                }
                return QueryIntent::Answer;
            }
        }

        // Default to Answer (most common use case)
        if self.debug_enabled {
            debug!(query = %query, intent = "Answer", "No pattern matched, using default");
        }
        QueryIntent::Answer
    }

    /// Get confidence score for classification (0.0 - 1.0).
    ///
    /// Higher scores indicate more pattern matches.
    pub fn confidence(&self, query: &str) -> f32 {
        let mut score = 0.0f32;
        let mut matches = 0u32;

        // Count pattern matches
        for pattern in EXPLORE_PATTERNS.iter() {
            if pattern.is_match(query) {
                matches += 1;
            }
        }
        for pattern in LOCATE_PATTERNS.iter() {
            if pattern.is_match(query) {
                matches += 1;
            }
        }
        for pattern in ANSWER_PATTERNS.iter() {
            if pattern.is_match(query) {
                matches += 1;
            }
        }

        // More matches = higher confidence
        if matches > 0 {
            score = (matches as f32 / 3.0).min(1.0);
        } else {
            // Default case - low confidence
            score = 0.3;
        }

        score
    }
}

/// Convenience function to classify a query.
pub fn classify_intent(query: &str) -> QueryIntent {
    IntentClassifier::new().classify(query)
}

/// Extract time constraint from query (FR-06).
///
/// Looks for patterns like:
/// - "in 2 seconds"
/// - "within 500ms"
/// - "timeout 1000"
/// - "max 3s"
///
/// Returns None if no time constraint found.
pub fn extract_time_constraint(query: &str) -> Option<TimeConstraint> {
    static TIME_PATTERNS: LazyLock<Vec<(Regex, &'static str)>> = LazyLock::new(|| {
        vec![
            // "in N seconds/ms"
            (Regex::new(r"(?i)\bin\s+(\d+)\s*(s|sec|second|ms|millisecond)s?\b").unwrap(), "explicit"),
            // "within Nms"
            (Regex::new(r"(?i)\bwithin\s+(\d+)\s*(s|sec|second|ms|millisecond)s?\b").unwrap(), "within"),
            // "timeout N"
            (Regex::new(r"(?i)\btimeout\s+(\d+)\b").unwrap(), "timeout"),
            // "max Ns"
            (Regex::new(r"(?i)\bmax\s+(\d+)\s*(s|sec|second|ms|millisecond)s?\b").unwrap(), "max"),
        ]
    });

    for (pattern, desc) in TIME_PATTERNS.iter() {
        if let Some(caps) = pattern.captures(query) {
            let value: u64 = caps.get(1)?.as_str().parse().ok()?;
            let unit = caps.get(2).map(|m| m.as_str().to_lowercase());

            let timeout_ms = match unit.as_deref() {
                Some("s") | Some("sec") | Some("second") | Some("seconds") => value * 1000,
                Some("ms") | Some("millisecond") | Some("milliseconds") => value,
                None => value, // Assume ms if no unit
                _ => value,
            };

            return Some(TimeConstraint {
                timeout_ms: Some(timeout_ms),
                description: format!("{}: {}ms", desc, timeout_ms),
            });
        }
    }

    None
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_explore_intent() {
        let classifier = IntentClassifier::new();

        // Explore patterns
        assert_eq!(classifier.classify("What have I been working on?"), QueryIntent::Explore);
        assert_eq!(classifier.classify("Show me the themes"), QueryIntent::Explore);
        assert_eq!(classifier.classify("What topics have we discussed?"), QueryIntent::Explore);
        assert_eq!(classifier.classify("Give me an overview"), QueryIntent::Explore);
        assert_eq!(classifier.classify("What's going on?"), QueryIntent::Explore);
        assert_eq!(classifier.classify("Show me recurring patterns"), QueryIntent::Explore);
    }

    #[test]
    fn test_locate_intent() {
        let classifier = IntentClassifier::new();

        // Locate patterns
        assert_eq!(classifier.classify("Where did I define that config?"), QueryIntent::Locate);
        assert_eq!(classifier.classify("Find the error message"), QueryIntent::Locate);
        assert_eq!(classifier.classify("Locate the function definition"), QueryIntent::Locate);
        assert_eq!(classifier.classify("Where is the main entry point?"), QueryIntent::Locate);
        assert_eq!(classifier.classify("What file contains the config?"), QueryIntent::Locate);
    }

    #[test]
    fn test_answer_intent() {
        let classifier = IntentClassifier::new();

        // Answer patterns
        assert_eq!(classifier.classify("How did we fix the JWT bug?"), QueryIntent::Answer);
        assert_eq!(classifier.classify("What was decided about the API?"), QueryIntent::Answer);
        assert_eq!(classifier.classify("Why did we choose Rust?"), QueryIntent::Answer);
        assert_eq!(classifier.classify("Explain the authentication flow"), QueryIntent::Answer);
        assert_eq!(classifier.classify("When did we add that feature?"), QueryIntent::Answer);
    }

    #[test]
    fn test_default_to_answer() {
        let classifier = IntentClassifier::new();

        // Ambiguous queries default to Answer
        assert_eq!(classifier.classify("something"), QueryIntent::Answer);
        assert_eq!(classifier.classify("memory"), QueryIntent::Answer);
        assert_eq!(classifier.classify("test query"), QueryIntent::Answer);
    }

    #[test]
    fn test_time_boxed_intent() {
        let classifier = IntentClassifier::new();

        assert_eq!(classifier.classify("Find it in 2 seconds"), QueryIntent::TimeBoxed);
        assert_eq!(classifier.classify("Search within 500ms"), QueryIntent::TimeBoxed);
        assert_eq!(classifier.classify("timeout 1000 search for X"), QueryIntent::TimeBoxed);
    }

    #[test]
    fn test_extract_time_constraint() {
        // With time constraint
        let constraint = extract_time_constraint("Find it in 2 seconds").unwrap();
        assert_eq!(constraint.timeout_ms, Some(2000));

        let constraint = extract_time_constraint("within 500ms").unwrap();
        assert_eq!(constraint.timeout_ms, Some(500));

        let constraint = extract_time_constraint("timeout 1000").unwrap();
        assert_eq!(constraint.timeout_ms, Some(1000));

        // No time constraint
        assert!(extract_time_constraint("normal query").is_none());
    }

    #[test]
    fn test_confidence() {
        let classifier = IntentClassifier::new();

        // Query with pattern match should have higher confidence
        let high = classifier.confidence("What have I been working on?");
        let low = classifier.confidence("random text");

        assert!(high > low);
        assert!(low > 0.0); // Even default has some confidence
    }

    #[test]
    fn test_classification_is_fast() {
        let classifier = IntentClassifier::new();
        let start = std::time::Instant::now();

        // Run 1000 classifications
        for _ in 0..1000 {
            let _ = classifier.classify("What have I been working on lately?");
        }

        let elapsed = start.elapsed();
        // Should complete 1000 classifications in under 100ms (0.1ms each)
        assert!(elapsed.as_millis() < 100, "Classification too slow: {:?}", elapsed);
    }
}
```
  </action>
  <verify>
```bash
cargo build -p memory-retrieval
cargo test -p memory-retrieval intent
cargo test -p memory-retrieval --release -- test_classification_is_fast
```
  </verify>
  <done>IntentClassifier exists with keyword-based heuristics; all tests pass including performance test</done>
</task>

</tasks>

<verification>
After all tasks complete:

```bash
# Full workspace build
cargo build --workspace

# All memory-retrieval tests
cargo test -p memory-retrieval --all-features

# Performance test
cargo test -p memory-retrieval --release -- test_classification_is_fast

# Clippy check
cargo clippy -p memory-retrieval -- -D warnings

# Doc test
cargo test -p memory-retrieval --doc
```
</verification>

<success_criteria>
1. memory-retrieval crate exists in workspace
2. IntentClassifier correctly classifies Explore/Answer/Locate/TimeBoxed
3. extract_time_constraint() extracts timeout hints from queries
4. Classification uses pattern matching, no external API calls
5. Classification completes 1000 queries in under 100ms
6. classify_intent() convenience function works
7. All unit tests pass
8. Clippy passes with no warnings
</success_criteria>

<output>
After completion, create `.planning/phases/17-agent-retrieval-policy/17-02-SUMMARY.md`
</output>
