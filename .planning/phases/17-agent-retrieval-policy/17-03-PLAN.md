---
phase: 17-agent-retrieval-policy
plan: 03
type: execute
wave: 2
depends_on: ["17-01"]
files_modified:
  - crates/memory-retrieval/src/tier.rs
  - crates/memory-retrieval/src/lib.rs
  - proto/memory.proto
autonomous: true

must_haves:
  truths:
    - "TierDetector calls all layer status RPCs in a single combined check"
    - "Tier detection maps layer availability to correct capability tier (1-5)"
    - "Tier 5 (Agentic) is returned when no accelerators are available"
    - "CombinedStatus struct aggregates BM25, Vector, and Topics status"
  artifacts:
    - path: "crates/memory-retrieval/src/tier.rs"
      provides: "Tier detection algorithm"
      exports: ["TierDetector", "CombinedStatus", "detect_tier"]
    - path: "proto/memory.proto"
      provides: "GetRetrievalCapabilities RPC"
      contains: "rpc GetRetrievalCapabilities"
  key_links:
    - from: "crates/memory-retrieval/src/lib.rs"
      to: "crates/memory-retrieval/src/tier.rs"
      via: "pub mod tier"
      pattern: "pub mod tier"
---

<objective>
Implement tier detection that maps layer availability to capability tiers.

Purpose: Per PRD Section 5.2, skills must detect the current capability tier before executing queries. FR-01 requires a combined status check pattern, FR-02 requires the tier detection algorithm, FR-03 requires capability advertisement. This plan implements the "check" part of Check-Then-Search.

Output: TierDetector that queries all layer status RPCs and maps availability to tiers 1-5.
</objective>

<execution_context>
@/Users/richardhightower/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardhightower/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-agent-retrieval-policy/17-01-SUMMARY.md

# Technical reference
@docs/prds/agent-retrieval-policy-prd.md
@crates/memory-service/src/vector.rs
@crates/memory-service/src/topics.rs
@proto/memory.proto
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create tier detection module with CombinedStatus</name>
  <files>crates/memory-retrieval/src/tier.rs, crates/memory-retrieval/src/lib.rs</files>
  <action>
Create `crates/memory-retrieval/src/tier.rs`:

```rust
//! Capability tier detection.
//!
//! Implements FR-01 (combined status check) and FR-02 (tier detection algorithm).
//!
//! Tiers per PRD Section 5.1:
//! - Tier 1 (Full): Topics + Hybrid + Agentic
//! - Tier 2 (Hybrid): BM25 + Vector + Agentic
//! - Tier 3 (Semantic): Vector + Agentic
//! - Tier 4 (Keyword): BM25 + Agentic
//! - Tier 5 (Agentic): TOC Search only (always works)

use memory_types::retrieval::{CapabilityTier, LayerStatus};
use serde::{Deserialize, Serialize};
use tracing::{debug, info};

/// Combined status of all retrieval layers.
///
/// Aggregates status from BM25 (GetTeleportStatus), Vector (GetVectorIndexStatus),
/// and Topics (GetTopicGraphStatus).
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct CombinedStatus {
    /// BM25 layer status (from GetTeleportStatus)
    pub bm25: LayerStatus,
    /// Vector layer status (from GetVectorIndexStatus)
    pub vector: LayerStatus,
    /// Topics layer status (from GetTopicGraphStatus)
    pub topics: LayerStatus,
    /// Detected capability tier
    pub tier: CapabilityTier,
    /// Human-readable description of current capabilities
    pub description: String,
}

impl CombinedStatus {
    /// Create a new combined status with all layers disabled (Tier 5).
    pub fn agentic_only() -> Self {
        Self {
            bm25: LayerStatus::default(),
            vector: LayerStatus::default(),
            topics: LayerStatus::default(),
            tier: CapabilityTier::Tier5Agentic,
            description: "Agentic TOC search only (no accelerators available)".to_string(),
        }
    }

    /// Check if BM25 is ready for queries.
    pub fn bm25_ready(&self) -> bool {
        self.bm25.enabled && self.bm25.healthy
    }

    /// Check if Vector is ready for queries.
    pub fn vector_ready(&self) -> bool {
        self.vector.enabled && self.vector.healthy
    }

    /// Check if Topics is ready for queries.
    pub fn topics_ready(&self) -> bool {
        self.topics.enabled && self.topics.healthy
    }

    /// Check if hybrid search (BM25 + Vector) is available.
    pub fn hybrid_ready(&self) -> bool {
        self.bm25_ready() && self.vector_ready()
    }
}

/// Tier detector that maps layer availability to capability tiers.
///
/// # Example
///
/// ```ignore
/// let detector = TierDetector::new();
/// let status = detector.detect(bm25_status, vector_status, topics_status);
/// println!("Current tier: {:?}", status.tier);
/// ```
#[derive(Debug, Clone, Default)]
pub struct TierDetector {
    /// Whether to log tier detection decisions
    debug_enabled: bool,
}

impl TierDetector {
    /// Create a new tier detector.
    pub fn new() -> Self {
        Self {
            debug_enabled: false,
        }
    }

    /// Enable debug logging.
    pub fn with_debug(mut self) -> Self {
        self.debug_enabled = true;
        self
    }

    /// Detect capability tier from layer statuses.
    ///
    /// Tier assignment per PRD Section 5.1:
    /// ```text
    /// Topics + Vector + BM25 => Tier 1 (Full)
    /// Vector + BM25          => Tier 2 (Hybrid)
    /// Vector only            => Tier 3 (Semantic)
    /// BM25 only              => Tier 4 (Keyword)
    /// None                   => Tier 5 (Agentic)
    /// ```
    pub fn detect(
        &self,
        bm25: LayerStatus,
        vector: LayerStatus,
        topics: LayerStatus,
    ) -> CombinedStatus {
        let bm25_ready = bm25.enabled && bm25.healthy;
        let vector_ready = vector.enabled && vector.healthy;
        let topics_ready = topics.enabled && topics.healthy;

        let (tier, description) = match (topics_ready, vector_ready, bm25_ready) {
            (true, true, true) => (
                CapabilityTier::Tier1Full,
                "Full capabilities: Topics + Hybrid + Agentic".to_string(),
            ),
            (_, true, true) => (
                CapabilityTier::Tier2Hybrid,
                "Hybrid capabilities: BM25 + Vector + Agentic".to_string(),
            ),
            (_, true, false) => (
                CapabilityTier::Tier3Semantic,
                "Semantic capabilities: Vector + Agentic".to_string(),
            ),
            (_, false, true) => (
                CapabilityTier::Tier4Keyword,
                "Keyword capabilities: BM25 + Agentic".to_string(),
            ),
            _ => (
                CapabilityTier::Tier5Agentic,
                "Agentic TOC search only (no accelerators available)".to_string(),
            ),
        };

        if self.debug_enabled {
            debug!(
                bm25_ready = bm25_ready,
                vector_ready = vector_ready,
                topics_ready = topics_ready,
                tier = ?tier,
                "Tier detection complete"
            );
        }

        info!(tier = ?tier, "Detected capability tier");

        CombinedStatus {
            bm25,
            vector,
            topics,
            tier,
            description,
        }
    }

    /// Get layers available for a given tier.
    pub fn tier_layers(tier: CapabilityTier) -> Vec<&'static str> {
        match tier {
            CapabilityTier::Tier1Full => vec!["topics", "bm25", "vector", "agentic"],
            CapabilityTier::Tier2Hybrid => vec!["bm25", "vector", "agentic"],
            CapabilityTier::Tier3Semantic => vec!["vector", "agentic"],
            CapabilityTier::Tier4Keyword => vec!["bm25", "agentic"],
            CapabilityTier::Tier5Agentic => vec!["agentic"],
        }
    }

    /// Check if a tier supports a specific layer.
    pub fn tier_supports(tier: CapabilityTier, layer: &str) -> bool {
        Self::tier_layers(tier).contains(&layer)
    }
}

/// Convenience function to detect tier.
pub fn detect_tier(
    bm25: LayerStatus,
    vector: LayerStatus,
    topics: LayerStatus,
) -> CombinedStatus {
    TierDetector::new().detect(bm25, vector, topics)
}

/// Layer order for each query intent.
///
/// Returns the preferred order to try layers based on intent type.
pub fn layer_order_for_intent(
    intent: memory_types::retrieval::QueryIntent,
) -> Vec<&'static str> {
    use memory_types::retrieval::QueryIntent;

    match intent {
        QueryIntent::Explore => vec!["topics", "hybrid", "vector", "bm25", "agentic"],
        QueryIntent::Answer => vec!["hybrid", "bm25", "vector", "agentic"],
        QueryIntent::Locate => vec!["bm25", "hybrid", "vector", "agentic"],
        QueryIntent::TimeBoxed => vec!["best_available", "agentic"],
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn ready_status(doc_count: u64) -> LayerStatus {
        LayerStatus {
            enabled: true,
            healthy: true,
            doc_count,
        }
    }

    fn disabled_status() -> LayerStatus {
        LayerStatus {
            enabled: false,
            healthy: false,
            doc_count: 0,
        }
    }

    fn unhealthy_status() -> LayerStatus {
        LayerStatus {
            enabled: true,
            healthy: false,
            doc_count: 0,
        }
    }

    #[test]
    fn test_tier1_full() {
        let detector = TierDetector::new();
        let status = detector.detect(
            ready_status(100),
            ready_status(100),
            ready_status(50),
        );
        assert_eq!(status.tier, CapabilityTier::Tier1Full);
        assert!(status.bm25_ready());
        assert!(status.vector_ready());
        assert!(status.topics_ready());
    }

    #[test]
    fn test_tier2_hybrid() {
        let detector = TierDetector::new();
        let status = detector.detect(
            ready_status(100),
            ready_status(100),
            disabled_status(),
        );
        assert_eq!(status.tier, CapabilityTier::Tier2Hybrid);
        assert!(status.hybrid_ready());
    }

    #[test]
    fn test_tier3_semantic() {
        let detector = TierDetector::new();
        let status = detector.detect(
            disabled_status(),
            ready_status(100),
            disabled_status(),
        );
        assert_eq!(status.tier, CapabilityTier::Tier3Semantic);
    }

    #[test]
    fn test_tier4_keyword() {
        let detector = TierDetector::new();
        let status = detector.detect(
            ready_status(100),
            disabled_status(),
            disabled_status(),
        );
        assert_eq!(status.tier, CapabilityTier::Tier4Keyword);
    }

    #[test]
    fn test_tier5_agentic() {
        let detector = TierDetector::new();
        let status = detector.detect(
            disabled_status(),
            disabled_status(),
            disabled_status(),
        );
        assert_eq!(status.tier, CapabilityTier::Tier5Agentic);
    }

    #[test]
    fn test_unhealthy_counts_as_unavailable() {
        let detector = TierDetector::new();
        let status = detector.detect(
            unhealthy_status(),
            unhealthy_status(),
            unhealthy_status(),
        );
        // All unhealthy = Tier 5 (agentic only)
        assert_eq!(status.tier, CapabilityTier::Tier5Agentic);
    }

    #[test]
    fn test_topics_without_others_still_tier5() {
        let detector = TierDetector::new();
        // Topics alone doesn't upgrade tier - need at least BM25 or Vector
        let status = detector.detect(
            disabled_status(),
            disabled_status(),
            ready_status(50),
        );
        // Topics without BM25/Vector is still Tier 5
        // (Topics enhances Explore but needs base layers)
        assert_eq!(status.tier, CapabilityTier::Tier5Agentic);
    }

    #[test]
    fn test_tier_layers() {
        assert!(TierDetector::tier_supports(CapabilityTier::Tier1Full, "topics"));
        assert!(TierDetector::tier_supports(CapabilityTier::Tier1Full, "bm25"));
        assert!(!TierDetector::tier_supports(CapabilityTier::Tier5Agentic, "bm25"));
        assert!(TierDetector::tier_supports(CapabilityTier::Tier5Agentic, "agentic"));
    }

    #[test]
    fn test_layer_order_for_intent() {
        use memory_types::retrieval::QueryIntent;

        let explore_order = layer_order_for_intent(QueryIntent::Explore);
        assert_eq!(explore_order[0], "topics"); // Topics first for explore

        let locate_order = layer_order_for_intent(QueryIntent::Locate);
        assert_eq!(locate_order[0], "bm25"); // BM25 first for locate

        let answer_order = layer_order_for_intent(QueryIntent::Answer);
        assert_eq!(answer_order[0], "hybrid"); // Hybrid first for answer
    }

    #[test]
    fn test_combined_status_agentic_only() {
        let status = CombinedStatus::agentic_only();
        assert_eq!(status.tier, CapabilityTier::Tier5Agentic);
        assert!(!status.bm25_ready());
        assert!(!status.vector_ready());
        assert!(!status.topics_ready());
    }
}
```

Update `crates/memory-retrieval/src/lib.rs` to add:
```rust
pub mod tier;

// Re-exports
pub use tier::{TierDetector, CombinedStatus, detect_tier, layer_order_for_intent};
```
  </action>
  <verify>
```bash
cargo build -p memory-retrieval
cargo test -p memory-retrieval tier
```
  </verify>
  <done>TierDetector exists with correct tier mapping; all tier tests pass</done>
</task>

<task type="auto">
  <name>Task 2: Add GetRetrievalCapabilities RPC to proto</name>
  <files>proto/memory.proto</files>
  <action>
Update `proto/memory.proto`:

1. Add GetRetrievalCapabilities RPC to MemoryService (around line 83, after existing RPCs):
   ```protobuf
   // Retrieval Policy RPCs (Phase 17 - FR-01 through FR-03)

   // Get current retrieval capabilities (combined status check)
   rpc GetRetrievalCapabilities(GetRetrievalCapabilitiesRequest) returns (GetRetrievalCapabilitiesResponse);
   ```

2. Add request/response messages (at end of file):
   ```protobuf
   // ===== Retrieval Capabilities Messages (Phase 17 - FR-01 through FR-03) =====

   // Request for current retrieval capabilities
   message GetRetrievalCapabilitiesRequest {
       // Whether to force refresh cached status
       bool force_refresh = 1;
   }

   // Combined status of all retrieval layers
   message CombinedLayerStatus {
       // BM25 layer status
       LayerStatus bm25 = 1;
       // Vector layer status
       LayerStatus vector = 2;
       // Topics layer status
       LayerStatus topics = 3;
   }

   // Response with current retrieval capabilities
   message GetRetrievalCapabilitiesResponse {
       // Current capability tier
       CapabilityTier tier = 1;
       // Combined layer status
       CombinedLayerStatus layer_status = 2;
       // Available layers for current tier
       repeated string available_layers = 3;
       // Human-readable description
       string description = 4;
       // Recommended execution mode for current tier
       ExecutionMode recommended_mode = 5;
   }
   ```
  </action>
  <verify>
```bash
cargo build --workspace
```
  </verify>
  <done>Proto has GetRetrievalCapabilities RPC with request/response messages</done>
</task>

<task type="auto">
  <name>Task 3: Add layer order routing helper</name>
  <files>crates/memory-retrieval/src/tier.rs</files>
  <action>
Add to `crates/memory-retrieval/src/tier.rs`:

```rust
/// Route selection based on intent and available tier.
///
/// Returns the best layer to use given intent and tier, plus fallback order.
#[derive(Debug, Clone)]
pub struct RouteSelection {
    /// Primary layer to try first
    pub primary: &'static str,
    /// Fallback layers in order
    pub fallbacks: Vec<&'static str>,
    /// Explanation of why this route was chosen
    pub explanation: String,
}

impl TierDetector {
    /// Select route based on intent and current tier (FR-05).
    ///
    /// Combines intent preference with tier availability to produce
    /// an actionable route.
    pub fn select_route(
        &self,
        intent: memory_types::retrieval::QueryIntent,
        status: &CombinedStatus,
    ) -> RouteSelection {
        use memory_types::retrieval::QueryIntent;

        let preferred = layer_order_for_intent(intent);
        let available = Self::tier_layers(status.tier);

        // Filter preferred order to only available layers
        let mut route: Vec<&'static str> = preferred
            .into_iter()
            .filter(|layer| {
                // Special handling for "hybrid" and "best_available"
                match *layer {
                    "hybrid" => status.hybrid_ready(),
                    "best_available" => true, // Will be resolved below
                    _ => available.contains(layer),
                }
            })
            .collect();

        // Resolve "best_available" to actual layer
        if route.contains(&"best_available") {
            route = route
                .into_iter()
                .flat_map(|l| {
                    if l == "best_available" {
                        // Return best available accelerator
                        if status.hybrid_ready() {
                            vec!["hybrid"]
                        } else if status.bm25_ready() {
                            vec!["bm25"]
                        } else if status.vector_ready() {
                            vec!["vector"]
                        } else {
                            vec![]
                        }
                    } else {
                        vec![l]
                    }
                })
                .collect();
        }

        // Ensure agentic is always last fallback
        if !route.contains(&"agentic") {
            route.push("agentic");
        }

        let (primary, fallbacks) = if route.is_empty() {
            ("agentic", vec![])
        } else {
            (route[0], route[1..].to_vec())
        };

        let explanation = format!(
            "Intent {:?} with {} -> primary: {}, fallbacks: {:?}",
            intent, status.tier as u8, primary, fallbacks
        );

        RouteSelection {
            primary,
            fallbacks,
            explanation,
        }
    }
}
```

Add tests:
```rust
#[test]
fn test_route_selection_explore_tier1() {
    use memory_types::retrieval::QueryIntent;

    let detector = TierDetector::new();
    let status = detector.detect(
        ready_status(100),
        ready_status(100),
        ready_status(50),
    );

    let route = detector.select_route(QueryIntent::Explore, &status);
    assert_eq!(route.primary, "topics");
    assert!(route.fallbacks.contains(&"agentic"));
}

#[test]
fn test_route_selection_locate_tier4() {
    use memory_types::retrieval::QueryIntent;

    let detector = TierDetector::new();
    let status = detector.detect(
        ready_status(100),
        disabled_status(),
        disabled_status(),
    );

    let route = detector.select_route(QueryIntent::Locate, &status);
    assert_eq!(route.primary, "bm25");
}

#[test]
fn test_route_selection_always_has_agentic_fallback() {
    use memory_types::retrieval::QueryIntent;

    let detector = TierDetector::new();
    let status = CombinedStatus::agentic_only();

    let route = detector.select_route(QueryIntent::Answer, &status);
    assert_eq!(route.primary, "agentic");
}
```
  </action>
  <verify>
```bash
cargo test -p memory-retrieval tier
```
  </verify>
  <done>RouteSelection helper exists with intent+tier-aware routing; tests pass</done>
</task>

</tasks>

<verification>
After all tasks complete:

```bash
# Full workspace build
cargo build --workspace

# All memory-retrieval tests
cargo test -p memory-retrieval --all-features

# Clippy check
cargo clippy -p memory-retrieval -- -D warnings

# Proto compiles
cargo build -p memory-service
```
</verification>

<success_criteria>
1. TierDetector correctly maps layer availability to tiers 1-5
2. CombinedStatus aggregates all layer statuses
3. Tier 5 (Agentic) returned when no accelerators available
4. Unhealthy layers treated as unavailable
5. RouteSelection combines intent + tier for actionable routing
6. Proto has GetRetrievalCapabilities RPC
7. layer_order_for_intent() returns correct order per intent
8. All unit tests pass
9. Clippy passes with no warnings
</success_criteria>

<output>
After completion, create `.planning/phases/17-agent-retrieval-policy/17-03-SUMMARY.md`
</output>
