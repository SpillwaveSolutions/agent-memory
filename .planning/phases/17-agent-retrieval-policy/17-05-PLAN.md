---
phase: 17-agent-retrieval-policy
plan: 05
type: execute
wave: 4
depends_on: ["17-01", "17-03", "17-04"]
files_modified:
  - crates/memory-retrieval/src/contract.rs
  - crates/memory-retrieval/src/explainability.rs
  - crates/memory-retrieval/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "SkillContract validates that skills meet retrieval policy requirements"
    - "ExplainabilityPayload reports tier, method, candidates, and reasoning"
    - "Validation checks capability detection, budget enforcement, fallback discipline"
    - "Contract documentation patterns available for SKILL.md generation"
  artifacts:
    - path: "crates/memory-retrieval/src/contract.rs"
      provides: "Skill contract validation"
      exports: ["SkillContract", "ContractValidation", "validate_skill"]
    - path: "crates/memory-retrieval/src/explainability.rs"
      provides: "Explainability payload for skill responses"
      exports: ["ExplainabilityPayload", "CandidateInfo", "ArbitrationReason"]
  key_links:
    - from: "crates/memory-retrieval/src/lib.rs"
      to: "crates/memory-retrieval/src/contract.rs"
      via: "pub mod contract"
      pattern: "pub mod contract"
---

<objective>
Implement skill contracts and explainability payloads for retrieval-capable skills.

Purpose: Per PRD Section 2.5 and 8, skills are "policy executors" that must meet contract requirements. FR-19 requires explainable arbitration. This plan implements the SkillContract validation patterns and ExplainabilityPayload that skills must include in responses.

Output: Contract validation module and explainability payload types that skills use to report their retrieval decisions.
</objective>

<execution_context>
@/Users/richardhightower/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardhightower/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-agent-retrieval-policy/17-01-SUMMARY.md
@.planning/phases/17-agent-retrieval-policy/17-03-SUMMARY.md
@.planning/phases/17-agent-retrieval-policy/17-04-SUMMARY.md

# Technical reference
@docs/prds/agent-retrieval-policy-prd.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create explainability payload types</name>
  <files>crates/memory-retrieval/src/explainability.rs</files>
  <action>
Create `crates/memory-retrieval/src/explainability.rs`:

```rust
//! Explainability payload for skill responses.
//!
//! Implements FR-13 (tier/method reporting), FR-14 (fallback explanation),
//! and FR-19 (explainable arbitration).
//!
//! Skills must include an ExplainabilityPayload in responses to enable
//! user trust and debugging.

use memory_types::retrieval::{CapabilityTier, ExecutionMode, QueryIntent};
use serde::{Deserialize, Serialize};

/// Information about a candidate layer that was considered.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CandidateInfo {
    /// Layer name (e.g., "bm25", "vector", "topics", "agentic")
    pub layer: String,
    /// Whether this layer was available
    pub available: bool,
    /// Whether this layer was used
    pub used: bool,
    /// Reason for selection/rejection
    pub reason: String,
    /// Result count if used
    pub result_count: Option<usize>,
    /// Confidence score if used (0.0-1.0)
    pub confidence: Option<f32>,
    /// Execution time if used (milliseconds)
    pub duration_ms: Option<u64>,
}

impl CandidateInfo {
    /// Create a candidate that was used.
    pub fn used(layer: &str, result_count: usize, confidence: f32, duration_ms: u64) -> Self {
        Self {
            layer: layer.to_string(),
            available: true,
            used: true,
            reason: "Selected as primary or fallback".to_string(),
            result_count: Some(result_count),
            confidence: Some(confidence),
            duration_ms: Some(duration_ms),
        }
    }

    /// Create a candidate that was skipped.
    pub fn skipped(layer: &str, reason: &str) -> Self {
        Self {
            layer: layer.to_string(),
            available: false,
            used: false,
            reason: reason.to_string(),
            result_count: None,
            confidence: None,
            duration_ms: None,
        }
    }

    /// Create a candidate that was available but not used.
    pub fn available_unused(layer: &str, reason: &str) -> Self {
        Self {
            layer: layer.to_string(),
            available: true,
            used: false,
            reason: reason.to_string(),
            result_count: None,
            confidence: None,
            duration_ms: None,
        }
    }
}

/// Reason why a particular arbitration decision was made.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ArbitrationReason {
    /// Primary layer succeeded with sufficient results
    PrimarySuccess { layer: String, confidence: f32 },
    /// Fell back due to primary failure
    FallbackFromFailure { failed_layer: String, fallback_layer: String, error: String },
    /// Fell back due to insufficient results
    FallbackFromInsufficient { prior_layer: String, fallback_layer: String, result_count: usize },
    /// Used parallel execution, winner determined by confidence
    ParallelWinner { winner: String, competitors: Vec<String>, confidence: f32 },
    /// Merged results from multiple layers
    MergedResults { layers: Vec<String>, method: String },
    /// Stopped due to stop condition
    StoppedByCondition { condition: String, partial_results: usize },
}

impl std::fmt::Display for ArbitrationReason {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ArbitrationReason::PrimarySuccess { layer, confidence } => {
                write!(f, "Primary layer '{}' succeeded (confidence: {:.2})", layer, confidence)
            }
            ArbitrationReason::FallbackFromFailure { failed_layer, fallback_layer, error } => {
                write!(f, "Fell back from '{}' to '{}': {}", failed_layer, fallback_layer, error)
            }
            ArbitrationReason::FallbackFromInsufficient { prior_layer, fallback_layer, result_count } => {
                write!(f, "Fell back from '{}' ({} results) to '{}'", prior_layer, result_count, fallback_layer)
            }
            ArbitrationReason::ParallelWinner { winner, competitors, confidence } => {
                write!(f, "Parallel winner '{}' (confidence: {:.2}) beat {:?}", winner, confidence, competitors)
            }
            ArbitrationReason::MergedResults { layers, method } => {
                write!(f, "Merged results from {:?} using {}", layers, method)
            }
            ArbitrationReason::StoppedByCondition { condition, partial_results } => {
                write!(f, "Stopped by {}, returning {} partial results", condition, partial_results)
            }
        }
    }
}

/// Explainability payload included in skill responses.
///
/// Per PRD Section 8, every retrieval-capable skill MUST provide this
/// payload to report: chosen tier/mode, candidates considered, why winner won.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExplainabilityPayload {
    /// Detected query intent
    pub intent: QueryIntent,
    /// Capability tier that was used
    pub tier_used: CapabilityTier,
    /// Execution mode that was used
    pub mode_used: ExecutionMode,
    /// All candidate layers that were considered
    pub candidates: Vec<CandidateInfo>,
    /// Primary reason for final arbitration
    pub arbitration_reason: ArbitrationReason,
    /// Human-readable summary
    pub summary: String,
    /// Whether a fallback occurred
    pub fallback_occurred: bool,
    /// Total execution time (milliseconds)
    pub total_duration_ms: u64,
    /// Grip IDs for evidence (if applicable)
    pub evidence_grip_ids: Vec<String>,
}

impl ExplainabilityPayload {
    /// Create a new payload builder.
    pub fn builder() -> ExplainabilityPayloadBuilder {
        ExplainabilityPayloadBuilder::default()
    }

    /// Get a short summary suitable for user display.
    pub fn short_summary(&self) -> String {
        format!(
            "Used {} (Tier {}) via {:?} mode in {}ms",
            self.candidates.iter().find(|c| c.used).map(|c| &c.layer).unwrap_or(&"unknown".to_string()),
            self.tier_used as u8,
            self.mode_used,
            self.total_duration_ms
        )
    }

    /// Generate markdown documentation for the retrieval path.
    pub fn to_markdown(&self) -> String {
        let mut md = String::new();

        md.push_str("## Retrieval Path\n\n");
        md.push_str(&format!("- **Intent:** {:?}\n", self.intent));
        md.push_str(&format!("- **Tier:** {} ({})\n", self.tier_used as u8, tier_description(self.tier_used)));
        md.push_str(&format!("- **Mode:** {:?}\n", self.mode_used));
        md.push_str(&format!("- **Duration:** {}ms\n", self.total_duration_ms));

        if self.fallback_occurred {
            md.push_str("- **Fallback:** Yes\n");
        }

        md.push_str("\n### Candidates Considered\n\n");
        for c in &self.candidates {
            let status = if c.used {
                "USED"
            } else if c.available {
                "available"
            } else {
                "unavailable"
            };
            md.push_str(&format!("- **{}** [{}]: {}\n", c.layer, status, c.reason));
        }

        md.push_str(&format!("\n### Arbitration\n\n{}\n", self.arbitration_reason));

        if !self.evidence_grip_ids.is_empty() {
            md.push_str("\n### Evidence\n\n");
            for grip_id in &self.evidence_grip_ids {
                md.push_str(&format!("- `{}`\n", grip_id));
            }
        }

        md
    }
}

/// Builder for ExplainabilityPayload.
#[derive(Debug, Default)]
pub struct ExplainabilityPayloadBuilder {
    intent: Option<QueryIntent>,
    tier_used: Option<CapabilityTier>,
    mode_used: Option<ExecutionMode>,
    candidates: Vec<CandidateInfo>,
    arbitration_reason: Option<ArbitrationReason>,
    fallback_occurred: bool,
    total_duration_ms: u64,
    evidence_grip_ids: Vec<String>,
}

impl ExplainabilityPayloadBuilder {
    /// Set the detected intent.
    pub fn intent(mut self, intent: QueryIntent) -> Self {
        self.intent = Some(intent);
        self
    }

    /// Set the tier used.
    pub fn tier(mut self, tier: CapabilityTier) -> Self {
        self.tier_used = Some(tier);
        self
    }

    /// Set the execution mode.
    pub fn mode(mut self, mode: ExecutionMode) -> Self {
        self.mode_used = Some(mode);
        self
    }

    /// Add a candidate layer.
    pub fn candidate(mut self, candidate: CandidateInfo) -> Self {
        self.candidates.push(candidate);
        self
    }

    /// Add multiple candidates.
    pub fn candidates(mut self, candidates: Vec<CandidateInfo>) -> Self {
        self.candidates.extend(candidates);
        self
    }

    /// Set the arbitration reason.
    pub fn arbitration(mut self, reason: ArbitrationReason) -> Self {
        self.arbitration_reason = Some(reason);
        self
    }

    /// Mark that fallback occurred.
    pub fn with_fallback(mut self) -> Self {
        self.fallback_occurred = true;
        self
    }

    /// Set total duration.
    pub fn duration_ms(mut self, ms: u64) -> Self {
        self.total_duration_ms = ms;
        self
    }

    /// Add evidence grip IDs.
    pub fn evidence(mut self, grip_ids: Vec<String>) -> Self {
        self.evidence_grip_ids = grip_ids;
        self
    }

    /// Build the payload.
    pub fn build(self) -> ExplainabilityPayload {
        let summary = format!(
            "{:?} query used Tier {} {:?} mode",
            self.intent.unwrap_or_default(),
            self.tier_used.unwrap_or_default() as u8,
            self.mode_used.unwrap_or_default()
        );

        ExplainabilityPayload {
            intent: self.intent.unwrap_or_default(),
            tier_used: self.tier_used.unwrap_or_default(),
            mode_used: self.mode_used.unwrap_or_default(),
            candidates: self.candidates,
            arbitration_reason: self.arbitration_reason.unwrap_or(ArbitrationReason::PrimarySuccess {
                layer: "agentic".to_string(),
                confidence: 0.5,
            }),
            summary,
            fallback_occurred: self.fallback_occurred,
            total_duration_ms: self.total_duration_ms,
            evidence_grip_ids: self.evidence_grip_ids,
        }
    }
}

/// Get human-readable description for a tier.
fn tier_description(tier: CapabilityTier) -> &'static str {
    match tier {
        CapabilityTier::Tier1Full => "Full: Topics + Hybrid + Agentic",
        CapabilityTier::Tier2Hybrid => "Hybrid: BM25 + Vector + Agentic",
        CapabilityTier::Tier3Semantic => "Semantic: Vector + Agentic",
        CapabilityTier::Tier4Keyword => "Keyword: BM25 + Agentic",
        CapabilityTier::Tier5Agentic => "Agentic: TOC Search only",
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_candidate_info_used() {
        let c = CandidateInfo::used("bm25", 10, 0.8, 50);
        assert!(c.used);
        assert!(c.available);
        assert_eq!(c.result_count, Some(10));
    }

    #[test]
    fn test_candidate_info_skipped() {
        let c = CandidateInfo::skipped("topics", "Not enabled");
        assert!(!c.used);
        assert!(!c.available);
    }

    #[test]
    fn test_arbitration_reason_display() {
        let reason = ArbitrationReason::PrimarySuccess {
            layer: "bm25".to_string(),
            confidence: 0.85,
        };
        assert!(reason.to_string().contains("bm25"));
        assert!(reason.to_string().contains("0.85"));
    }

    #[test]
    fn test_payload_builder() {
        let payload = ExplainabilityPayload::builder()
            .intent(QueryIntent::Answer)
            .tier(CapabilityTier::Tier2Hybrid)
            .mode(ExecutionMode::Sequential)
            .candidate(CandidateInfo::used("bm25", 10, 0.8, 50))
            .candidate(CandidateInfo::skipped("topics", "Not enabled"))
            .arbitration(ArbitrationReason::PrimarySuccess {
                layer: "bm25".to_string(),
                confidence: 0.8,
            })
            .duration_ms(50)
            .build();

        assert_eq!(payload.intent, QueryIntent::Answer);
        assert_eq!(payload.tier_used, CapabilityTier::Tier2Hybrid);
        assert_eq!(payload.candidates.len(), 2);
    }

    #[test]
    fn test_payload_short_summary() {
        let payload = ExplainabilityPayload::builder()
            .tier(CapabilityTier::Tier4Keyword)
            .mode(ExecutionMode::Sequential)
            .candidate(CandidateInfo::used("bm25", 10, 0.8, 50))
            .duration_ms(50)
            .build();

        let summary = payload.short_summary();
        assert!(summary.contains("bm25"));
        assert!(summary.contains("Tier 4"));
    }

    #[test]
    fn test_payload_to_markdown() {
        let payload = ExplainabilityPayload::builder()
            .intent(QueryIntent::Locate)
            .tier(CapabilityTier::Tier4Keyword)
            .candidate(CandidateInfo::used("bm25", 5, 0.9, 30))
            .arbitration(ArbitrationReason::PrimarySuccess {
                layer: "bm25".to_string(),
                confidence: 0.9,
            })
            .evidence(vec!["grip-123".to_string()])
            .build();

        let md = payload.to_markdown();
        assert!(md.contains("## Retrieval Path"));
        assert!(md.contains("Locate"));
        assert!(md.contains("bm25"));
        assert!(md.contains("grip-123"));
    }
}
```

Update `crates/memory-retrieval/src/lib.rs`:
```rust
pub mod explainability;
pub use explainability::{ExplainabilityPayload, CandidateInfo, ArbitrationReason};
```
  </action>
  <verify>
```bash
cargo build -p memory-retrieval
cargo test -p memory-retrieval explainability
```
  </verify>
  <done>ExplainabilityPayload and related types exist; all tests pass</done>
</task>

<task type="auto">
  <name>Task 2: Create skill contract validation module</name>
  <files>crates/memory-retrieval/src/contract.rs</files>
  <action>
Create `crates/memory-retrieval/src/contract.rs`:

```rust
//! Skill contract validation.
//!
//! Per PRD Section 2.5 and 8, retrieval-capable skills MUST implement
//! certain patterns. This module validates compliance and generates
//! documentation patterns for SKILL.md files.

use memory_types::retrieval::{CapabilityTier, StopConditions};
use serde::{Deserialize, Serialize};

/// Contract requirements for retrieval-capable skills.
///
/// Per PRD Section 8, skills must:
/// 1. Capability Detection: Check status RPCs once per request
/// 2. Budget Enforcement: Respect max_rpc_calls, token_budget, timeout
/// 3. Fallback Discipline: Never hard-fail if agentic TOC search can run
/// 4. Explainability Payload: Report tier/mode, candidates, why winner won
/// 5. Evidence Handling: Include grip_ids/citations when returning facts
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SkillContract {
    /// Skill name for identification
    pub skill_name: String,
    /// Which retrieval layers this skill uses
    pub layers_used: Vec<String>,
    /// Whether skill performs capability detection
    pub capability_detection: bool,
    /// Whether skill enforces budget limits
    pub budget_enforcement: bool,
    /// Whether skill has fallback to agentic
    pub fallback_discipline: bool,
    /// Whether skill includes explainability payload
    pub explainability_enabled: bool,
    /// Whether skill includes grip_ids in responses
    pub evidence_handling: bool,
    /// Custom stop conditions (if different from defaults)
    pub custom_stop_conditions: Option<StopConditions>,
}

impl SkillContract {
    /// Create a new contract for a skill.
    pub fn new(skill_name: &str) -> Self {
        Self {
            skill_name: skill_name.to_string(),
            layers_used: vec!["agentic".to_string()], // Minimum
            capability_detection: false,
            budget_enforcement: false,
            fallback_discipline: false,
            explainability_enabled: false,
            evidence_handling: false,
            custom_stop_conditions: None,
        }
    }

    /// Mark that this skill uses specific layers.
    pub fn uses_layers(mut self, layers: Vec<&str>) -> Self {
        self.layers_used = layers.into_iter().map(String::from).collect();
        // Ensure agentic is always included
        if !self.layers_used.contains(&"agentic".to_string()) {
            self.layers_used.push("agentic".to_string());
        }
        self
    }

    /// Mark capability detection as implemented.
    pub fn with_capability_detection(mut self) -> Self {
        self.capability_detection = true;
        self
    }

    /// Mark budget enforcement as implemented.
    pub fn with_budget_enforcement(mut self) -> Self {
        self.budget_enforcement = true;
        self
    }

    /// Mark fallback discipline as implemented.
    pub fn with_fallback_discipline(mut self) -> Self {
        self.fallback_discipline = true;
        self
    }

    /// Mark explainability as implemented.
    pub fn with_explainability(mut self) -> Self {
        self.explainability_enabled = true;
        self
    }

    /// Mark evidence handling as implemented.
    pub fn with_evidence_handling(mut self) -> Self {
        self.evidence_handling = true;
        self
    }

    /// Set custom stop conditions.
    pub fn with_stop_conditions(mut self, conditions: StopConditions) -> Self {
        self.custom_stop_conditions = Some(conditions);
        self
    }

    /// Create a fully compliant contract (all requirements met).
    pub fn fully_compliant(skill_name: &str) -> Self {
        Self::new(skill_name)
            .with_capability_detection()
            .with_budget_enforcement()
            .with_fallback_discipline()
            .with_explainability()
            .with_evidence_handling()
    }
}

/// Result of contract validation.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ContractValidation {
    /// Whether the contract is valid
    pub valid: bool,
    /// Validation errors (if any)
    pub errors: Vec<String>,
    /// Validation warnings (if any)
    pub warnings: Vec<String>,
    /// Compliance score (0-100)
    pub compliance_score: u32,
}

impl ContractValidation {
    /// Check if validation passed with no errors.
    pub fn passed(&self) -> bool {
        self.valid && self.errors.is_empty()
    }
}

/// Validate a skill contract against PRD requirements.
pub fn validate_contract(contract: &SkillContract) -> ContractValidation {
    let mut errors = Vec::new();
    let mut warnings = Vec::new();
    let mut score = 0u32;

    // Requirement 1: Capability Detection (MUST)
    if contract.capability_detection {
        score += 20;
    } else {
        errors.push("Missing capability detection: Skills MUST check status RPCs before using layers".to_string());
    }

    // Requirement 2: Budget Enforcement (MUST)
    if contract.budget_enforcement {
        score += 20;
    } else {
        errors.push("Missing budget enforcement: Skills MUST respect max_rpc_calls, token_budget, timeout".to_string());
    }

    // Requirement 3: Fallback Discipline (MUST)
    if contract.fallback_discipline {
        score += 20;
    } else {
        errors.push("Missing fallback discipline: Skills MUST never hard-fail if agentic TOC search can run".to_string());
    }

    // Requirement 4: Explainability (MUST)
    if contract.explainability_enabled {
        score += 20;
    } else {
        errors.push("Missing explainability payload: Skills MUST report tier/mode, candidates, reasoning".to_string());
    }

    // Requirement 5: Evidence Handling (MUST)
    if contract.evidence_handling {
        score += 20;
    } else {
        errors.push("Missing evidence handling: Skills MUST include grip_ids/citations with facts".to_string());
    }

    // Check layers include agentic (MUST)
    if !contract.layers_used.contains(&"agentic".to_string()) {
        errors.push("Layers MUST include 'agentic' as guaranteed fallback".to_string());
    }

    // Warnings for optional best practices
    if contract.custom_stop_conditions.is_none() {
        warnings.push("No custom stop conditions defined - using defaults".to_string());
    }

    if contract.layers_used.len() == 1 && contract.layers_used[0] == "agentic" {
        warnings.push("Only using agentic layer - consider enabling accelerators for better performance".to_string());
    }

    let valid = errors.is_empty();

    ContractValidation {
        valid,
        errors,
        warnings,
        compliance_score: score,
    }
}

/// Generate SKILL.md documentation section for retrieval integration.
///
/// Per PRD Section 8, every skill that queries memory MUST document
/// its retrieval patterns.
pub fn generate_skill_md_section(contract: &SkillContract) -> String {
    let mut md = String::new();

    md.push_str("## Memory Integration\n\n");

    // Retrieval Layers Used
    md.push_str("### Retrieval Layers Used\n");
    let layers = [
        ("Topics", contract.layers_used.contains(&"topics".to_string())),
        ("Vector", contract.layers_used.contains(&"vector".to_string())),
        ("BM25", contract.layers_used.contains(&"bm25".to_string())),
        ("Hybrid", contract.layers_used.contains(&"hybrid".to_string())),
        ("Agentic TOC Search", contract.layers_used.contains(&"agentic".to_string())),
    ];

    for (name, used) in layers {
        let mark = if used { "[x]" } else { "[ ]" };
        let optional = if name == "Agentic TOC Search" { "(always available)" } else { "(optional)" };
        md.push_str(&format!("- {} {} {}\n", mark, name, optional));
    }

    // Fallback Behavior
    md.push_str("\n### Fallback Behavior\n");
    if contract.fallback_discipline {
        md.push_str("This skill implements graceful degradation:\n");
        md.push_str("1. Checks layer availability before each query\n");
        md.push_str("2. Falls back through: ");
        md.push_str(&contract.layers_used.join(" â†’ "));
        md.push_str("\n3. Never fails if agentic TOC search is available\n");
    } else {
        md.push_str("**WARNING:** Fallback discipline not implemented.\n");
    }

    // Stop Conditions
    md.push_str("\n### Stop Conditions\n");
    if let Some(ref conditions) = contract.custom_stop_conditions {
        md.push_str(&format!("- **max_depth:** {} levels\n", conditions.max_depth));
        md.push_str(&format!("- **max_nodes:** {} nodes\n", conditions.max_nodes_visited));
        md.push_str(&format!("- **max_rpc_calls:** {} calls\n", conditions.max_rpc_calls));
        md.push_str(&format!("- **timeout:** {}ms\n", conditions.timeout_ms));
        md.push_str(&format!("- **token_budget:** {} tokens\n", conditions.max_token_budget));
    } else {
        md.push_str("Uses default stop conditions.\n");
    }

    // Configuration
    md.push_str("\n### Configuration\n");
    md.push_str("Users can enable/disable layers this skill depends on:\n");
    md.push_str("```yaml\n");
    md.push_str("# memory-config.yaml\n");
    md.push_str("teleport:\n");
    md.push_str("  bm25:\n");
    md.push_str("    enabled: true  # Enable BM25 keyword search\n");
    md.push_str("  vector:\n");
    md.push_str("    enabled: true  # Enable vector semantic search\n");
    md.push_str("topics:\n");
    md.push_str("  enabled: false   # Disable topic graph (saves resources)\n");
    md.push_str("```\n");

    md
}

/// Anti-patterns that skills MUST NOT do (per PRD Section 2.5).
pub fn check_anti_patterns(contract: &SkillContract) -> Vec<String> {
    let mut violations = Vec::new();

    // MUST NOT: Assume any index is available without checking
    if !contract.capability_detection {
        violations.push("Anti-pattern: Assumes indexes are available without checking status RPCs".to_string());
    }

    // MUST NOT: Fail silently when a layer is unavailable
    if !contract.fallback_discipline {
        violations.push("Anti-pattern: May fail silently when layers are unavailable".to_string());
    }

    // MUST NOT: Ignore stop conditions
    if !contract.budget_enforcement {
        violations.push("Anti-pattern: May ignore stop conditions (depth, tokens, timeout)".to_string());
    }

    // MUST NOT: Return facts without provenance
    if !contract.evidence_handling {
        violations.push("Anti-pattern: Returns facts without grip links/provenance".to_string());
    }

    violations
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_contract_new() {
        let contract = SkillContract::new("test-skill");
        assert_eq!(contract.skill_name, "test-skill");
        assert!(contract.layers_used.contains(&"agentic".to_string()));
    }

    #[test]
    fn test_contract_fully_compliant() {
        let contract = SkillContract::fully_compliant("compliant-skill");
        assert!(contract.capability_detection);
        assert!(contract.budget_enforcement);
        assert!(contract.fallback_discipline);
        assert!(contract.explainability_enabled);
        assert!(contract.evidence_handling);
    }

    #[test]
    fn test_validate_contract_valid() {
        let contract = SkillContract::fully_compliant("test");
        let validation = validate_contract(&contract);

        assert!(validation.valid);
        assert!(validation.errors.is_empty());
        assert_eq!(validation.compliance_score, 100);
    }

    #[test]
    fn test_validate_contract_invalid() {
        let contract = SkillContract::new("incomplete");
        let validation = validate_contract(&contract);

        assert!(!validation.valid);
        assert_eq!(validation.errors.len(), 5); // All 5 requirements missing
        assert_eq!(validation.compliance_score, 0);
    }

    #[test]
    fn test_validate_contract_partial() {
        let contract = SkillContract::new("partial")
            .with_capability_detection()
            .with_fallback_discipline();

        let validation = validate_contract(&contract);

        assert!(!validation.valid);
        assert_eq!(validation.compliance_score, 40); // 2 of 5 requirements
    }

    #[test]
    fn test_generate_skill_md_section() {
        let contract = SkillContract::fully_compliant("test")
            .uses_layers(vec!["bm25", "vector", "agentic"]);

        let md = generate_skill_md_section(&contract);

        assert!(md.contains("## Memory Integration"));
        assert!(md.contains("[x] BM25"));
        assert!(md.contains("[x] Vector"));
        assert!(md.contains("[x] Agentic TOC Search"));
        assert!(md.contains("### Fallback Behavior"));
    }

    #[test]
    fn test_check_anti_patterns() {
        let bad_contract = SkillContract::new("bad-skill");
        let violations = check_anti_patterns(&bad_contract);

        assert_eq!(violations.len(), 4);
        assert!(violations.iter().any(|v| v.contains("Assumes indexes")));
    }

    #[test]
    fn test_check_anti_patterns_compliant() {
        let good_contract = SkillContract::fully_compliant("good-skill");
        let violations = check_anti_patterns(&good_contract);

        assert!(violations.is_empty());
    }
}
```

Update `crates/memory-retrieval/src/lib.rs`:
```rust
pub mod contract;
pub use contract::{SkillContract, ContractValidation, validate_contract, generate_skill_md_section};
```
  </action>
  <verify>
```bash
cargo build -p memory-retrieval
cargo test -p memory-retrieval contract
```
  </verify>
  <done>SkillContract and validation exist; generate_skill_md_section produces SKILL.md documentation; all tests pass</done>
</task>

</tasks>

<verification>
After all tasks complete:

```bash
# Full workspace build
cargo build --workspace

# All memory-retrieval tests
cargo test -p memory-retrieval --all-features

# Clippy check
cargo clippy -p memory-retrieval -- -D warnings

# Doc tests
cargo test -p memory-retrieval --doc
```
</verification>

<success_criteria>
1. ExplainabilityPayload reports tier, method, candidates, arbitration reason
2. CandidateInfo tracks used/skipped/available-unused layers
3. ArbitrationReason explains why decisions were made
4. SkillContract validates capability detection, budget, fallback, explainability, evidence
5. validate_contract() returns errors for non-compliant skills
6. generate_skill_md_section() produces valid SKILL.md documentation
7. check_anti_patterns() identifies PRD violations
8. All unit tests pass
9. Clippy passes with no warnings
</success_criteria>

<output>
After completion, create `.planning/phases/17-agent-retrieval-policy/17-05-SUMMARY.md`
</output>
