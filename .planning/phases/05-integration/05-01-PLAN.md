# Plan 05-01: Client Library and Hook Mapping

## Goal

Create a client library that hook handlers can use to call IngestEvent RPC, with event type mapping from hook events to memory events.

## Requirements Covered

- **HOOK-02**: Hook handlers call daemon's IngestEvent RPC
- **HOOK-03**: Event types map 1:1 from hook events

## Tasks

### Task 1: Create memory-client Crate

**File: crates/memory-client/Cargo.toml**

```toml
[package]
name = "memory-client"
version = "0.1.0"
edition = "2021"
description = "Client library for Agent Memory daemon"

[dependencies]
memory-service = { path = "../memory-service" }
memory-types = { path = "../memory-types" }
tonic = { workspace = true }
tokio = { workspace = true }
thiserror = { workspace = true }
tracing = { workspace = true }
```

**File: crates/memory-client/src/lib.rs**

```rust
//! Client library for Agent Memory daemon.
//!
//! Per HOOK-02: Hook handlers call daemon's IngestEvent RPC.

pub mod client;
pub mod error;
pub mod hook_mapping;

pub use client::MemoryClient;
pub use error::ClientError;
pub use hook_mapping::{HookEvent, HookEventType, map_hook_event};
```

### Task 2: Implement MemoryClient

**File: crates/memory-client/src/client.rs**

```rust
use memory_service::proto::{
    memory_service_client::MemoryServiceClient,
    IngestEventRequest,
};
use memory_types::Event;
use tonic::transport::Channel;

use crate::error::ClientError;

pub struct MemoryClient {
    inner: MemoryServiceClient<Channel>,
}

impl MemoryClient {
    pub async fn connect(endpoint: &str) -> Result<Self, ClientError> {
        let inner = MemoryServiceClient::connect(endpoint.to_string())
            .await
            .map_err(ClientError::Connection)?;
        Ok(Self { inner })
    }

    pub async fn ingest(&mut self, event: Event) -> Result<String, ClientError> {
        // Convert event to proto and call RPC
    }
}
```

### Task 3: Implement Hook Event Mapping

**File: crates/memory-client/src/hook_mapping.rs**

```rust
use memory_types::{Event, EventType, EventRole};

#[derive(Debug, Clone)]
pub enum HookEventType {
    SessionStart,
    UserPromptSubmit,
    AssistantResponse,
    ToolUse,
    Stop,
}

#[derive(Debug, Clone)]
pub struct HookEvent {
    pub session_id: String,
    pub event_type: HookEventType,
    pub content: String,
    pub timestamp: Option<i64>,
    pub tool_name: Option<String>,
}

pub fn map_hook_event(hook: HookEvent) -> Event {
    let event_type = match hook.event_type {
        HookEventType::SessionStart => EventType::SessionStart,
        HookEventType::UserPromptSubmit => EventType::UserMessage,
        HookEventType::AssistantResponse => EventType::AssistantMessage,
        HookEventType::ToolUse => EventType::ToolUse,
        HookEventType::Stop => EventType::SessionEnd,
    };

    let role = match hook.event_type {
        HookEventType::UserPromptSubmit => EventRole::User,
        HookEventType::AssistantResponse => EventRole::Assistant,
        HookEventType::ToolUse => EventRole::System,
        _ => EventRole::System,
    };

    Event::new(hook.session_id, event_type, role, hook.content)
        .with_timestamp(hook.timestamp.map(|ts|
            chrono::DateTime::from_timestamp_millis(ts).unwrap_or_default()
        ).unwrap_or_else(chrono::Utc::now))
}
```

### Task 4: Implement ClientError

**File: crates/memory-client/src/error.rs**

```rust
use thiserror::Error;

#[derive(Error, Debug)]
pub enum ClientError {
    #[error("Connection failed: {0}")]
    Connection(#[from] tonic::transport::Error),

    #[error("RPC failed: {0}")]
    Rpc(#[from] tonic::Status),

    #[error("Serialization failed: {0}")]
    Serialization(String),
}
```

### Task 5: Update Workspace Cargo.toml

Add memory-client to workspace members.

### Task 6: Add Tests

Test client connection (mock server), event mapping.

## Acceptance Criteria

- [ ] memory-client crate compiles
- [ ] MemoryClient can connect to daemon endpoint
- [ ] ingest() method sends events via gRPC
- [ ] HookEvent maps to Event with correct types
- [ ] Tests pass for event mapping

## Dependencies

- Phase 4 complete (IngestEvent RPC exists)

---
*Plan created: 2026-01-30*
