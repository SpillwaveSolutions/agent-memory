---
phase: 18-agent-tagging-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - proto/memory.proto
  - crates/memory-types/src/event.rs
autonomous: true

must_haves:
  truths:
    - "Events can be ingested with optional agent identifier"
    - "Old events without agent field deserialize correctly"
    - "Proto Event message includes optional agent field"
  artifacts:
    - path: "proto/memory.proto"
      provides: "Event message with agent field"
      contains: "optional string agent"
    - path: "crates/memory-types/src/event.rs"
      provides: "Event struct with agent field"
      contains: "pub agent: Option<String>"
  key_links:
    - from: "crates/memory-types/src/event.rs"
      to: "proto/memory.proto"
      via: "Proto code generation"
      pattern: "agent.*Option<String>"
---

<objective>
Add the `agent` field to Event in both proto and Rust types.

Purpose: Enable tracking which AI agent (Claude, OpenCode, Gemini, Copilot) produced each event. This is the foundational change for multi-agent memory unification.

Output: Updated proto schema and Rust Event struct with backward-compatible agent field.
</objective>

<execution_context>
@/Users/richardhightower/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardhightower/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-agent-tagging-infrastructure/18-RESEARCH.md

# Source files to modify
@proto/memory.proto
@crates/memory-types/src/event.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add agent field to Event proto message</name>
  <files>proto/memory.proto</files>
  <action>
Add optional agent field to the Event message in proto/memory.proto.

Location: Find the Event message (around line 151) and add after field 7 (metadata):

```protobuf
// Phase 18: Agent identifier for multi-agent memory
// Common values: "claude", "opencode", "gemini", "copilot"
// Empty/absent means legacy event or unknown source
optional string agent = 8;
```

Use `optional` keyword per proto3 semantics for fields that may be absent.
Field number 8 is the next available after metadata (7).

Do NOT modify any other messages - only the Event message.
  </action>
  <verify>
Run `cargo build -p memory-service` to verify proto compiles and generates Rust code.
Check generated code in `target/debug/build/memory-service-*/out/memory.rs` contains `agent` field.
  </verify>
  <done>
Event message in proto/memory.proto has optional string agent field at position 8.
Proto compiles without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add agent field to Rust Event struct</name>
  <files>crates/memory-types/src/event.rs</files>
  <action>
Add agent field to the Event struct in crates/memory-types/src/event.rs.

Follow the Phase 16 pattern for backward compatibility (see salience fields in TocNode).

1. Add the field to Event struct after metadata:

```rust
/// Agent that produced this event.
///
/// Common values: "claude", "opencode", "gemini", "copilot".
/// Default: None for pre-phase-18 events (backward compatible).
#[serde(default)]
pub agent: Option<String>,
```

2. Update Event::new() to initialize agent to None:
In the Self { ... } block, add: `agent: None,`

3. Add builder method after with_metadata():

```rust
/// Set the agent identifier for this event.
pub fn with_agent(mut self, agent: impl Into<String>) -> Self {
    self.agent = Some(agent.into());
    self
}
```

4. Add backward compatibility test:

```rust
#[test]
fn test_event_backward_compat_no_agent() {
    // Simulate pre-phase-18 serialized event (no agent field)
    let v200_json = r#"{
        "event_id": "01HN4QXKN6YWXVKZ3JMHP4BCDE",
        "session_id": "session-123",
        "timestamp": 1704067200000,
        "event_type": "user_message",
        "role": "user",
        "text": "Hello, world!"
    }"#;

    let event: Event = serde_json::from_str(v200_json).unwrap();

    // Verify default agent is None
    assert!(event.agent.is_none());
    // Verify other fields loaded correctly
    assert_eq!(event.event_id, "01HN4QXKN6YWXVKZ3JMHP4BCDE");
}

#[test]
fn test_event_with_agent() {
    let event = Event::new(
        "01HN4QXKN6YWXVKZ3JMHP4BCDE".to_string(),
        "session-123".to_string(),
        Utc::now(),
        EventType::UserMessage,
        EventRole::User,
        "Hello, world!".to_string(),
    )
    .with_agent("claude");

    assert_eq!(event.agent, Some("claude".to_string()));
}
```
  </action>
  <verify>
Run `cargo test -p memory-types` - all tests pass including new backward compat tests.
Run `cargo clippy -p memory-types` - no warnings.
  </verify>
  <done>
Event struct has agent: Option<String> field with serde(default).
with_agent() builder method exists.
Backward compatibility test passes for events without agent field.
Test for events with agent field passes.
  </done>
</task>

</tasks>

<verification>
1. `cargo build --workspace` compiles successfully
2. `cargo test -p memory-types` passes all tests
3. `cargo clippy -p memory-types` has no warnings
4. Proto regenerates without errors on next memory-service build
</verification>

<success_criteria>
- Event proto message has `optional string agent = 8`
- Event Rust struct has `agent: Option<String>` with `#[serde(default)]`
- Old events without agent field deserialize with agent = None
- New events can be created with agent identifier using with_agent()
- All existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/18-agent-tagging-infrastructure/18-01-SUMMARY.md`
</output>
