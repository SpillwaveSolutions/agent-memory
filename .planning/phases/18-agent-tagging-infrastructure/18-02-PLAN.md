---
phase: 18-agent-tagging-infrastructure
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/memory-adapters/Cargo.toml
  - crates/memory-adapters/src/lib.rs
  - crates/memory-adapters/src/adapter.rs
  - crates/memory-adapters/src/error.rs
  - crates/memory-adapters/src/config.rs
  - Cargo.toml
autonomous: true

must_haves:
  truths:
    - "Adapter trait defines interface for agent-specific adapters"
    - "Error types support adapter operations"
    - "Configuration types support adapter-specific settings"
    - "Crate is part of workspace and builds successfully"
  artifacts:
    - path: "crates/memory-adapters/Cargo.toml"
      provides: "Crate manifest with dependencies"
      contains: "[package]"
    - path: "crates/memory-adapters/src/adapter.rs"
      provides: "AgentAdapter trait definition"
      contains: "pub trait AgentAdapter"
    - path: "crates/memory-adapters/src/error.rs"
      provides: "AdapterError type"
      contains: "pub enum AdapterError"
  key_links:
    - from: "crates/memory-adapters/src/adapter.rs"
      to: "memory-types"
      via: "Event import"
      pattern: "use memory_types::Event"
---

<objective>
Create the memory-adapters crate with AgentAdapter trait for multi-agent SDK.

Purpose: Define a common interface that all agent adapters (Claude, OpenCode, Gemini, Copilot) will implement. This SDK enables extending Agent Memory to new AI agent CLIs.

Output: New memory-adapters crate with AgentAdapter trait, error types, and configuration types.
</objective>

<execution_context>
@/Users/richardhightower/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardhightower/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-agent-tagging-infrastructure/18-RESEARCH.md

# Pattern reference
@crates/memory-retrieval/src/executor.rs (LayerExecutor trait pattern)
@crates/memory-types/src/lib.rs (crate structure pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create memory-adapters crate structure</name>
  <files>
crates/memory-adapters/Cargo.toml
crates/memory-adapters/src/lib.rs
Cargo.toml
  </files>
  <action>
Create the memory-adapters crate following workspace patterns.

1. Create directory: `crates/memory-adapters/src/`

2. Create `crates/memory-adapters/Cargo.toml`:

```toml
[package]
name = "memory-adapters"
version = "0.1.0"
edition = "2021"
description = "Agent adapter SDK for multi-agent memory integration"
license = "MIT"

[dependencies]
async-trait = "0.1"
memory-types = { path = "../memory-types" }
serde = { version = "1.0", features = ["derive"] }
thiserror = "2.0"
tracing = "0.1"

[dev-dependencies]
tokio = { version = "1", features = ["rt-multi-thread", "macros"] }
```

3. Create `crates/memory-adapters/src/lib.rs`:

```rust
//! # memory-adapters
//!
//! Agent adapter SDK for multi-agent memory integration.
//!
//! This crate provides the foundation for building adapters that connect
//! various AI agent CLIs (OpenCode, Gemini CLI, Copilot CLI) to Agent Memory.
//!
//! ## Core Components
//!
//! - [`AgentAdapter`]: Trait that all adapters must implement
//! - [`AdapterConfig`]: Configuration for adapter-specific settings
//! - [`AdapterError`]: Error types for adapter operations
//! - [`RawEvent`]: Raw event data before normalization
//!
//! ## Usage
//!
//! Implement the `AgentAdapter` trait for your agent:
//!
//! ```rust,ignore
//! use memory_adapters::{AgentAdapter, AdapterConfig, AdapterError, RawEvent};
//! use memory_types::Event;
//!
//! struct MyAgentAdapter;
//!
//! #[async_trait::async_trait]
//! impl AgentAdapter for MyAgentAdapter {
//!     fn agent_id(&self) -> &str { "myagent" }
//!     fn display_name(&self) -> &str { "My Agent CLI" }
//!     fn normalize(&self, raw: RawEvent) -> Result<Event, AdapterError> {
//!         // Convert raw event to unified format
//!         todo!()
//!     }
//!     fn load_config(&self, path: Option<&std::path::Path>) -> Result<AdapterConfig, AdapterError> {
//!         Ok(AdapterConfig::default())
//!     }
//! }
//! ```

pub mod adapter;
pub mod config;
pub mod error;

// Re-export main types at crate root
pub use adapter::{AgentAdapter, RawEvent};
pub use config::AdapterConfig;
pub use error::AdapterError;
```

4. Add to workspace in root `Cargo.toml`:

In the `[workspace]` members list, add `"crates/memory-adapters"` (maintain alphabetical order within the crates/* entries).
  </action>
  <verify>
Run `cargo build -p memory-adapters` - compiles (will have warnings for empty modules initially).
Check workspace with `cargo metadata --no-deps | grep memory-adapters` - appears in workspace.
  </verify>
  <done>
Crate structure created with Cargo.toml and lib.rs.
Crate added to workspace members.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement error and config types</name>
  <files>
crates/memory-adapters/src/error.rs
crates/memory-adapters/src/config.rs
  </files>
  <action>
Create error and configuration types.

1. Create `crates/memory-adapters/src/error.rs`:

```rust
//! Error types for adapter operations.

use std::path::PathBuf;
use thiserror::Error;

/// Errors that can occur during adapter operations.
#[derive(Error, Debug)]
pub enum AdapterError {
    /// Configuration file not found or invalid.
    #[error("Configuration error at {path:?}: {message}")]
    Config {
        path: Option<PathBuf>,
        message: String,
    },

    /// Failed to normalize event from raw format.
    #[error("Normalization error: {0}")]
    Normalize(String),

    /// IO error during adapter operation.
    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),

    /// Failed to parse event data.
    #[error("Parse error: {0}")]
    Parse(String),

    /// Agent detection failed.
    #[error("Detection error: {0}")]
    Detection(String),
}

impl AdapterError {
    /// Create a configuration error.
    pub fn config(message: impl Into<String>) -> Self {
        Self::Config {
            path: None,
            message: message.into(),
        }
    }

    /// Create a configuration error with path context.
    pub fn config_at(path: impl Into<PathBuf>, message: impl Into<String>) -> Self {
        Self::Config {
            path: Some(path.into()),
            message: message.into(),
        }
    }

    /// Create a normalization error.
    pub fn normalize(message: impl Into<String>) -> Self {
        Self::Normalize(message.into())
    }

    /// Create a parse error.
    pub fn parse(message: impl Into<String>) -> Self {
        Self::Parse(message.into())
    }

    /// Create a detection error.
    pub fn detection(message: impl Into<String>) -> Self {
        Self::Detection(message.into())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_error_display() {
        let err = AdapterError::config("invalid format");
        assert!(err.to_string().contains("Configuration error"));
        assert!(err.to_string().contains("invalid format"));
    }

    #[test]
    fn test_error_with_path() {
        let err = AdapterError::config_at("/path/to/config.toml", "missing field");
        assert!(err.to_string().contains("/path/to/config.toml"));
    }
}
```

2. Create `crates/memory-adapters/src/config.rs`:

```rust
//! Configuration types for agent adapters.

use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::path::PathBuf;

/// Configuration for an agent adapter.
///
/// Each adapter can have its own settings in addition to common fields.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct AdapterConfig {
    /// Path to agent's event log or history file.
    ///
    /// This is where the adapter reads raw events from.
    #[serde(default)]
    pub event_source_path: Option<PathBuf>,

    /// Path to output/ingest events.
    ///
    /// Usually the daemon's gRPC endpoint or a file path.
    #[serde(default)]
    pub ingest_target: Option<String>,

    /// Whether this adapter is enabled.
    #[serde(default = "default_enabled")]
    pub enabled: bool,

    /// Additional agent-specific settings.
    ///
    /// Use this for settings that don't fit the common fields.
    #[serde(default)]
    pub settings: HashMap<String, String>,
}

fn default_enabled() -> bool {
    true
}

impl AdapterConfig {
    /// Create a new config with the given event source path.
    pub fn with_event_source(path: impl Into<PathBuf>) -> Self {
        Self {
            event_source_path: Some(path.into()),
            enabled: true,
            ..Default::default()
        }
    }

    /// Set the ingest target.
    pub fn with_ingest_target(mut self, target: impl Into<String>) -> Self {
        self.ingest_target = Some(target.into());
        self
    }

    /// Add a custom setting.
    pub fn with_setting(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
        self.settings.insert(key.into(), value.into());
        self
    }

    /// Get a custom setting value.
    pub fn get_setting(&self, key: &str) -> Option<&str> {
        self.settings.get(key).map(|s| s.as_str())
    }

    /// Check if the adapter is enabled.
    pub fn is_enabled(&self) -> bool {
        self.enabled
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_config_default() {
        let config = AdapterConfig::default();
        assert!(config.enabled);
        assert!(config.event_source_path.is_none());
        assert!(config.settings.is_empty());
    }

    #[test]
    fn test_config_builder() {
        let config = AdapterConfig::with_event_source("/var/log/agent.log")
            .with_ingest_target("http://localhost:50051")
            .with_setting("poll_interval_ms", "1000");

        assert_eq!(
            config.event_source_path,
            Some(PathBuf::from("/var/log/agent.log"))
        );
        assert_eq!(
            config.ingest_target,
            Some("http://localhost:50051".to_string())
        );
        assert_eq!(config.get_setting("poll_interval_ms"), Some("1000"));
    }

    #[test]
    fn test_config_serialization() {
        let config = AdapterConfig::with_event_source("/tmp/events.log");
        let json = serde_json::to_string(&config).unwrap();
        let parsed: AdapterConfig = serde_json::from_str(&json).unwrap();
        assert_eq!(config.event_source_path, parsed.event_source_path);
    }
}
```
  </action>
  <verify>
Run `cargo test -p memory-adapters` - tests pass.
Run `cargo clippy -p memory-adapters` - no warnings.
  </verify>
  <done>
AdapterError enum with Config, Normalize, Io, Parse, Detection variants.
AdapterConfig struct with event_source_path, ingest_target, enabled, settings.
Builder methods and tests for both types.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement AgentAdapter trait</name>
  <files>crates/memory-adapters/src/adapter.rs</files>
  <action>
Create the AgentAdapter trait following the LayerExecutor pattern from memory-retrieval.

Create `crates/memory-adapters/src/adapter.rs`:

```rust
//! Agent adapter trait definition.
//!
//! The `AgentAdapter` trait defines the interface that all agent-specific
//! adapters must implement to integrate with Agent Memory.

use async_trait::async_trait;
use std::collections::HashMap;
use std::path::Path;

use memory_types::Event;

use crate::config::AdapterConfig;
use crate::error::AdapterError;

/// Raw event data before normalization.
///
/// This represents event data in the agent's native format,
/// before being converted to the unified Event type.
#[derive(Debug, Clone)]
pub struct RawEvent {
    /// Unique identifier from the source agent.
    pub id: String,

    /// Timestamp in milliseconds since Unix epoch.
    pub timestamp_ms: i64,

    /// Event content/text.
    pub content: String,

    /// Event type in the source agent's terminology.
    pub event_type: String,

    /// Role identifier from the source agent.
    pub role: String,

    /// Session identifier from the source agent.
    pub session_id: String,

    /// Additional metadata from the source agent.
    pub metadata: HashMap<String, String>,
}

impl RawEvent {
    /// Create a new raw event.
    pub fn new(
        id: impl Into<String>,
        timestamp_ms: i64,
        content: impl Into<String>,
    ) -> Self {
        Self {
            id: id.into(),
            timestamp_ms,
            content: content.into(),
            event_type: String::new(),
            role: String::new(),
            session_id: String::new(),
            metadata: HashMap::new(),
        }
    }

    /// Set the event type.
    pub fn with_event_type(mut self, event_type: impl Into<String>) -> Self {
        self.event_type = event_type.into();
        self
    }

    /// Set the role.
    pub fn with_role(mut self, role: impl Into<String>) -> Self {
        self.role = role.into();
        self
    }

    /// Set the session ID.
    pub fn with_session_id(mut self, session_id: impl Into<String>) -> Self {
        self.session_id = session_id.into();
        self
    }

    /// Add metadata.
    pub fn with_metadata(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
        self.metadata.insert(key.into(), value.into());
        self
    }
}

/// Trait for agent-specific adapters.
///
/// Implement this trait to add support for a new AI agent CLI.
///
/// # Agent Identifier
///
/// The `agent_id()` method should return a lowercase, stable identifier
/// that uniquely identifies the agent. This identifier is stored with
/// events and used for filtering queries.
///
/// Canonical agent IDs:
/// - `"claude"` - Claude Code
/// - `"opencode"` - OpenCode CLI
/// - `"gemini"` - Gemini CLI
/// - `"copilot"` - GitHub Copilot CLI
///
/// # Example
///
/// ```rust,ignore
/// use memory_adapters::{AgentAdapter, AdapterConfig, AdapterError, RawEvent};
/// use memory_types::{Event, EventType, EventRole};
/// use chrono::{DateTime, Utc};
///
/// struct OpenCodeAdapter;
///
/// #[async_trait::async_trait]
/// impl AgentAdapter for OpenCodeAdapter {
///     fn agent_id(&self) -> &str {
///         "opencode"
///     }
///
///     fn display_name(&self) -> &str {
///         "OpenCode CLI"
///     }
///
///     fn normalize(&self, raw: RawEvent) -> Result<Event, AdapterError> {
///         // Convert OpenCode-specific event to unified format
///         let timestamp = DateTime::from_timestamp_millis(raw.timestamp_ms)
///             .unwrap_or_else(Utc::now);
///
///         Ok(Event::new(
///             raw.id,
///             raw.session_id,
///             timestamp,
///             EventType::UserMessage,
///             EventRole::User,
///             raw.content,
///         ).with_agent(self.agent_id()))
///     }
///
///     fn load_config(&self, path: Option<&std::path::Path>) -> Result<AdapterConfig, AdapterError> {
///         // Load from ~/.config/opencode/adapter.toml or default
///         Ok(AdapterConfig::default())
///     }
/// }
/// ```
#[async_trait]
pub trait AgentAdapter: Send + Sync {
    /// Canonical agent identifier (lowercase, e.g., "claude", "opencode").
    ///
    /// This identifier is stored with events and used for query filtering.
    /// It should be stable across versions.
    fn agent_id(&self) -> &str;

    /// Human-readable agent name (e.g., "Claude Code", "OpenCode CLI").
    ///
    /// Used for display purposes in logs and status messages.
    fn display_name(&self) -> &str;

    /// Convert raw event to unified Event format.
    ///
    /// This method is responsible for:
    /// 1. Mapping event types to unified EventType enum
    /// 2. Mapping roles to unified EventRole enum
    /// 3. Extracting/generating event IDs
    /// 4. Setting the agent identifier via with_agent()
    ///
    /// # Errors
    ///
    /// Returns `AdapterError::Normalize` if the raw event cannot be converted.
    fn normalize(&self, raw: RawEvent) -> Result<Event, AdapterError>;

    /// Load adapter configuration from path or default location.
    ///
    /// If `path` is None, use the agent's default config location.
    ///
    /// # Errors
    ///
    /// Returns `AdapterError::Config` if configuration cannot be loaded.
    fn load_config(&self, path: Option<&Path>) -> Result<AdapterConfig, AdapterError>;

    /// Attempt to auto-detect this adapter from environment.
    ///
    /// Override this to enable automatic adapter selection based on
    /// environment variables, running processes, or other signals.
    ///
    /// Default implementation returns false (explicit selection required).
    fn detect(&self) -> bool {
        false
    }

    /// Check if the adapter is available and properly configured.
    ///
    /// Override this for adapters that require external services or binaries.
    ///
    /// Default implementation returns true.
    fn is_available(&self) -> bool {
        true
    }

    /// Normalize agent identifier to lowercase.
    ///
    /// This helper ensures consistent agent IDs across the system.
    fn normalize_agent_id(id: &str) -> String {
        id.to_lowercase().trim().to_string()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use memory_types::{EventRole, EventType};

    // Mock adapter for testing
    struct MockAdapter;

    #[async_trait]
    impl AgentAdapter for MockAdapter {
        fn agent_id(&self) -> &str {
            "mock"
        }

        fn display_name(&self) -> &str {
            "Mock Agent"
        }

        fn normalize(&self, raw: RawEvent) -> Result<Event, AdapterError> {
            use chrono::{DateTime, Utc};

            let timestamp = DateTime::from_timestamp_millis(raw.timestamp_ms)
                .unwrap_or_else(Utc::now);

            Ok(Event::new(
                raw.id,
                raw.session_id,
                timestamp,
                EventType::UserMessage,
                EventRole::User,
                raw.content,
            ).with_agent(self.agent_id()))
        }

        fn load_config(&self, _path: Option<&Path>) -> Result<AdapterConfig, AdapterError> {
            Ok(AdapterConfig::default())
        }
    }

    #[test]
    fn test_raw_event_builder() {
        let raw = RawEvent::new("evt-1", 1704067200000, "Hello")
            .with_event_type("user_message")
            .with_role("user")
            .with_session_id("session-123")
            .with_metadata("tool", "Read");

        assert_eq!(raw.id, "evt-1");
        assert_eq!(raw.timestamp_ms, 1704067200000);
        assert_eq!(raw.content, "Hello");
        assert_eq!(raw.event_type, "user_message");
        assert_eq!(raw.role, "user");
        assert_eq!(raw.session_id, "session-123");
        assert_eq!(raw.metadata.get("tool"), Some(&"Read".to_string()));
    }

    #[test]
    fn test_mock_adapter_normalize() {
        let adapter = MockAdapter;
        let raw = RawEvent::new("evt-1", 1704067200000, "Test message")
            .with_session_id("session-123");

        let event = adapter.normalize(raw).unwrap();

        assert_eq!(event.event_id, "evt-1");
        assert_eq!(event.session_id, "session-123");
        assert_eq!(event.text, "Test message");
        assert_eq!(event.agent, Some("mock".to_string()));
    }

    #[test]
    fn test_normalize_agent_id() {
        assert_eq!(MockAdapter::normalize_agent_id("Claude"), "claude");
        assert_eq!(MockAdapter::normalize_agent_id("  OpenCode  "), "opencode");
        assert_eq!(MockAdapter::normalize_agent_id("GEMINI"), "gemini");
    }

    #[test]
    fn test_adapter_default_methods() {
        let adapter = MockAdapter;
        assert!(!adapter.detect());
        assert!(adapter.is_available());
    }
}
```
  </action>
  <verify>
Run `cargo test -p memory-adapters` - all tests pass.
Run `cargo clippy -p memory-adapters` - no warnings.
Run `cargo doc -p memory-adapters` - documentation builds.
  </verify>
  <done>
AgentAdapter trait with agent_id(), display_name(), normalize(), load_config().
Default implementations for detect() and is_available().
RawEvent struct with builder pattern.
Tests for adapter trait and raw events.
Documentation with usage examples.
  </done>
</task>

</tasks>

<verification>
1. `cargo build -p memory-adapters` compiles successfully
2. `cargo test -p memory-adapters` passes all tests
3. `cargo clippy -p memory-adapters` has no warnings
4. `cargo doc -p memory-adapters` generates documentation
5. Crate appears in `cargo metadata` workspace members
</verification>

<success_criteria>
- memory-adapters crate exists in workspace
- AgentAdapter trait defines normalize(), load_config(), agent_id(), display_name()
- RawEvent struct provides builder pattern for raw event data
- AdapterError enum covers Config, Normalize, Io, Parse, Detection errors
- AdapterConfig struct supports event_source_path, ingest_target, settings
- All types have tests and documentation
</success_criteria>

<output>
After completion, create `.planning/phases/18-agent-tagging-infrastructure/18-02-SUMMARY.md`
</output>
