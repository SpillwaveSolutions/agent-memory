---
phase: 18-agent-tagging-infrastructure
plan: 04
type: execute
wave: 3
depends_on:
  - 18-01
  - 18-02
  - 18-03
files_modified:
  - crates/memory-service/src/ingest.rs
  - crates/memory-retrieval/src/types.rs
  - proto/memory.proto
autonomous: true

must_haves:
  truths:
    - "Ingest handler extracts agent from proto Event"
    - "RouteQueryRequest includes optional agent filter"
    - "RetrievalResult includes source agent"
    - "Agent field flows through ingest to storage"
  artifacts:
    - path: "proto/memory.proto"
      provides: "RouteQueryRequest with agent filter"
      contains: "optional string agent_filter"
    - path: "crates/memory-service/src/ingest.rs"
      provides: "Ingest handler with agent support"
      contains: "agent"
  key_links:
    - from: "proto/memory.proto RouteQueryRequest"
      to: "retrieval filtering"
      via: "agent_filter field"
      pattern: "agent_filter"
---

<objective>
Wire up agent field through ingest and query paths.

Purpose: Complete the data flow so events are ingested with agent tags and queries can filter by agent.

Output: Updated ingest handler, proto query messages with agent filter, retrieval types with agent support.
</objective>

<execution_context>
@/Users/richardhightower/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardhightower/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-agent-tagging-infrastructure/18-RESEARCH.md
@.planning/phases/18-agent-tagging-infrastructure/18-01-SUMMARY.md

# Source files
@proto/memory.proto
@crates/memory-retrieval/src/types.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add agent filter to proto query messages</name>
  <files>proto/memory.proto</files>
  <action>
Add agent_filter field to query request messages.

1. Add to RouteQueryRequest (around line 907):

After the `limit` field, add:
```protobuf
// Phase 18: Filter results by agent (e.g., "claude", "opencode")
// Empty/absent means return all agents
optional string agent_filter = 6;
```

2. Add to TeleportSearchRequest (around line 504):

After the `limit` field, add:
```protobuf
// Phase 18: Filter results by agent
optional string agent_filter = 4;
```

3. Add to VectorTeleportRequest (around line 554):

After the `target` field, add:
```protobuf
// Phase 18: Filter results by agent
optional string agent_filter = 6;
```

4. Add to HybridSearchRequest (around line 598):

After the `target` field, add:
```protobuf
// Phase 18: Filter results by agent
optional string agent_filter = 8;
```

5. Add agent to RetrievalResult (around line 919):

After the `metadata` field, add:
```protobuf
// Phase 18: Source agent that produced this result
optional string agent = 7;
```

Note: Use next available field numbers in each message. Verify numbers don't conflict with existing fields.
  </action>
  <verify>
Run `cargo build -p memory-service` to verify proto compiles.
Check generated code contains agent_filter fields in request messages.
Check generated code contains agent field in RetrievalResult.
  </verify>
  <done>
RouteQueryRequest has optional string agent_filter.
TeleportSearchRequest has optional string agent_filter.
VectorTeleportRequest has optional string agent_filter.
HybridSearchRequest has optional string agent_filter.
RetrievalResult has optional string agent.
Proto compiles without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update retrieval types with agent support</name>
  <files>crates/memory-retrieval/src/types.rs</files>
  <action>
Add agent field to SearchResult and StopConditions types.

1. Read the current types.rs to understand the structure.

2. Add agent field to SearchResult struct (if it exists in this file) or document that the proto-generated RetrievalResult handles this.

3. Add agent_filter to StopConditions struct:

Find StopConditions struct and add:
```rust
/// Filter results to a specific agent.
/// None means return all agents.
#[serde(default)]
pub agent_filter: Option<String>,
```

4. Add builder method to StopConditions:

```rust
/// Set agent filter.
pub fn with_agent_filter(mut self, agent: impl Into<String>) -> Self {
    self.agent_filter = Some(agent.into().to_lowercase());
    self
}
```

5. Ensure the default implementation includes agent_filter: None.

6. Add test:

```rust
#[test]
fn test_stop_conditions_agent_filter() {
    let conditions = StopConditions::default()
        .with_agent_filter("claude");

    assert_eq!(conditions.agent_filter, Some("claude".to_string()));
}
```

Note: If SearchResult is in executor.rs, that was already read. The key change is StopConditions which controls query behavior.
  </action>
  <verify>
Run `cargo test -p memory-retrieval` - all tests pass.
Run `cargo clippy -p memory-retrieval` - no warnings.
  </verify>
  <done>
StopConditions has agent_filter: Option<String> field.
with_agent_filter() builder method exists.
Test verifies agent filter can be set.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update ingest handler to extract agent</name>
  <files>crates/memory-service/src/ingest.rs</files>
  <action>
Update the ingest handler to extract agent from proto Event and set it on the domain Event.

1. First, read the current ingest.rs to understand the conversion logic:
   - Look for where proto::Event is converted to memory_types::Event
   - This is typically in the IngestEvent RPC handler

2. Find the proto to domain Event conversion and add agent extraction:

   The pattern should look like:
   ```rust
   // After extracting other fields from proto_event...
   let agent = proto_event.agent.filter(|s| !s.is_empty());

   // When building the Event...
   let event = Event::new(...)
       .with_metadata(metadata);

   // Add agent if present
   let event = if let Some(agent_id) = agent {
       event.with_agent(agent_id.to_lowercase())
   } else {
       event
   };
   ```

3. If the conversion uses a From or Into trait, update that implementation.

4. Add or update test to verify agent is extracted:

   ```rust
   #[test]
   fn test_ingest_event_with_agent() {
       // Create proto event with agent
       let proto_event = proto::Event {
           event_id: "test-123".to_string(),
           session_id: "session-1".to_string(),
           timestamp_ms: 1704067200000,
           event_type: proto::EventType::UserMessage as i32,
           role: proto::EventRole::User as i32,
           text: "Hello".to_string(),
           metadata: HashMap::new(),
           agent: Some("claude".to_string()),
       };

       // Convert and verify
       let event: Event = proto_event.into();
       assert_eq!(event.agent, Some("claude".to_string()));
   }

   #[test]
   fn test_ingest_event_without_agent() {
       let proto_event = proto::Event {
           event_id: "test-456".to_string(),
           session_id: "session-1".to_string(),
           timestamp_ms: 1704067200000,
           event_type: proto::EventType::UserMessage as i32,
           role: proto::EventRole::User as i32,
           text: "Hello".to_string(),
           metadata: HashMap::new(),
           agent: None,
       };

       let event: Event = proto_event.into();
       assert!(event.agent.is_none());
   }
   ```

Note: The exact location depends on how the codebase structures proto-to-domain conversions. Look for From<proto::Event> for Event or similar patterns.
  </action>
  <verify>
Run `cargo test -p memory-service` - all tests pass.
Run `cargo clippy -p memory-service` - no warnings.
  </verify>
  <done>
Ingest handler extracts agent from proto Event.
Agent is normalized to lowercase.
Empty agent strings are treated as None.
Tests verify agent extraction works.
  </done>
</task>

</tasks>

<verification>
1. `cargo build --workspace` compiles successfully
2. `cargo test --workspace` passes all tests
3. `cargo clippy --workspace` has no warnings
4. Proto regenerates and includes agent_filter fields
5. Ingest correctly handles events with and without agent field

Full integration verification:
```bash
# Build everything
cargo build --workspace

# Run all tests
cargo test --workspace

# Check lints
cargo clippy --workspace --all-targets --all-features -- -D warnings

# Verify docs build
RUSTDOCFLAGS="-D warnings" cargo doc --no-deps --workspace --all-features
```
</verification>

<success_criteria>
- RouteQueryRequest has agent_filter field in proto
- TeleportSearchRequest has agent_filter field in proto
- VectorTeleportRequest has agent_filter field in proto
- HybridSearchRequest has agent_filter field in proto
- RetrievalResult has agent field in proto
- StopConditions has agent_filter in Rust types
- Ingest handler extracts agent from proto and sets on Event
- All workspace tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/18-agent-tagging-infrastructure/18-04-SUMMARY.md`
</output>
