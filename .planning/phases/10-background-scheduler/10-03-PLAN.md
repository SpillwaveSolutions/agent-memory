---
phase: 10-background-scheduler
plan: 03
type: execute
wave: 3
depends_on: ["10-01", "10-02"]
files_modified:
  - crates/memory-scheduler/src/jobs/mod.rs
  - crates/memory-scheduler/src/jobs/rollup.rs
  - crates/memory-scheduler/src/jobs/compaction.rs
  - crates/memory-scheduler/src/lib.rs
  - crates/memory-daemon/src/lib.rs
  - crates/memory-daemon/src/commands.rs
  - crates/memory-daemon/Cargo.toml
autonomous: true

must_haves:
  truths:
    - "TOC rollup jobs run on configured schedule"
    - "Day/Week/Month rollups execute in sequence"
    - "Rollup jobs use existing memory-toc::rollup::RollupJob"
    - "Jobs checkpoint for crash recovery"
    - "Daemon starts scheduler on startup"
  artifacts:
    - path: "crates/memory-scheduler/src/jobs/rollup.rs"
      provides: "TOC rollup job definitions"
      exports: ["create_rollup_jobs", "RollupJobConfig"]
    - path: "crates/memory-scheduler/src/jobs/compaction.rs"
      provides: "RocksDB compaction job"
      exports: ["create_compaction_job"]
  key_links:
    - from: "crates/memory-scheduler/src/jobs/rollup.rs"
      to: "memory_toc::rollup::RollupJob"
      via: "wraps existing rollup implementation"
      pattern: "RollupJob::new"
    - from: "crates/memory-daemon/src/commands.rs"
      to: "memory_scheduler::SchedulerService"
      via: "daemon starts scheduler"
      pattern: "SchedulerService::new"
---

<objective>
Wire existing TOC rollup jobs to the scheduler and integrate into daemon.

Purpose: Enable automatic periodic TOC rollups without manual intervention.
Output: Scheduled rollup jobs integrated into daemon lifecycle.
</objective>

<execution_context>
@/Users/richardhightower/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardhightower/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/10-background-scheduler/10-RESEARCH.md
@.planning/phases/10-background-scheduler/10-01-SUMMARY.md
@.planning/phases/10-background-scheduler/10-02-SUMMARY.md
@crates/memory-toc/src/rollup.rs
@crates/memory-daemon/src/commands.rs
@crates/memory-daemon/Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create rollup job definitions</name>
  <files>
    crates/memory-scheduler/src/jobs/mod.rs
    crates/memory-scheduler/src/jobs/rollup.rs
    crates/memory-scheduler/src/lib.rs
    crates/memory-scheduler/Cargo.toml
  </files>
  <action>
Create job definitions module with TOC rollup jobs:

1. Update `crates/memory-scheduler/Cargo.toml`:
   - Add dependency: memory-toc = { workspace = true }
   - Add dependency: memory-storage = { workspace = true }
   - Add optional feature "jobs" that includes these (default on)

2. Create `crates/memory-scheduler/src/jobs/mod.rs`:
   ```rust
   //! Predefined job implementations for common tasks.

   pub mod rollup;
   pub mod compaction;
   ```

3. Create `crates/memory-scheduler/src/jobs/rollup.rs`:
   ```rust
   //! TOC rollup job definitions.
   //!
   //! Wraps memory_toc::rollup to schedule periodic rollups.

   use std::sync::Arc;
   use serde::{Deserialize, Serialize};

   use memory_storage::Storage;
   use memory_toc::summarizer::Summarizer;
   use memory_toc::rollup::RollupJob;

   use crate::{
       SchedulerService, SchedulerError,
       OverlapPolicy, JitterConfig,
   };

   /// Configuration for rollup jobs
   #[derive(Debug, Clone, Serialize, Deserialize)]
   pub struct RollupJobConfig {
       /// Cron expression for day rollup (default: "0 0 1 * * *" = 1 AM daily)
       pub day_cron: String,
       /// Cron expression for week rollup (default: "0 0 2 * * 0" = 2 AM Sunday)
       pub week_cron: String,
       /// Cron expression for month rollup (default: "0 0 3 1 * *" = 3 AM 1st of month)
       pub month_cron: String,
       /// Timezone for scheduling (default: "UTC")
       pub timezone: String,
       /// Max jitter in seconds (default: 300 = 5 min)
       pub jitter_secs: u64,
   }

   impl Default for RollupJobConfig {
       fn default() -> Self {
           Self {
               day_cron: "0 0 1 * * *".to_string(),
               week_cron: "0 0 2 * * 0".to_string(),
               month_cron: "0 0 3 1 * *".to_string(),
               timezone: "UTC".to_string(),
               jitter_secs: 300,
           }
       }
   }

   /// Register all rollup jobs with the scheduler.
   ///
   /// Creates jobs for day, week, and month rollups using existing
   /// memory_toc::rollup implementation.
   pub async fn create_rollup_jobs(
       scheduler: &SchedulerService,
       storage: Arc<Storage>,
       summarizer: Arc<dyn Summarizer>,
       config: RollupJobConfig,
   ) -> Result<(), SchedulerError> {
       // Day rollup job
       let storage_day = storage.clone();
       let summarizer_day = summarizer.clone();
       scheduler.register_job(
           "toc_rollup_day",
           &config.day_cron,
           Some(&config.timezone),
           OverlapPolicy::Skip,
           JitterConfig::new(config.jitter_secs),
           move || {
               let storage = storage_day.clone();
               let summarizer = summarizer_day.clone();
               async move {
                   run_day_rollup(storage, summarizer).await
               }
           },
       ).await?;

       // Week rollup job
       let storage_week = storage.clone();
       let summarizer_week = summarizer.clone();
       scheduler.register_job(
           "toc_rollup_week",
           &config.week_cron,
           Some(&config.timezone),
           OverlapPolicy::Skip,
           JitterConfig::new(config.jitter_secs),
           move || {
               let storage = storage_week.clone();
               let summarizer = summarizer_week.clone();
               async move {
                   run_week_rollup(storage, summarizer).await
               }
           },
       ).await?;

       // Month rollup job
       let storage_month = storage.clone();
       let summarizer_month = summarizer.clone();
       scheduler.register_job(
           "toc_rollup_month",
           &config.month_cron,
           Some(&config.timezone),
           OverlapPolicy::Skip,
           JitterConfig::new(config.jitter_secs),
           move || {
               let storage = storage_month.clone();
               let summarizer = summarizer_month.clone();
               async move {
                   run_month_rollup(storage, summarizer).await
               }
           },
       ).await?;

       tracing::info!("Registered TOC rollup jobs");
       Ok(())
   }

   async fn run_day_rollup(
       storage: Arc<Storage>,
       summarizer: Arc<dyn Summarizer>,
   ) -> Result<(), String> {
       use memory_toc::rollup::RollupJob;
       use memory_types::TocLevel;
       use chrono::Duration;

       let job = RollupJob::new(storage, summarizer, TocLevel::Day, Duration::hours(1));
       job.run().await
           .map(|count| tracing::info!(count, "Day rollup complete"))
           .map_err(|e| e.to_string())
   }

   async fn run_week_rollup(
       storage: Arc<Storage>,
       summarizer: Arc<dyn Summarizer>,
   ) -> Result<(), String> {
       use memory_toc::rollup::RollupJob;
       use memory_types::TocLevel;
       use chrono::Duration;

       let job = RollupJob::new(storage, summarizer, TocLevel::Week, Duration::hours(24));
       job.run().await
           .map(|count| tracing::info!(count, "Week rollup complete"))
           .map_err(|e| e.to_string())
   }

   async fn run_month_rollup(
       storage: Arc<Storage>,
       summarizer: Arc<dyn Summarizer>,
   ) -> Result<(), String> {
       use memory_toc::rollup::RollupJob;
       use memory_types::TocLevel;
       use chrono::Duration;

       let job = RollupJob::new(storage, summarizer, TocLevel::Month, Duration::hours(24));
       job.run().await
           .map(|count| tracing::info!(count, "Month rollup complete"))
           .map_err(|e| e.to_string())
   }
   ```

4. Update lib.rs to add jobs module and exports
  </action>
  <verify>
    cd /Users/richardhightower/clients/spillwave/src/agent-memory && cargo check -p memory-scheduler
  </verify>
  <done>
    Rollup job definitions compile and use existing memory-toc rollup implementation.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add compaction job and job module exports</name>
  <files>
    crates/memory-scheduler/src/jobs/compaction.rs
    crates/memory-scheduler/src/lib.rs
  </files>
  <action>
Add RocksDB compaction job:

1. Create `crates/memory-scheduler/src/jobs/compaction.rs`:
   ```rust
   //! RocksDB compaction job.
   //!
   //! Triggers manual compaction to optimize storage.

   use std::sync::Arc;
   use serde::{Deserialize, Serialize};

   use memory_storage::Storage;

   use crate::{
       SchedulerService, SchedulerError,
       OverlapPolicy, JitterConfig,
   };

   /// Configuration for compaction job
   #[derive(Debug, Clone, Serialize, Deserialize)]
   pub struct CompactionJobConfig {
       /// Cron expression (default: "0 0 4 * * 0" = 4 AM Sunday)
       pub cron: String,
       /// Timezone (default: "UTC")
       pub timezone: String,
       /// Max jitter in seconds (default: 600 = 10 min)
       pub jitter_secs: u64,
   }

   impl Default for CompactionJobConfig {
       fn default() -> Self {
           Self {
               cron: "0 0 4 * * 0".to_string(),
               timezone: "UTC".to_string(),
               jitter_secs: 600,
           }
       }
   }

   /// Register compaction job with the scheduler.
   pub async fn create_compaction_job(
       scheduler: &SchedulerService,
       storage: Arc<Storage>,
       config: CompactionJobConfig,
   ) -> Result<(), SchedulerError> {
       scheduler.register_job(
           "rocksdb_compaction",
           &config.cron,
           Some(&config.timezone),
           OverlapPolicy::Skip,
           JitterConfig::new(config.jitter_secs),
           move || {
               let storage = storage.clone();
               async move {
                   tracing::info!("Starting manual compaction");
                   storage.compact_all()
                       .map(|_| tracing::info!("Compaction complete"))
                       .map_err(|e| e.to_string())
               }
           },
       ).await?;

       tracing::info!("Registered compaction job");
       Ok(())
   }
   ```

2. Update lib.rs to export jobs module:
   ```rust
   pub mod jobs;
   pub use jobs::rollup::{create_rollup_jobs, RollupJobConfig};
   pub use jobs::compaction::{create_compaction_job, CompactionJobConfig};
   ```

3. Ensure all public types have proper derives (Serialize, Deserialize, Debug, Clone)
  </action>
  <verify>
    cd /Users/richardhightower/clients/spillwave/src/agent-memory && cargo check -p memory-scheduler
  </verify>
  <done>
    Compaction job defined. All job configs are serializable for config loading.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate scheduler into daemon startup</name>
  <files>
    crates/memory-daemon/Cargo.toml
    crates/memory-daemon/src/lib.rs
    crates/memory-daemon/src/commands.rs
  </files>
  <action>
Integrate scheduler into daemon lifecycle:

1. Update `crates/memory-daemon/Cargo.toml`:
   - Add dependency: memory-scheduler = { workspace = true }

2. Update daemon commands.rs start_daemon function:
   - After storage initialization, create SchedulerService
   - Register rollup jobs using create_rollup_jobs
   - Register compaction job using create_compaction_job
   - Start scheduler before starting gRPC server
   - Wire scheduler shutdown into graceful shutdown flow

   Key changes to start_daemon:
   ```rust
   // After storage is created
   let scheduler = SchedulerService::new(SchedulerConfig::default()).await?;

   // Get or create summarizer (use MockSummarizer for now, or load from config)
   let summarizer: Arc<dyn Summarizer> = Arc::new(MockSummarizer::new());

   // Register jobs
   create_rollup_jobs(
       &scheduler,
       storage.clone(),
       summarizer,
       RollupJobConfig::default(),
   ).await?;

   create_compaction_job(
       &scheduler,
       storage.clone(),
       CompactionJobConfig::default(),
   ).await?;

   // Start scheduler
   scheduler.start().await?;

   // Get shutdown token for graceful shutdown
   let scheduler_shutdown = scheduler.shutdown_token();

   // Run gRPC server with shutdown signal
   // ... existing server code ...

   // On shutdown, stop scheduler first
   scheduler.shutdown().await?;
   ```

3. Add scheduler to lib.rs exports if needed

4. Ensure daemon logs scheduler startup:
   - "Scheduler started with N jobs"
   - Job registration messages

Note: The summarizer is currently hardcoded to MockSummarizer. In production,
this should be loaded from config (ApiSummarizer if OPENAI_API_KEY set).
Add TODO comment for this enhancement.
  </action>
  <verify>
    cd /Users/richardhightower/clients/spillwave/src/agent-memory && cargo build -p memory-daemon
  </verify>
  <done>
    Daemon starts scheduler on startup. Rollup and compaction jobs are registered. Graceful shutdown works.
  </done>
</task>

</tasks>

<verification>
```bash
cd /Users/richardhightower/clients/spillwave/src/agent-memory

# Build daemon with scheduler
cargo build -p memory-daemon

# All scheduler tests pass
cargo test -p memory-scheduler

# Daemon binary runs (brief test)
./target/debug/memory-daemon --help

# Check scheduler is mentioned in daemon logs
# (Manual verification by starting daemon in foreground)

# Clippy clean
cargo clippy -p memory-scheduler -p memory-daemon -- -D warnings
```
</verification>

<success_criteria>
- [ ] RollupJobConfig configures day/week/month cron schedules
- [ ] create_rollup_jobs registers three jobs with OverlapPolicy::Skip
- [ ] CompactionJobConfig configures weekly compaction
- [ ] create_compaction_job registers compaction job
- [ ] memory-daemon depends on memory-scheduler
- [ ] Daemon start_daemon creates and starts scheduler
- [ ] Jobs use existing memory-toc RollupJob implementation
- [ ] Scheduler shutdown integrated into graceful shutdown
- [ ] All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/10-background-scheduler/10-03-SUMMARY.md`
</output>
