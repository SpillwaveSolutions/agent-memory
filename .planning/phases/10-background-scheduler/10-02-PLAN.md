---
phase: 10-background-scheduler
plan: 02
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - crates/memory-scheduler/src/registry.rs
  - crates/memory-scheduler/src/overlap.rs
  - crates/memory-scheduler/src/jitter.rs
  - crates/memory-scheduler/src/lib.rs
  - crates/memory-scheduler/src/scheduler.rs
autonomous: true

must_haves:
  truths:
    - "Job registry tracks last run, next run, and status for each job"
    - "Overlap policy prevents concurrent execution when configured to skip"
    - "Jitter adds random delay before job execution"
    - "Jobs can be paused and resumed"
  artifacts:
    - path: "crates/memory-scheduler/src/registry.rs"
      provides: "Job metadata tracking"
      exports: ["JobRegistry", "JobStatus", "JobResult"]
    - path: "crates/memory-scheduler/src/overlap.rs"
      provides: "Overlap policy implementation"
      exports: ["OverlapPolicy", "OverlapGuard"]
    - path: "crates/memory-scheduler/src/jitter.rs"
      provides: "Jitter utilities"
      exports: ["with_jitter", "JitterConfig"]
  key_links:
    - from: "crates/memory-scheduler/src/registry.rs"
      to: "std::sync::RwLock"
      via: "thread-safe status tracking"
      pattern: "RwLock<HashMap"
    - from: "crates/memory-scheduler/src/overlap.rs"
      to: "std::sync::atomic::AtomicBool"
      via: "lock-free running state"
      pattern: "AtomicBool"
    - from: "crates/memory-scheduler/src/scheduler.rs"
      to: "crates/memory-scheduler/src/registry.rs"
      via: "SchedulerService holds Arc<JobRegistry>"
      pattern: "Arc<JobRegistry>"
---

<objective>
Implement job registry for observability and overlap/jitter policies.

Purpose: Enable job status tracking for monitoring and prevent job pileup via configurable overlap policies.
Output: JobRegistry for status tracking, OverlapPolicy enum, jitter utilities.
</objective>

<execution_context>
@/Users/richardhightower/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardhightower/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/10-background-scheduler/10-RESEARCH.md
@.planning/phases/10-background-scheduler/10-01-SUMMARY.md
@crates/memory-scheduler/src/lib.rs
@crates/memory-scheduler/src/scheduler.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement JobRegistry for status tracking</name>
  <files>
    crates/memory-scheduler/src/registry.rs
    crates/memory-scheduler/src/lib.rs
  </files>
  <action>
Create job registry for tracking job execution status:

1. Create `crates/memory-scheduler/src/registry.rs`:

```rust
use std::collections::HashMap;
use std::sync::RwLock;
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};

/// Result of a job execution
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum JobResult {
    Success,
    Failed(String),
    Skipped(String),
}

/// Status of a registered job
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct JobStatus {
    pub job_name: String,
    pub cron_expr: String,
    pub last_run: Option<DateTime<Utc>>,
    pub last_duration_ms: Option<u64>,
    pub last_result: Option<JobResult>,
    pub next_run: Option<DateTime<Utc>>,
    pub run_count: u64,
    pub error_count: u64,
    pub is_running: bool,
    pub is_paused: bool,
}

impl JobStatus {
    pub fn new(job_name: String, cron_expr: String) -> Self {
        Self {
            job_name,
            cron_expr,
            last_run: None,
            last_duration_ms: None,
            last_result: None,
            next_run: None,
            run_count: 0,
            error_count: 0,
            is_running: false,
            is_paused: false,
        }
    }
}

/// Registry for tracking job metadata and execution status
pub struct JobRegistry {
    jobs: RwLock<HashMap<String, JobStatus>>,
}

impl JobRegistry {
    pub fn new() -> Self {
        Self {
            jobs: RwLock::new(HashMap::new()),
        }
    }

    pub fn register(&self, job_name: &str, cron_expr: &str) {
        let mut jobs = self.jobs.write().unwrap();
        jobs.insert(
            job_name.to_string(),
            JobStatus::new(job_name.to_string(), cron_expr.to_string()),
        );
    }

    pub fn record_start(&self, job_name: &str) {
        let mut jobs = self.jobs.write().unwrap();
        if let Some(status) = jobs.get_mut(job_name) {
            status.is_running = true;
        }
    }

    pub fn record_complete(&self, job_name: &str, result: JobResult, duration_ms: u64) {
        let mut jobs = self.jobs.write().unwrap();
        if let Some(status) = jobs.get_mut(job_name) {
            status.is_running = false;
            status.last_run = Some(Utc::now());
            status.last_duration_ms = Some(duration_ms);
            status.run_count += 1;
            if matches!(result, JobResult::Failed(_)) {
                status.error_count += 1;
            }
            status.last_result = Some(result);
        }
    }

    pub fn set_next_run(&self, job_name: &str, next: DateTime<Utc>) {
        let mut jobs = self.jobs.write().unwrap();
        if let Some(status) = jobs.get_mut(job_name) {
            status.next_run = Some(next);
        }
    }

    pub fn set_paused(&self, job_name: &str, paused: bool) {
        let mut jobs = self.jobs.write().unwrap();
        if let Some(status) = jobs.get_mut(job_name) {
            status.is_paused = paused;
        }
    }

    pub fn get_status(&self, job_name: &str) -> Option<JobStatus> {
        self.jobs.read().unwrap().get(job_name).cloned()
    }

    pub fn get_all_status(&self) -> Vec<JobStatus> {
        self.jobs.read().unwrap().values().cloned().collect()
    }

    pub fn is_running(&self, job_name: &str) -> bool {
        self.jobs.read().unwrap()
            .get(job_name)
            .map(|s| s.is_running)
            .unwrap_or(false)
    }
}

impl Default for JobRegistry {
    fn default() -> Self {
        Self::new()
    }
}
```

2. Update lib.rs to add registry module and exports
  </action>
  <verify>
    cd /Users/richardhightower/clients/spillwave/src/agent-memory && cargo test -p memory-scheduler registry
  </verify>
  <done>
    JobRegistry tracks job status with thread-safe access. All registry tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement OverlapPolicy and jitter utilities</name>
  <files>
    crates/memory-scheduler/src/overlap.rs
    crates/memory-scheduler/src/jitter.rs
    crates/memory-scheduler/src/lib.rs
  </files>
  <action>
Implement overlap policy and jitter:

1. Create `crates/memory-scheduler/src/overlap.rs`:

```rust
use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::Arc;
use serde::{Deserialize, Serialize};

/// Policy for handling overlapping job executions
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize, Default)]
pub enum OverlapPolicy {
    /// Skip execution if previous run is still active (recommended)
    #[default]
    Skip,
    /// Allow concurrent executions
    Concurrent,
}

/// Guard for tracking whether a job is currently running
pub struct OverlapGuard {
    is_running: Arc<AtomicBool>,
    policy: OverlapPolicy,
}

impl OverlapGuard {
    pub fn new(policy: OverlapPolicy) -> Self {
        Self {
            is_running: Arc::new(AtomicBool::new(false)),
            policy,
        }
    }

    /// Attempt to acquire the guard for execution.
    /// Returns Some(RunGuard) if job should run, None if should skip.
    pub fn try_acquire(&self) -> Option<RunGuard> {
        match self.policy {
            OverlapPolicy::Skip => {
                if self.is_running.compare_exchange(
                    false,
                    true,
                    Ordering::SeqCst,
                    Ordering::SeqCst,
                ).is_ok() {
                    Some(RunGuard {
                        flag: self.is_running.clone(),
                    })
                } else {
                    None
                }
            }
            OverlapPolicy::Concurrent => {
                // Always allow, use dummy flag
                Some(RunGuard {
                    flag: Arc::new(AtomicBool::new(true)),
                })
            }
        }
    }

    pub fn is_running(&self) -> bool {
        self.is_running.load(Ordering::SeqCst)
    }
}

/// RAII guard that releases the running flag when dropped
pub struct RunGuard {
    flag: Arc<AtomicBool>,
}

impl Drop for RunGuard {
    fn drop(&mut self) {
        self.flag.store(false, Ordering::SeqCst);
    }
}
```

2. Create `crates/memory-scheduler/src/jitter.rs`:

```rust
use rand::Rng;
use std::time::Duration;
use serde::{Deserialize, Serialize};

/// Configuration for job execution jitter
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct JitterConfig {
    /// Maximum jitter in seconds (0 = no jitter)
    pub max_jitter_secs: u64,
}

impl Default for JitterConfig {
    fn default() -> Self {
        Self { max_jitter_secs: 0 }
    }
}

impl JitterConfig {
    pub fn new(max_jitter_secs: u64) -> Self {
        Self { max_jitter_secs }
    }

    /// Generate a random jitter duration
    pub fn generate_jitter(&self) -> Duration {
        if self.max_jitter_secs == 0 {
            return Duration::ZERO;
        }
        let jitter_ms = rand::thread_rng().gen_range(0..self.max_jitter_secs * 1000);
        Duration::from_millis(jitter_ms)
    }
}

/// Execute a future with jitter delay
pub async fn with_jitter<F, T>(max_jitter_secs: u64, job_fn: F) -> T
where
    F: std::future::Future<Output = T>,
{
    if max_jitter_secs > 0 {
        let config = JitterConfig::new(max_jitter_secs);
        let jitter = config.generate_jitter();
        if !jitter.is_zero() {
            tracing::debug!(jitter_ms = jitter.as_millis(), "Applying jitter delay");
            tokio::time::sleep(jitter).await;
        }
    }
    job_fn.await
}
```

3. Update lib.rs to add overlap and jitter modules with exports

4. Add tests:
   - test_overlap_skip_prevents_concurrent
   - test_overlap_concurrent_allows_multiple
   - test_jitter_within_bounds
   - test_jitter_zero_is_immediate
  </action>
  <verify>
    cd /Users/richardhightower/clients/spillwave/src/agent-memory && cargo test -p memory-scheduler -- overlap jitter
  </verify>
  <done>
    OverlapPolicy::Skip prevents concurrent runs. Jitter adds bounded random delay. Tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate registry with SchedulerService</name>
  <files>
    crates/memory-scheduler/src/scheduler.rs
    crates/memory-scheduler/src/lib.rs
  </files>
  <action>
Wire JobRegistry into SchedulerService:

1. Update SchedulerService struct:
   - Add registry: Arc<JobRegistry> field
   - Initialize in new()

2. Add registry access method:
   - pub fn registry(&self) -> Arc<JobRegistry>

3. Create enhanced job registration method:
   ```rust
   pub async fn register_job<F, Fut>(
       &self,
       name: &str,
       cron_expr: &str,
       timezone: Option<&str>,
       overlap_policy: OverlapPolicy,
       jitter: JitterConfig,
       job_fn: F,
   ) -> Result<uuid::Uuid, SchedulerError>
   where
       F: Fn() -> Fut + Clone + Send + Sync + 'static,
       Fut: std::future::Future<Output = Result<(), String>> + Send,
   ```

   Implementation:
   - Register job in registry with name and cron_expr
   - Create OverlapGuard with policy
   - Parse timezone or use default
   - Create Job::new_async_tz with closure that:
     - Tries to acquire overlap guard (skip if fails)
     - Records start in registry
     - Applies jitter delay
     - Executes job_fn
     - Records complete with result and duration
   - Add job to scheduler
   - Return UUID

4. Add pause/resume methods:
   - pub async fn pause_job(&self, job_name: &str) -> Result<(), SchedulerError>
     - Set paused in registry
     - Log pause

   - pub async fn resume_job(&self, job_name: &str) -> Result<(), SchedulerError>
     - Clear paused in registry
     - Log resume

   Note: Pause/resume affects registry tracking but actual job pausing
   requires job_fn to check registry.is_paused() - document this pattern.

5. Add integration test that:
   - Registers a job with Skip overlap
   - Verifies job appears in registry
   - Triggers job (via short cron like "* * * * * *")
   - Verifies status updates after execution

Use #[tokio::test(flavor = "multi_thread")] for all tests.
  </action>
  <verify>
    cd /Users/richardhightower/clients/spillwave/src/agent-memory && cargo test -p memory-scheduler
  </verify>
  <done>
    SchedulerService integrates with JobRegistry. Jobs track status correctly. All tests pass.
  </done>
</task>

</tasks>

<verification>
```bash
cd /Users/richardhightower/clients/spillwave/src/agent-memory

# All tests pass
cargo test -p memory-scheduler

# Registry operations are thread-safe
cargo test -p memory-scheduler registry

# Overlap policy works
cargo test -p memory-scheduler overlap

# Jitter is bounded
cargo test -p memory-scheduler jitter

# Clippy clean
cargo clippy -p memory-scheduler -- -D warnings
```
</verification>

<success_criteria>
- [ ] JobRegistry tracks all job metadata (last_run, next_run, status, duration)
- [ ] JobResult enum covers Success, Failed, Skipped cases
- [ ] OverlapPolicy::Skip prevents concurrent job execution
- [ ] OverlapPolicy::Concurrent allows multiple instances
- [ ] JitterConfig generates random delays within bounds
- [ ] with_jitter helper applies delay before execution
- [ ] SchedulerService.register_job integrates overlap and jitter
- [ ] pause/resume methods update registry state
- [ ] All tests pass with multi_thread flavor
</success_criteria>

<output>
After completion, create `.planning/phases/10-background-scheduler/10-02-SUMMARY.md`
</output>
