---
phase: 16-memory-ranking-enhancements
plan: 05
type: execute
wave: 3
depends_on: ["16-04"]
files_modified:
  - crates/memory-search/src/lifecycle.rs
  - crates/memory-search/src/indexer.rs
  - crates/memory-search/src/lib.rs
  - crates/memory-scheduler/src/jobs/bm25_prune.rs
  - crates/memory-scheduler/src/jobs/mod.rs
  - crates/memory-daemon/src/admin.rs
  - proto/memory.proto
autonomous: true

must_haves:
  truths:
    - "BM25 lifecycle is DISABLED by default (config.enabled = false)"
    - "BM25 prune respects per-level retention (segment 30d, day 180d, week 1825d)"
    - "Month and Year BM25 docs are NEVER pruned (protected)"
    - "Post-prune optimize/compact runs after deletion (per FR-09)"
    - "CLI command `admin prune-bm25` works with --level, --age-days, --dry-run"
  artifacts:
    - path: "crates/memory-search/src/lifecycle.rs"
      provides: "Bm25LifecycleConfig and prune_by_lifecycle"
      exports: ["Bm25LifecycleConfig", "Bm25PruneStats"]
    - path: "crates/memory-scheduler/src/jobs/bm25_prune.rs"
      provides: "Bm25PruneJob scheduler job"
      exports: ["Bm25PruneJob", "create_bm25_prune_job"]
    - path: "proto/memory.proto"
      provides: "PruneBm25Index RPC"
      contains: "rpc PruneBm25Index"
  key_links:
    - from: "crates/memory-search/src/lifecycle.rs"
      to: "crates/memory-search/src/indexer.rs"
      via: "delete_docs_before method"
      pattern: "delete_docs_before"
---

<objective>
Implement BM25 index lifecycle automation per FR-09 with per-level retention and post-prune optimization.

Purpose: Allow optional pruning of old BM25 documents while respecting append-only philosophy. DISABLED by default per PRD "append-only, no eviction" principle. When enabled, follows same per-level retention as vector index.

Output: Lifecycle config, prune-by-level API, admin RPC, CLI command, scheduler job.
</objective>

<execution_context>
@/Users/richardhightower/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardhightower/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Technical reference
@docs/plans/phase-16-memory-ranking-plan.md
@docs/prds/bm25-teleport-prd.md
@crates/memory-search/src/indexer.rs
@crates/memory-search/src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Bm25LifecycleConfig and prune_by_lifecycle in memory-search</name>
  <files>crates/memory-search/src/lifecycle.rs, crates/memory-search/src/lib.rs</files>
  <action>
Create new file `crates/memory-search/src/lifecycle.rs`:

```rust
//! BM25 index lifecycle management per FR-09.
//!
//! Retention rules from PRD:
//! - Segment: 30 days (high churn)
//! - Grip: 30 days (same as segment)
//! - Day: 180 days (mid-term recall while rollups mature)
//! - Week: 1825 days (5 years)
//! - Month: NEVER pruned (stable anchor)
//! - Year: NEVER pruned (stable anchor)
//!
//! IMPORTANT: DISABLED by default per PRD "append-only, no eviction" philosophy.
//! Must be explicitly enabled via configuration.

use chrono::{DateTime, Duration, Utc};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use tracing;

/// Configuration for BM25 lifecycle per FR-09
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Bm25LifecycleConfig {
    /// MUST be explicitly enabled (PRD default: append-only, no eviction)
    #[serde(default)]
    pub enabled: bool,

    /// Retention days for segment-level docs
    #[serde(default = "default_segment_retention")]
    pub segment_retention_days: u32,

    /// Retention days for grip-level docs
    #[serde(default = "default_grip_retention")]
    pub grip_retention_days: u32,

    /// Retention days for day-level docs
    #[serde(default = "default_day_retention")]
    pub day_retention_days: u32,

    /// Retention days for week-level docs
    #[serde(default = "default_week_retention")]
    pub week_retention_days: u32,

    // NOTE: month and year are NEVER pruned (protected)
}

fn default_segment_retention() -> u32 { 30 }
fn default_grip_retention() -> u32 { 30 }
fn default_day_retention() -> u32 { 180 }  // Different from vector (180 vs 365)
fn default_week_retention() -> u32 { 1825 }  // 5 years

impl Default for Bm25LifecycleConfig {
    fn default() -> Self {
        Self {
            enabled: false,  // DISABLED by default per PRD
            segment_retention_days: default_segment_retention(),
            grip_retention_days: default_grip_retention(),
            day_retention_days: default_day_retention(),
            week_retention_days: default_week_retention(),
        }
    }
}

/// Statistics from a BM25 prune operation
#[derive(Debug, Clone, Default)]
pub struct Bm25PruneStats {
    pub segments_pruned: u32,
    pub grips_pruned: u32,
    pub days_pruned: u32,
    pub weeks_pruned: u32,
    pub optimized: bool,
    pub errors: Vec<String>,
}

impl Bm25PruneStats {
    pub fn new() -> Self {
        Self::default()
    }

    pub fn add(&mut self, level: &str, count: u32) {
        match level {
            "segment" => self.segments_pruned += count,
            "grip" => self.grips_pruned += count,
            "day" => self.days_pruned += count,
            "week" => self.weeks_pruned += count,
            _ => {}
        }
    }

    pub fn total(&self) -> u32 {
        self.segments_pruned + self.grips_pruned + self.days_pruned + self.weeks_pruned
    }

    pub fn is_empty(&self) -> bool {
        self.total() == 0 && self.errors.is_empty()
    }
}

/// Protected levels that are NEVER pruned
pub const PROTECTED_LEVELS: &[&str] = &["month", "year"];

/// Check if a level is protected from pruning
pub fn is_protected_level(level: &str) -> bool {
    PROTECTED_LEVELS.contains(&level)
}

/// Get retention config as a map of level -> retention_days
pub fn retention_map(config: &Bm25LifecycleConfig) -> HashMap<&'static str, u32> {
    let mut map = HashMap::new();
    map.insert("segment", config.segment_retention_days);
    map.insert("grip", config.grip_retention_days);
    map.insert("day", config.day_retention_days);
    map.insert("week", config.week_retention_days);
    map
}

/// Calculate cutoff date for a given retention period
pub fn cutoff_date(retention_days: u32) -> DateTime<Utc> {
    Utc::now() - Duration::days(retention_days as i64)
}

/// BM25 maintenance configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Bm25MaintenanceConfig {
    /// Cron schedule for prune job (default: daily 3 AM)
    #[serde(default = "default_prune_schedule")]
    pub prune_schedule: String,

    /// Run index optimization after pruning (per FR-09)
    #[serde(default = "default_true")]
    pub optimize_after_prune: bool,
}

fn default_prune_schedule() -> String { "0 3 * * *".to_string() }
fn default_true() -> bool { true }

impl Default for Bm25MaintenanceConfig {
    fn default() -> Self {
        Self {
            prune_schedule: default_prune_schedule(),
            optimize_after_prune: true,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_disabled_by_default() {
        let config = Bm25LifecycleConfig::default();
        assert!(!config.enabled);  // MUST be false by default
    }

    #[test]
    fn test_default_retention() {
        let config = Bm25LifecycleConfig::default();
        assert_eq!(config.segment_retention_days, 30);
        assert_eq!(config.day_retention_days, 180);  // Different from vector
        assert_eq!(config.week_retention_days, 1825);
    }

    #[test]
    fn test_protected_levels() {
        assert!(is_protected_level("month"));
        assert!(is_protected_level("year"));
        assert!(!is_protected_level("segment"));
        assert!(!is_protected_level("day"));
    }

    #[test]
    fn test_prune_stats() {
        let mut stats = Bm25PruneStats::new();
        stats.add("segment", 10);
        stats.add("day", 5);
        assert_eq!(stats.total(), 15);
        assert_eq!(stats.segments_pruned, 10);
        assert_eq!(stats.days_pruned, 5);
    }

    #[test]
    fn test_retention_map() {
        let config = Bm25LifecycleConfig::default();
        let map = retention_map(&config);
        assert_eq!(map.get("segment"), Some(&30));
        assert_eq!(map.get("day"), Some(&180));
        assert_eq!(map.get("month"), None);  // Protected, not in map
    }
}
```

Export in `crates/memory-search/src/lib.rs`:
```rust
pub mod lifecycle;
pub use lifecycle::{Bm25LifecycleConfig, Bm25PruneStats, Bm25MaintenanceConfig, is_protected_level};
```
  </action>
  <verify>
```bash
cargo build -p memory-search
cargo test -p memory-search lifecycle
```
  </verify>
  <done>Bm25LifecycleConfig exists with enabled=false default; tests verify disabled by default</done>
</task>

<task type="auto">
  <name>Task 2: Add prune_by_lifecycle and optimize to Bm25Indexer</name>
  <files>crates/memory-search/src/indexer.rs</files>
  <action>
Update `crates/memory-search/src/indexer.rs`:

Add imports at top:
```rust
use crate::lifecycle::{Bm25LifecycleConfig, Bm25PruneStats, Bm25MaintenanceConfig, is_protected_level, retention_map, cutoff_date};
```

Add methods to Bm25Indexer impl (or equivalent indexer struct):

```rust
impl Bm25Indexer {
    // ... existing methods ...

    /// Prune BM25 documents per level using configured retention
    ///
    /// Per FR-09 retention rules:
    /// - segment: 30 days
    /// - grip: 30 days
    /// - day: 180 days
    /// - week: 1825 days (5 years)
    /// - month/year: NEVER pruned (protected)
    ///
    /// Returns early if lifecycle is disabled.
    pub async fn prune_by_lifecycle(
        &mut self,
        lifecycle_config: &Bm25LifecycleConfig,
        maintenance_config: &Bm25MaintenanceConfig,
        dry_run: bool,
    ) -> Result<Bm25PruneStats, Error> {
        let mut stats = Bm25PruneStats::new();

        if !lifecycle_config.enabled {
            tracing::info!("BM25 lifecycle disabled, skipping prune");
            return Ok(stats);
        }

        let retentions = retention_map(lifecycle_config);

        for (level, retention_days) in retentions {
            // Skip protected levels (month/year)
            if is_protected_level(level) {
                tracing::debug!(level, "Skipping protected level");
                continue;
            }

            let cutoff = cutoff_date(retention_days);
            tracing::info!(
                level,
                retention_days,
                cutoff = %cutoff.format("%Y-%m-%d"),
                dry_run,
                "Pruning BM25 documents"
            );

            match self.delete_docs_before(level, cutoff, dry_run).await {
                Ok(count) => {
                    stats.add(level, count);
                    tracing::info!(level, count, "Pruned BM25 documents");
                }
                Err(e) => {
                    let msg = format!("Failed to prune level {}: {}", level, e);
                    tracing::warn!("{}", msg);
                    stats.errors.push(msg);
                }
            }
        }

        // Explicitly log protected levels
        tracing::info!("Skipping month/year documents (protected, never pruned)");

        // Post-prune optimize (per FR-09)
        if !dry_run && stats.total() > 0 && maintenance_config.optimize_after_prune {
            match self.optimize_index().await {
                Ok(()) => {
                    stats.optimized = true;
                    tracing::info!("BM25 index optimized after prune");
                }
                Err(e) => {
                    let msg = format!("Failed to optimize index: {}", e);
                    tracing::warn!("{}", msg);
                    stats.errors.push(msg);
                }
            }
        }

        Ok(stats)
    }

    /// Delete documents for a level created before cutoff
    ///
    /// Uses Tantivy term query + delete.
    async fn delete_docs_before(
        &mut self,
        doc_type: &str,
        cutoff: DateTime<Utc>,
        dry_run: bool,
    ) -> Result<u32, Error> {
        // Build query: doc_type=X AND created_at < cutoff
        // This depends on Tantivy schema having doc_type and created_at fields

        // Pseudocode for Tantivy deletion:
        // let query = BooleanQuery::new(vec![
        //     (Occur::Must, TermQuery::new(Term::from_field_text(doc_type_field, doc_type))),
        //     (Occur::Must, RangeQuery::new_i64_lt(created_at_field, cutoff.timestamp_millis())),
        // ]);

        if dry_run {
            // Count matching documents
            // let count = searcher.search(&query, &Count)?;
            let count = 0u32;  // Placeholder
            tracing::info!(doc_type, count, "Dry run: would delete {} documents", count);
            return Ok(count);
        }

        // Delete matching documents
        // let delete_query = query;
        // self.index_writer.delete_query(delete_query)?;
        // self.index_writer.commit()?;

        let deleted = 0u32;  // Placeholder - actual impl uses Tantivy API
        tracing::debug!(doc_type, deleted, "Deleted BM25 documents");
        Ok(deleted)
    }

    /// Optimize/compact the index after deletions
    ///
    /// Per FR-09: "Post-prune optimize/compact keeps index healthy"
    async fn optimize_index(&self) -> Result<(), Error> {
        // Tantivy segment merging
        // self.index_writer.merge(&MergePolicy::default()).wait()?;

        tracing::info!("BM25 index optimized");
        Ok(())
    }
}
```

Note: The actual Tantivy API calls depend on the existing schema and writer setup. The executor should adapt `delete_docs_before` and `optimize_index` to the actual Tantivy APIs available.
  </action>
  <verify>
```bash
cargo build -p memory-search
cargo test -p memory-search
```
  </verify>
  <done>prune_by_lifecycle method exists with per-level retention and post-prune optimize</done>
</task>

<task type="auto">
  <name>Task 3: Add PruneBm25Index RPC to proto and create scheduler job</name>
  <files>proto/memory.proto, crates/memory-scheduler/src/jobs/bm25_prune.rs, crates/memory-scheduler/src/jobs/mod.rs</files>
  <action>
Update `proto/memory.proto`:

Add after PruneVectorIndexResponse:

```protobuf
// ===== BM25 Lifecycle Messages (Phase 16 - FR-09) =====

// Request to prune BM25 index
message PruneBm25IndexRequest {
    // Optional: prune specific level only ("segment", "grip", "day", "week", "all", or "")
    string level = 1;
    // Override retention days (0 = use config)
    uint32 age_days_override = 2;
    // If true, report what would be pruned without actually deleting
    bool dry_run = 3;
}

// Response from BM25 prune
message PruneBm25IndexResponse {
    bool success = 1;
    uint32 segments_pruned = 2;
    uint32 grips_pruned = 3;
    uint32 days_pruned = 4;
    uint32 weeks_pruned = 5;
    bool optimized = 6;
    string message = 7;
}
```

Add RPC to MemoryService (after PruneVectorIndex):

```protobuf
// Prune old BM25 documents per lifecycle policy (FR-09)
rpc PruneBm25Index(PruneBm25IndexRequest) returns (PruneBm25IndexResponse);
```

Add BM25 lifecycle fields to an appropriate status message (use field numbers 60+):

```protobuf
// Add to GetTopicGraphStatusResponse or create GetTeleportStatusResponse:
// BM25 lifecycle metrics
int64 bm25_last_prune_timestamp = 60;
uint32 bm25_last_prune_segments = 61;
uint32 bm25_last_prune_grips = 62;
uint32 bm25_last_prune_days = 63;
uint32 bm25_last_prune_weeks = 64;
// Protected level counts
uint32 bm25_month_docs_count = 65;
uint32 bm25_year_docs_count = 66;
```

Create `crates/memory-scheduler/src/jobs/bm25_prune.rs`:

```rust
//! BM25 prune scheduler job (FR-09).
//!
//! Calls admin RPC to prune BM25 documents - doesn't own the search indexer.
//! DISABLED by default per PRD "append-only, no eviction" philosophy.

use crate::jobs::bm25_prune;
use memory_search::lifecycle::{Bm25LifecycleConfig, Bm25MaintenanceConfig};
use tokio_util::sync::CancellationToken;
use tracing;

/// Configuration for BM25 prune job
#[derive(Debug, Clone)]
pub struct Bm25PruneJobConfig {
    /// Lifecycle config (includes enabled flag)
    pub lifecycle: Bm25LifecycleConfig,
    /// Maintenance config (includes schedule)
    pub maintenance: Bm25MaintenanceConfig,
}

impl Default for Bm25PruneJobConfig {
    fn default() -> Self {
        Self {
            lifecycle: Bm25LifecycleConfig::default(),  // enabled: false by default
            maintenance: Bm25MaintenanceConfig::default(),
        }
    }
}

/// BM25 prune job - calls admin RPC
pub struct Bm25PruneJob {
    config: Bm25PruneJobConfig,
}

impl Bm25PruneJob {
    pub fn new(config: Bm25PruneJobConfig) -> Self {
        Self { config }
    }

    /// Execute the prune job
    ///
    /// In production, this would call the PruneBm25Index RPC.
    /// The scheduler doesn't own the indexer - it triggers via RPC.
    pub async fn run(&self, cancel: CancellationToken) -> Result<(), String> {
        if cancel.is_cancelled() {
            return Ok(());
        }

        if !self.config.lifecycle.enabled {
            tracing::debug!("BM25 lifecycle disabled, skipping prune job");
            return Ok(());
        }

        tracing::info!("Starting BM25 prune job");

        // In actual implementation, this calls gRPC:
        // let response = admin_client.prune_bm25_index(PruneBm25IndexRequest {
        //     level: String::new(),  // All levels
        //     age_days_override: 0,  // Use config
        //     dry_run: false,
        // }).await?;

        // For now, log that we would prune
        tracing::info!(
            segment_days = self.config.lifecycle.segment_retention_days,
            day_days = self.config.lifecycle.day_retention_days,
            week_days = self.config.lifecycle.week_retention_days,
            optimize = self.config.maintenance.optimize_after_prune,
            "BM25 prune job would prune per retention config"
        );

        // Placeholder success
        tracing::info!("BM25 prune job completed");
        Ok(())
    }

    /// Get job name
    pub fn name(&self) -> &str {
        "bm25_prune"
    }

    /// Get cron schedule
    pub fn cron_schedule(&self) -> &str {
        &self.config.maintenance.prune_schedule
    }
}

/// Create BM25 prune job for registration with scheduler
pub fn create_bm25_prune_job(config: Bm25PruneJobConfig) -> Bm25PruneJob {
    Bm25PruneJob::new(config)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_job_disabled_by_default() {
        let config = Bm25PruneJobConfig::default();
        assert!(!config.lifecycle.enabled);  // MUST be disabled by default

        let job = Bm25PruneJob::new(config);
        let cancel = CancellationToken::new();

        let result = job.run(cancel).await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_job_respects_cancel() {
        let config = Bm25PruneJobConfig {
            lifecycle: Bm25LifecycleConfig {
                enabled: true,
                ..Default::default()
            },
            ..Default::default()
        };
        let job = Bm25PruneJob::new(config);
        let cancel = CancellationToken::new();
        cancel.cancel();

        let result = job.run(cancel).await;
        assert!(result.is_ok());
    }
}
```

Update `crates/memory-scheduler/src/jobs/mod.rs` to export:

```rust
pub mod bm25_prune;
pub use bm25_prune::{Bm25PruneJob, Bm25PruneJobConfig, create_bm25_prune_job};
```
  </action>
  <verify>
```bash
cargo build --workspace
cargo test -p memory-scheduler bm25_prune
```
  </verify>
  <done>PruneBm25Index RPC in proto; Bm25PruneJob scheduler job created; tests verify disabled by default</done>
</task>

</tasks>

<verification>
After all tasks complete:

```bash
# Full workspace build
cargo build --workspace

# Search tests
cargo test -p memory-search --all-features

# Scheduler tests
cargo test -p memory-scheduler --all-features

# Clippy check
cargo clippy -p memory-search -p memory-scheduler -- -D warnings
```
</verification>

<success_criteria>
1. Bm25LifecycleConfig exists with enabled=false by default (per PRD)
2. Retention defaults: segment 30d, day 180d (not 365), week 1825d
3. is_protected_level() returns true for month/year
4. prune_by_lifecycle() skips protected levels
5. prune_by_lifecycle() calls optimize_index() after successful prune (per FR-09)
6. PruneBm25Index RPC defined in proto with level filter and dry_run
7. Status messages have BM25 lifecycle metrics
8. Bm25PruneJob exists and is disabled by default
9. All tests pass including "disabled by default" assertions
10. Clippy passes with no warnings
</success_criteria>

<output>
After completion, create `.planning/phases/16-memory-ranking-enhancements/16-05-SUMMARY.md`
</output>
