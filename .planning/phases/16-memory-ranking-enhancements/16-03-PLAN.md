---
phase: 16-memory-ranking-enhancements
plan: 03
type: execute
wave: 2
depends_on: ["16-01"]
files_modified:
  - crates/memory-service/src/novelty.rs
  - crates/memory-service/src/lib.rs
  - crates/memory-types/src/config.rs
  - proto/memory.proto
autonomous: true

must_haves:
  truths:
    - "Novelty check is DISABLED by default (config.enabled = false)"
    - "When disabled, events are always stored without similarity check"
    - "When embedder or vector index unavailable, events are stored (fallback)"
    - "Timeout on novelty check results in storing the event (fail-open)"
    - "Metrics track skip/timeout/reject/store rates"
  artifacts:
    - path: "crates/memory-service/src/novelty.rs"
      provides: "NoveltyChecker with opt-in design and fallback behavior"
      exports: ["NoveltyChecker", "NoveltyConfig", "NoveltyMetrics"]
    - path: "crates/memory-types/src/config.rs"
      provides: "NoveltyConfig with enabled=false default"
      contains: "pub enabled: bool"
  key_links:
    - from: "crates/memory-service/src/novelty.rs"
      to: "crates/memory-embeddings"
      via: "optional embedder for similarity check"
      pattern: "Option<Arc<Embedder>>"
---

<objective>
Implement opt-in novelty checking with fail-open behavior to prevent redundant storage.

Purpose: Allow users to optionally filter near-duplicate events, but NEVER block ingestion. The check is disabled by default, has explicit fallbacks for missing dependencies, and times out gracefully.

Output: NoveltyChecker service with opt-in config, dependency gating, timeout handling, and comprehensive metrics.
</objective>

<execution_context>
@/Users/richardhightower/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardhightower/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Technical reference
@docs/plans/phase-16-memory-ranking-plan.md
@crates/memory-embeddings/src/lib.rs
@crates/memory-vector/src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add NoveltyConfig to memory-types with disabled-by-default</name>
  <files>crates/memory-types/src/config.rs, crates/memory-types/src/lib.rs</files>
  <action>
Add NoveltyConfig to `crates/memory-types/src/config.rs`:

```rust
/// Configuration for novelty detection (opt-in, disabled by default)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NoveltyConfig {
    /// MUST be explicitly set to true to enable (default: false)
    /// When false, all events are stored without similarity check
    #[serde(default)]
    pub enabled: bool,

    /// Similarity threshold - events above this are considered duplicates
    /// Range: 0.0-1.0, higher = stricter (more duplicates detected)
    #[serde(default = "default_novelty_threshold")]
    pub threshold: f32,

    /// Maximum time for novelty check (ms)
    /// If exceeded, event is stored anyway (fail-open)
    #[serde(default = "default_novelty_timeout")]
    pub timeout_ms: u64,

    /// Minimum event text length to check (skip very short events)
    #[serde(default = "default_min_text_length")]
    pub min_text_length: usize,
}

fn default_novelty_threshold() -> f32 { 0.82 }
fn default_novelty_timeout() -> u64 { 50 }
fn default_min_text_length() -> usize { 50 }

impl Default for NoveltyConfig {
    fn default() -> Self {
        Self {
            enabled: false,  // DISABLED by default - explicit opt-in required
            threshold: default_novelty_threshold(),
            timeout_ms: default_novelty_timeout(),
            min_text_length: default_min_text_length(),
        }
    }
}

impl NoveltyConfig {
    /// Validate configuration
    pub fn validate(&self) -> Result<(), String> {
        if !(0.0..=1.0).contains(&self.threshold) {
            return Err(format!("threshold must be 0.0-1.0, got {}", self.threshold));
        }
        if self.timeout_ms == 0 {
            return Err("timeout_ms must be > 0".to_string());
        }
        Ok(())
    }
}
```

Add to RankingConfig (if exists):
```rust
#[serde(default)]
pub novelty: NoveltyConfig,
```

Export in lib.rs:
```rust
pub use config::NoveltyConfig;
```

Add unit tests:
```rust
#[test]
fn test_novelty_config_disabled_by_default() {
    let config = NoveltyConfig::default();
    assert!(!config.enabled);
    assert_eq!(config.threshold, 0.82);
    assert_eq!(config.timeout_ms, 50);
}

#[test]
fn test_novelty_config_validation() {
    let mut config = NoveltyConfig::default();
    assert!(config.validate().is_ok());

    config.threshold = 1.5;
    assert!(config.validate().is_err());
}
```
  </action>
  <verify>
```bash
cargo build -p memory-types
cargo test -p memory-types novelty
```
  </verify>
  <done>NoveltyConfig exists with enabled=false default and validation; tests pass</done>
</task>

<task type="auto">
  <name>Task 2: Create NoveltyChecker with gated checks and fail-open behavior</name>
  <files>crates/memory-service/src/novelty.rs, crates/memory-service/src/lib.rs</files>
  <action>
Create new file `crates/memory-service/src/novelty.rs`:

```rust
//! Novelty checking service with opt-in design and fail-open behavior.
//!
//! Key design principles (from Phase 16 Plan):
//! - DISABLED by default (config.enabled = false)
//! - Explicit fallback on any failure (embedder unavailable, index not ready, timeout)
//! - Async check with configurable timeout
//! - Full metrics for observability
//! - NEVER a hard gate - always stores on any failure

use memory_types::config::NoveltyConfig;
use memory_types::Event;
use std::sync::atomic::{AtomicU64, Ordering};
use std::sync::Arc;
use std::time::{Duration, Instant};
use tokio::time::timeout;
use tracing;

// Forward declarations - these would come from actual crate imports
// use memory_embeddings::Embedder;
// use memory_vector::VectorIndex;

/// Metrics for novelty checking
#[derive(Debug, Default)]
pub struct NoveltyMetrics {
    pub skipped_disabled: AtomicU64,
    pub skipped_no_embedder: AtomicU64,
    pub skipped_no_index: AtomicU64,
    pub skipped_index_not_ready: AtomicU64,
    pub skipped_error: AtomicU64,
    pub skipped_timeout: AtomicU64,
    pub skipped_short_text: AtomicU64,
    pub stored_novel: AtomicU64,
    pub rejected_duplicate: AtomicU64,
}

impl NoveltyMetrics {
    pub fn new() -> Self {
        Self::default()
    }

    /// Get all counts as a snapshot
    pub fn snapshot(&self) -> NoveltyMetricsSnapshot {
        NoveltyMetricsSnapshot {
            skipped_disabled: self.skipped_disabled.load(Ordering::Relaxed),
            skipped_no_embedder: self.skipped_no_embedder.load(Ordering::Relaxed),
            skipped_no_index: self.skipped_no_index.load(Ordering::Relaxed),
            skipped_index_not_ready: self.skipped_index_not_ready.load(Ordering::Relaxed),
            skipped_error: self.skipped_error.load(Ordering::Relaxed),
            skipped_timeout: self.skipped_timeout.load(Ordering::Relaxed),
            skipped_short_text: self.skipped_short_text.load(Ordering::Relaxed),
            stored_novel: self.stored_novel.load(Ordering::Relaxed),
            rejected_duplicate: self.rejected_duplicate.load(Ordering::Relaxed),
        }
    }
}

#[derive(Debug, Clone)]
pub struct NoveltyMetricsSnapshot {
    pub skipped_disabled: u64,
    pub skipped_no_embedder: u64,
    pub skipped_no_index: u64,
    pub skipped_index_not_ready: u64,
    pub skipped_error: u64,
    pub skipped_timeout: u64,
    pub skipped_short_text: u64,
    pub stored_novel: u64,
    pub rejected_duplicate: u64,
}

impl NoveltyMetricsSnapshot {
    /// Total events that were stored (novel + all skipped)
    pub fn total_stored(&self) -> u64 {
        self.stored_novel +
        self.skipped_disabled +
        self.skipped_no_embedder +
        self.skipped_no_index +
        self.skipped_index_not_ready +
        self.skipped_error +
        self.skipped_timeout +
        self.skipped_short_text
    }

    /// Total events checked (novel + rejected)
    pub fn total_checked(&self) -> u64 {
        self.stored_novel + self.rejected_duplicate
    }

    /// Total events rejected
    pub fn total_rejected(&self) -> u64 {
        self.rejected_duplicate
    }
}

/// Trait for embedder (to allow mocking)
#[async_trait::async_trait]
pub trait EmbedderTrait: Send + Sync {
    async fn embed(&self, text: &str) -> Result<Vec<f32>, String>;
}

/// Trait for vector index (to allow mocking)
#[async_trait::async_trait]
pub trait VectorIndexTrait: Send + Sync {
    fn is_ready(&self) -> bool;
    async fn search(&self, embedding: &[f32], top_k: usize) -> Result<Vec<(String, f32)>, String>;
}

/// Novelty checker with opt-in design and fail-open behavior
pub struct NoveltyChecker {
    embedder: Option<Arc<dyn EmbedderTrait>>,
    vector_index: Option<Arc<dyn VectorIndexTrait>>,
    config: NoveltyConfig,
    metrics: Arc<NoveltyMetrics>,
}

impl NoveltyChecker {
    /// Create new novelty checker
    pub fn new(
        embedder: Option<Arc<dyn EmbedderTrait>>,
        vector_index: Option<Arc<dyn VectorIndexTrait>>,
        config: NoveltyConfig,
    ) -> Self {
        Self {
            embedder,
            vector_index,
            config,
            metrics: Arc::new(NoveltyMetrics::new()),
        }
    }

    /// Get metrics for this checker
    pub fn metrics(&self) -> Arc<NoveltyMetrics> {
        Arc::clone(&self.metrics)
    }

    /// Check if event should be stored (novel or check skipped)
    ///
    /// Returns true if event should be stored:
    /// - Feature disabled -> true (store)
    /// - Embedder unavailable -> true (store)
    /// - Index unavailable or not ready -> true (store)
    /// - Timeout -> true (store)
    /// - Error -> true (store)
    /// - Below similarity threshold -> true (store, is novel)
    /// - Above similarity threshold -> false (reject, is duplicate)
    pub async fn should_store(&self, event: &Event) -> bool {
        // GATE 1: Feature must be explicitly enabled
        if !self.config.enabled {
            self.metrics.skipped_disabled.fetch_add(1, Ordering::Relaxed);
            return true;
        }

        // GATE 2: Skip very short text
        if event.text.len() < self.config.min_text_length {
            self.metrics.skipped_short_text.fetch_add(1, Ordering::Relaxed);
            tracing::debug!(
                text_len = event.text.len(),
                min_len = self.config.min_text_length,
                "Novelty check skipped: text too short"
            );
            return true;
        }

        // GATE 3: Embedder must be available
        let embedder = match &self.embedder {
            Some(e) => e,
            None => {
                self.metrics.skipped_no_embedder.fetch_add(1, Ordering::Relaxed);
                tracing::debug!("Novelty check skipped: embedder unavailable");
                return true;
            }
        };

        // GATE 4: Vector index must be available and ready
        let index = match &self.vector_index {
            Some(i) => i,
            None => {
                self.metrics.skipped_no_index.fetch_add(1, Ordering::Relaxed);
                tracing::debug!("Novelty check skipped: vector index unavailable");
                return true;
            }
        };

        if !index.is_ready() {
            self.metrics.skipped_index_not_ready.fetch_add(1, Ordering::Relaxed);
            tracing::debug!("Novelty check skipped: vector index not ready");
            return true;
        }

        // GATE 5: Check must complete within timeout
        let start = Instant::now();
        let timeout_duration = Duration::from_millis(self.config.timeout_ms);

        match timeout(timeout_duration, self.check_similarity(&event.text, embedder, index)).await {
            Ok(Ok(is_novel)) => {
                let elapsed = start.elapsed();
                tracing::debug!(elapsed_ms = elapsed.as_millis(), is_novel, "Novelty check completed");

                if is_novel {
                    self.metrics.stored_novel.fetch_add(1, Ordering::Relaxed);
                    true
                } else {
                    self.metrics.rejected_duplicate.fetch_add(1, Ordering::Relaxed);
                    tracing::info!(
                        event_id = %event.event_id,
                        "Novelty check rejected duplicate"
                    );
                    false
                }
            }
            Ok(Err(e)) => {
                self.metrics.skipped_error.fetch_add(1, Ordering::Relaxed);
                tracing::warn!(?e, "Novelty check failed, storing anyway");
                true
            }
            Err(_) => {
                self.metrics.skipped_timeout.fetch_add(1, Ordering::Relaxed);
                tracing::warn!(
                    timeout_ms = self.config.timeout_ms,
                    "Novelty check timed out, storing anyway"
                );
                true
            }
        }
    }

    /// Internal similarity check
    async fn check_similarity(
        &self,
        text: &str,
        embedder: &Arc<dyn EmbedderTrait>,
        index: &Arc<dyn VectorIndexTrait>,
    ) -> Result<bool, String> {
        // Generate embedding
        let embedding = embedder.embed(text).await?;

        // Search for similar
        let results = index.search(&embedding, 1).await?;

        // Check if most similar is above threshold
        if let Some((_, score)) = results.first() {
            Ok(*score <= self.config.threshold)
        } else {
            // No similar documents found - is novel
            Ok(true)
        }
    }

    /// Get configuration
    pub fn config(&self) -> &NoveltyConfig {
        &self.config
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use memory_types::{Event, EventType, EventRole};

    fn test_event(text: &str) -> Event {
        Event {
            event_id: "test-event-1".to_string(),
            session_id: "test-session".to_string(),
            timestamp: chrono::Utc::now(),
            event_type: EventType::UserMessage,
            role: EventRole::User,
            text: text.to_string(),
            metadata: Default::default(),
        }
    }

    #[tokio::test]
    async fn test_disabled_by_default_returns_true() {
        let config = NoveltyConfig::default();
        assert!(!config.enabled);

        let checker = NoveltyChecker::new(None, None, config);
        let event = test_event("This is a test event with enough text to pass length check");

        assert!(checker.should_store(&event).await);

        let metrics = checker.metrics().snapshot();
        assert_eq!(metrics.skipped_disabled, 1);
    }

    #[tokio::test]
    async fn test_skips_short_text() {
        let config = NoveltyConfig {
            enabled: true,
            min_text_length: 100,
            ..Default::default()
        };

        let checker = NoveltyChecker::new(None, None, config);
        let event = test_event("Short text");

        assert!(checker.should_store(&event).await);

        let metrics = checker.metrics().snapshot();
        assert_eq!(metrics.skipped_short_text, 1);
    }

    #[tokio::test]
    async fn test_skips_when_no_embedder() {
        let config = NoveltyConfig {
            enabled: true,
            min_text_length: 10,
            ..Default::default()
        };

        let checker = NoveltyChecker::new(None, None, config);
        let event = test_event("This is a test event with enough text");

        assert!(checker.should_store(&event).await);

        let metrics = checker.metrics().snapshot();
        assert_eq!(metrics.skipped_no_embedder, 1);
    }

    // Additional tests would use mock embedder/index implementations
}
```

Export in `crates/memory-service/src/lib.rs`:
```rust
pub mod novelty;
pub use novelty::{NoveltyChecker, NoveltyConfig, NoveltyMetrics};
```

Add to Cargo.toml for memory-service:
```toml
[dependencies]
async-trait = "0.1"
tokio = { version = "1", features = ["time"] }
```
  </action>
  <verify>
```bash
cargo build -p memory-service
cargo test -p memory-service novelty
```
  </verify>
  <done>NoveltyChecker exists with disabled-by-default, fallback behavior, timeout, and metrics; tests pass</done>
</task>

<task type="auto">
  <name>Task 3: Add novelty status fields to proto TeleportStatus</name>
  <files>proto/memory.proto</files>
  <action>
Update `proto/memory.proto`:

Find the TeleportStatus or GetTopicGraphStatusResponse message and add novelty fields.

If TeleportStatus doesn't exist, add it or use an appropriate status message.

Add these fields (use field numbers starting at 50+ to avoid conflicts):

```protobuf
// ===== Novelty Status Fields (Phase 16) =====
// Add to appropriate status message or create TeleportStatus if needed

// In an existing status response message, add:

// Whether novelty checking is enabled
bool novelty_enabled = 50;
// Total events checked for novelty
int64 novelty_checked_total = 51;
// Total events rejected as duplicates
int64 novelty_rejected_total = 52;
// Total events where novelty check was skipped (disabled, timeout, error)
int64 novelty_skipped_total = 53;
```

If creating a new message for ranking status:

```protobuf
// Request for ranking/novelty status
message GetRankingStatusRequest {}

// Ranking and novelty status
message RankingStatus {
    // Whether ranking enhancements are enabled (master switch)
    bool ranking_enabled = 1;

    // Salience scoring
    bool salience_enabled = 2;

    // Usage decay
    bool usage_decay_enabled = 3;

    // Novelty checking
    bool novelty_enabled = 4;
    int64 novelty_checked_total = 5;
    int64 novelty_rejected_total = 6;
    int64 novelty_skipped_total = 7;
}

// Add to MemoryService:
rpc GetRankingStatus(GetRankingStatusRequest) returns (RankingStatus);
```
  </action>
  <verify>
```bash
cargo build --workspace
```
  </verify>
  <done>Proto has novelty status fields; workspace builds successfully</done>
</task>

</tasks>

<verification>
After all tasks complete:

```bash
# Full workspace build
cargo build --workspace

# All service tests
cargo test -p memory-service --all-features

# All types tests
cargo test -p memory-types --all-features

# Clippy check
cargo clippy -p memory-service -p memory-types -- -D warnings
```
</verification>

<success_criteria>
1. NoveltyConfig exists with enabled=false by default
2. NoveltyChecker implements opt-in with explicit gating
3. When disabled, events always stored (skipped_disabled metric increments)
4. When embedder unavailable, events stored (skipped_no_embedder metric)
5. When index unavailable or not ready, events stored
6. Timeout results in storing event (skipped_timeout metric)
7. Error results in storing event (skipped_error metric)
8. Only above-threshold similarity results in rejection
9. Metrics track all skip/store/reject outcomes
10. Proto has novelty status fields
11. All tests pass, clippy clean
</success_criteria>

<output>
After completion, create `.planning/phases/16-memory-ranking-enhancements/16-03-SUMMARY.md`
</output>
