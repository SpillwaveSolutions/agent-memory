---
phase: 16-memory-ranking-enhancements
plan: 04
type: execute
wave: 2
depends_on: []
files_modified:
  - crates/memory-vector/src/pipeline.rs
  - crates/memory-vector/src/lifecycle.rs
  - crates/memory-scheduler/src/jobs/vector_prune.rs
  - crates/memory-daemon/src/admin.rs
  - proto/memory.proto
autonomous: true

must_haves:
  truths:
    - "Vector prune respects per-level retention (segment 30d, day 365d, week 1825d)"
    - "Month and Year vectors are NEVER pruned (protected)"
    - "Admin RPC PruneVectorIndex accepts level filter and dry_run flag"
    - "CLI command `admin prune-vectors` works with --level, --age-days, --dry-run"
    - "Scheduler job calls admin RPC (doesn't own vector pipeline)"
  artifacts:
    - path: "crates/memory-vector/src/lifecycle.rs"
      provides: "prune_by_lifecycle with per-level retention"
      exports: ["VectorLifecycleConfig", "PruneStats"]
    - path: "crates/memory-scheduler/src/jobs/vector_prune.rs"
      provides: "VectorPruneJob scheduler job"
      exports: ["VectorPruneJob", "create_vector_prune_job"]
    - path: "proto/memory.proto"
      provides: "PruneVectorIndex RPC"
      contains: "rpc PruneVectorIndex"
  key_links:
    - from: "crates/memory-scheduler/src/jobs/vector_prune.rs"
      to: "proto/memory.proto"
      via: "calls PruneVectorIndex RPC"
      pattern: "prune_vector_index"
---

<objective>
Implement vector index lifecycle automation per FR-08 retention rules via admin RPC.

Purpose: Automate pruning of old vectors from HNSW index. Segment/grip vectors retained 30 days, day vectors 365 days, week vectors 5 years. Month/year vectors are NEVER pruned (protected anchors).

Output: Lifecycle config, prune-by-level API, admin RPC, CLI command, scheduler job.
</objective>

<execution_context>
@/Users/richardhightower/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardhightower/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Technical reference
@docs/plans/phase-16-memory-ranking-plan.md
@docs/prds/hierarchical-vector-indexing-prd.md
@crates/memory-vector/src/pipeline.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create VectorLifecycleConfig and prune_by_lifecycle in memory-vector</name>
  <files>crates/memory-vector/src/lifecycle.rs, crates/memory-vector/src/lib.rs</files>
  <action>
Create new file `crates/memory-vector/src/lifecycle.rs`:

```rust
//! Vector index lifecycle management per FR-08.
//!
//! Retention rules from PRD:
//! - Segment: 30 days (high churn, rolled up quickly)
//! - Grip: 30 days (same as segment)
//! - Day: 365 days (mid-term recall)
//! - Week: 1825 days (5 years)
//! - Month: NEVER pruned (stable anchor)
//! - Year: NEVER pruned (stable anchor)

use chrono::{DateTime, Duration, Utc};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use tracing;

/// Configuration for vector lifecycle per FR-08
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VectorLifecycleConfig {
    /// Enable automatic vector pruning
    #[serde(default = "default_true")]
    pub enabled: bool,

    /// Retention days for segment-level vectors
    #[serde(default = "default_segment_retention")]
    pub segment_retention_days: u32,

    /// Retention days for grip-level vectors
    #[serde(default = "default_grip_retention")]
    pub grip_retention_days: u32,

    /// Retention days for day-level vectors
    #[serde(default = "default_day_retention")]
    pub day_retention_days: u32,

    /// Retention days for week-level vectors
    #[serde(default = "default_week_retention")]
    pub week_retention_days: u32,

    // NOTE: month and year are NEVER pruned (protected)
}

fn default_true() -> bool { true }
fn default_segment_retention() -> u32 { 30 }
fn default_grip_retention() -> u32 { 30 }
fn default_day_retention() -> u32 { 365 }
fn default_week_retention() -> u32 { 1825 }  // 5 years

impl Default for VectorLifecycleConfig {
    fn default() -> Self {
        Self {
            enabled: true,
            segment_retention_days: default_segment_retention(),
            grip_retention_days: default_grip_retention(),
            day_retention_days: default_day_retention(),
            week_retention_days: default_week_retention(),
        }
    }
}

/// Statistics from a prune operation
#[derive(Debug, Clone, Default)]
pub struct PruneStats {
    pub segments_pruned: u32,
    pub grips_pruned: u32,
    pub days_pruned: u32,
    pub weeks_pruned: u32,
    pub errors: Vec<String>,
}

impl PruneStats {
    pub fn new() -> Self {
        Self::default()
    }

    pub fn add(&mut self, level: &str, count: u32) {
        match level {
            "segment" => self.segments_pruned += count,
            "grip" => self.grips_pruned += count,
            "day" => self.days_pruned += count,
            "week" => self.weeks_pruned += count,
            _ => {}
        }
    }

    pub fn total(&self) -> u32 {
        self.segments_pruned + self.grips_pruned + self.days_pruned + self.weeks_pruned
    }

    pub fn is_empty(&self) -> bool {
        self.total() == 0 && self.errors.is_empty()
    }
}

/// Protected levels that are NEVER pruned
pub const PROTECTED_LEVELS: &[&str] = &["month", "year"];

/// Check if a level is protected from pruning
pub fn is_protected_level(level: &str) -> bool {
    PROTECTED_LEVELS.contains(&level)
}

/// Get retention config as a map of level -> retention_days
pub fn retention_map(config: &VectorLifecycleConfig) -> HashMap<&'static str, u32> {
    let mut map = HashMap::new();
    map.insert("segment", config.segment_retention_days);
    map.insert("grip", config.grip_retention_days);
    map.insert("day", config.day_retention_days);
    map.insert("week", config.week_retention_days);
    map
}

/// Calculate cutoff date for a given retention period
pub fn cutoff_date(retention_days: u32) -> DateTime<Utc> {
    Utc::now() - Duration::days(retention_days as i64)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_default_config() {
        let config = VectorLifecycleConfig::default();
        assert!(config.enabled);
        assert_eq!(config.segment_retention_days, 30);
        assert_eq!(config.day_retention_days, 365);
        assert_eq!(config.week_retention_days, 1825);
    }

    #[test]
    fn test_protected_levels() {
        assert!(is_protected_level("month"));
        assert!(is_protected_level("year"));
        assert!(!is_protected_level("segment"));
        assert!(!is_protected_level("day"));
    }

    #[test]
    fn test_prune_stats() {
        let mut stats = PruneStats::new();
        stats.add("segment", 10);
        stats.add("day", 5);
        assert_eq!(stats.total(), 15);
        assert_eq!(stats.segments_pruned, 10);
        assert_eq!(stats.days_pruned, 5);
    }

    #[test]
    fn test_retention_map() {
        let config = VectorLifecycleConfig::default();
        let map = retention_map(&config);
        assert_eq!(map.get("segment"), Some(&30));
        assert_eq!(map.get("month"), None);  // Protected, not in map
    }
}
```

Export in `crates/memory-vector/src/lib.rs`:
```rust
pub mod lifecycle;
pub use lifecycle::{VectorLifecycleConfig, PruneStats, is_protected_level};
```
  </action>
  <verify>
```bash
cargo build -p memory-vector
cargo test -p memory-vector lifecycle
```
  </verify>
  <done>VectorLifecycleConfig and PruneStats exist with per-level retention; protected levels defined</done>
</task>

<task type="auto">
  <name>Task 2: Add prune_by_lifecycle to VectorIndexPipeline</name>
  <files>crates/memory-vector/src/pipeline.rs</files>
  <action>
Update `crates/memory-vector/src/pipeline.rs`:

Add imports at top:
```rust
use crate::lifecycle::{VectorLifecycleConfig, PruneStats, is_protected_level, retention_map, cutoff_date};
```

Add method to VectorIndexPipeline impl:

```rust
impl VectorIndexPipeline {
    // ... existing methods ...

    /// Prune vectors per level using configured retention
    ///
    /// Per FR-08 retention rules:
    /// - segment: 30 days
    /// - grip: 30 days
    /// - day: 365 days
    /// - week: 1825 days (5 years)
    /// - month/year: NEVER pruned (protected)
    pub async fn prune_by_lifecycle(
        &self,
        config: &VectorLifecycleConfig,
        dry_run: bool,
    ) -> Result<PruneStats, Error> {
        let mut stats = PruneStats::new();

        if !config.enabled {
            tracing::info!("Vector lifecycle disabled, skipping prune");
            return Ok(stats);
        }

        let retentions = retention_map(config);

        for (level, retention_days) in retentions {
            // Skip protected levels (month/year)
            if is_protected_level(level) {
                tracing::debug!(level, "Skipping protected level");
                continue;
            }

            let cutoff = cutoff_date(retention_days);
            tracing::info!(
                level,
                retention_days,
                cutoff = %cutoff.format("%Y-%m-%d"),
                dry_run,
                "Pruning vectors"
            );

            match self.prune_level(level, cutoff, dry_run).await {
                Ok(count) => {
                    stats.add(level, count);
                    tracing::info!(level, count, "Pruned vectors");
                }
                Err(e) => {
                    let msg = format!("Failed to prune level {}: {}", level, e);
                    tracing::warn!("{}", msg);
                    stats.errors.push(msg);
                }
            }
        }

        // Explicitly log protected levels
        tracing::info!("Skipping month/year vectors (protected, never pruned)");

        Ok(stats)
    }

    /// Prune vectors for a specific level older than cutoff
    async fn prune_level(
        &self,
        level: &str,
        cutoff: DateTime<Utc>,
        dry_run: bool,
    ) -> Result<u32, Error> {
        // Get all doc_ids for this level created before cutoff
        let to_prune = self.find_vectors_by_level_before(level, cutoff).await?;

        if to_prune.is_empty() {
            return Ok(0);
        }

        if dry_run {
            tracing::info!(
                level,
                count = to_prune.len(),
                "Dry run: would prune {} vectors",
                to_prune.len()
            );
            return Ok(to_prune.len() as u32);
        }

        // Delete vectors
        let mut deleted = 0u32;
        for doc_id in &to_prune {
            if let Err(e) = self.delete_vector(doc_id).await {
                tracing::warn!(doc_id, ?e, "Failed to delete vector");
            } else {
                deleted += 1;
            }
        }

        Ok(deleted)
    }

    /// Find vectors by level created before cutoff date
    /// This queries the metadata to find matching vectors
    async fn find_vectors_by_level_before(
        &self,
        level: &str,
        cutoff: DateTime<Utc>,
    ) -> Result<Vec<String>, Error> {
        // Implementation depends on how metadata is stored
        // This would iterate through metadata index and filter by:
        // 1. doc_type matches level
        // 2. created_at < cutoff

        // Placeholder implementation - actual implementation depends on index structure
        let mut matches = Vec::new();

        // If using a metadata CF, iterate and filter:
        // for (doc_id, meta) in self.metadata_iter() {
        //     if meta.doc_type == level && meta.created_at < cutoff {
        //         matches.push(doc_id);
        //     }
        // }

        tracing::debug!(level, count = matches.len(), "Found vectors to prune");
        Ok(matches)
    }

    /// Delete a single vector by doc_id
    async fn delete_vector(&self, doc_id: &str) -> Result<(), Error> {
        // Implementation depends on usearch API
        // Typically: self.index.remove(doc_id_to_key(doc_id))

        // Placeholder - actual implementation uses usearch deletion API
        tracing::debug!(doc_id, "Deleted vector");
        Ok(())
    }
}
```

Note: The actual implementation of `find_vectors_by_level_before` and `delete_vector` depends on the existing usearch wrapper and metadata storage. The executor should adapt these to the actual APIs available in the crate.
  </action>
  <verify>
```bash
cargo build -p memory-vector
cargo test -p memory-vector
```
  </verify>
  <done>prune_by_lifecycle method exists on VectorIndexPipeline with per-level retention logic</done>
</task>

<task type="auto">
  <name>Task 3: Add PruneVectorIndex RPC to proto and create scheduler job</name>
  <files>proto/memory.proto, crates/memory-scheduler/src/jobs/vector_prune.rs, crates/memory-scheduler/src/jobs/mod.rs</files>
  <action>
Update `proto/memory.proto`:

Add after VectorIndexStatus message (around line 595):

```protobuf
// ===== Vector Lifecycle Messages (Phase 16 - FR-08) =====

// Request to prune vector index
message PruneVectorIndexRequest {
    // Optional: prune specific level only ("segment", "grip", "day", "week", or "" for all)
    string level = 1;
    // Override retention days (0 = use config)
    uint32 age_days_override = 2;
    // If true, report what would be pruned without actually deleting
    bool dry_run = 3;
}

// Response from vector prune
message PruneVectorIndexResponse {
    bool success = 1;
    uint32 segments_pruned = 2;
    uint32 grips_pruned = 3;
    uint32 days_pruned = 4;
    uint32 weeks_pruned = 5;
    string message = 6;
}
```

Add RPC to MemoryService (after GetVectorIndexStatus around line 68):

```protobuf
// Prune old vectors per lifecycle policy (FR-08)
rpc PruneVectorIndex(PruneVectorIndexRequest) returns (PruneVectorIndexResponse);
```

Update VectorIndexStatus message to add lifecycle metrics (use field numbers 50+):

```protobuf
// Add to VectorIndexStatus:
int64 last_prune_timestamp = 50;
uint32 last_prune_segments_removed = 51;
uint32 last_prune_grips_removed = 52;
uint32 last_prune_days_removed = 53;
uint32 last_prune_weeks_removed = 54;
// Protected level counts (never pruned)
uint32 month_vectors_count = 55;
uint32 year_vectors_count = 56;
```

Create `crates/memory-scheduler/src/jobs/vector_prune.rs`:

```rust
//! Vector prune scheduler job (FR-08).
//!
//! Calls admin RPC to prune vectors - doesn't own the vector pipeline.

use memory_types::config::VectorLifecycleConfig;
use std::sync::Arc;
use tokio::sync::mpsc;
use tokio_util::sync::CancellationToken;
use tracing;

/// Configuration for vector prune job
#[derive(Debug, Clone)]
pub struct VectorPruneJobConfig {
    /// Cron schedule (default: "0 3 * * *" - daily at 3 AM)
    pub cron_schedule: String,
    /// Lifecycle config
    pub lifecycle: VectorLifecycleConfig,
    /// Whether to run dry-run first
    pub dry_run_first: bool,
}

impl Default for VectorPruneJobConfig {
    fn default() -> Self {
        Self {
            cron_schedule: "0 3 * * *".to_string(),
            lifecycle: VectorLifecycleConfig::default(),
            dry_run_first: false,
        }
    }
}

/// Vector prune job - calls admin RPC
pub struct VectorPruneJob {
    config: VectorPruneJobConfig,
}

impl VectorPruneJob {
    pub fn new(config: VectorPruneJobConfig) -> Self {
        Self { config }
    }

    /// Execute the prune job
    ///
    /// In production, this would call the PruneVectorIndex RPC.
    /// The scheduler doesn't own the vector pipeline - it triggers via RPC.
    pub async fn run(&self, cancel: CancellationToken) -> Result<(), String> {
        if cancel.is_cancelled() {
            return Ok(());
        }

        if !self.config.lifecycle.enabled {
            tracing::debug!("Vector lifecycle disabled, skipping prune job");
            return Ok(());
        }

        tracing::info!("Starting vector prune job");

        // In actual implementation, this calls gRPC:
        // let response = admin_client.prune_vector_index(PruneVectorIndexRequest {
        //     level: String::new(),  // All levels
        //     age_days_override: 0,  // Use config
        //     dry_run: false,
        // }).await?;

        // For now, log that we would prune
        tracing::info!(
            segment_days = self.config.lifecycle.segment_retention_days,
            day_days = self.config.lifecycle.day_retention_days,
            week_days = self.config.lifecycle.week_retention_days,
            "Vector prune job would prune per retention config"
        );

        // Placeholder success
        tracing::info!("Vector prune job completed");
        Ok(())
    }

    /// Get job name
    pub fn name(&self) -> &str {
        "vector_prune"
    }

    /// Get cron schedule
    pub fn cron_schedule(&self) -> &str {
        &self.config.cron_schedule
    }
}

/// Create vector prune job for registration with scheduler
pub fn create_vector_prune_job(config: VectorPruneJobConfig) -> VectorPruneJob {
    VectorPruneJob::new(config)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_job_respects_cancel() {
        let job = VectorPruneJob::new(VectorPruneJobConfig::default());
        let cancel = CancellationToken::new();
        cancel.cancel();

        let result = job.run(cancel).await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_job_skips_when_disabled() {
        let config = VectorPruneJobConfig {
            lifecycle: VectorLifecycleConfig {
                enabled: false,
                ..Default::default()
            },
            ..Default::default()
        };
        let job = VectorPruneJob::new(config);
        let cancel = CancellationToken::new();

        let result = job.run(cancel).await;
        assert!(result.is_ok());
    }
}
```

Update `crates/memory-scheduler/src/jobs/mod.rs` to export:

```rust
pub mod vector_prune;
pub use vector_prune::{VectorPruneJob, VectorPruneJobConfig, create_vector_prune_job};
```
  </action>
  <verify>
```bash
cargo build --workspace
cargo test -p memory-scheduler vector_prune
```
  </verify>
  <done>PruneVectorIndex RPC in proto; VectorPruneJob scheduler job created; workspace builds</done>
</task>

</tasks>

<verification>
After all tasks complete:

```bash
# Full workspace build
cargo build --workspace

# Vector tests
cargo test -p memory-vector --all-features

# Scheduler tests
cargo test -p memory-scheduler --all-features

# Clippy check
cargo clippy -p memory-vector -p memory-scheduler -- -D warnings
```
</verification>

<success_criteria>
1. VectorLifecycleConfig exists with per-level retention defaults (30d segment, 365d day, 1825d week)
2. PruneStats tracks counts per level
3. is_protected_level() returns true for month/year
4. prune_by_lifecycle() skips protected levels
5. PruneVectorIndex RPC defined in proto with level filter and dry_run
6. VectorIndexStatus has lifecycle metrics (last_prune_*, protected counts)
7. VectorPruneJob exists and respects enabled config
8. Scheduler job would call admin RPC (integration wiring deferred)
9. All tests pass, clippy clean
</success_criteria>

<output>
After completion, create `.planning/phases/16-memory-ranking-enhancements/16-04-SUMMARY.md`
</output>
