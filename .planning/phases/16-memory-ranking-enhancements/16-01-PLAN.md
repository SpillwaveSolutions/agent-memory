---
phase: 16-memory-ranking-enhancements
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/memory-types/src/lib.rs
  - crates/memory-types/src/salience.rs
  - crates/memory-types/src/toc.rs
  - crates/memory-types/src/grip.rs
  - crates/memory-types/src/config.rs
  - proto/memory.proto
autonomous: true

must_haves:
  truths:
    - "New TocNodes and Grips include salience_score, memory_kind, and is_pinned fields"
    - "Salience score is calculated once at write time using configurable weights"
    - "Existing v2.0.0 data deserializes correctly with default salience values"
    - "MemoryKind classification uses keyword pattern matching"
  artifacts:
    - path: "crates/memory-types/src/salience.rs"
      provides: "SalienceScorer and MemoryKind enum"
      exports: ["SalienceScorer", "SalienceConfig", "MemoryKind", "calculate_salience"]
    - path: "crates/memory-types/src/toc.rs"
      provides: "TocNode with salience fields"
      contains: "salience_score: f32"
    - path: "crates/memory-types/src/grip.rs"
      provides: "Grip with salience fields"
      contains: "salience_score: f32"
  key_links:
    - from: "crates/memory-types/src/lib.rs"
      to: "crates/memory-types/src/salience.rs"
      via: "pub mod salience"
      pattern: "pub mod salience"
---

<objective>
Add salience scoring fields and logic to memory types for write-time importance calculation.

Purpose: Enable ranking differentiation between memories based on content importance, memory kind (preference/procedure/constraint/definition), and pinned status. Salience is calculated ONCE at node creation respecting the append-only model.

Output: New salience module with scorer, updated TocNode and Grip structs with salience fields, backward-compatible serde defaults for v2.0.0 data.
</objective>

<execution_context>
@/Users/richardhightower/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardhightower/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Technical reference
@docs/plans/phase-16-memory-ranking-plan.md
@crates/memory-types/src/toc.rs
@crates/memory-types/src/grip.rs
@crates/memory-types/src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create salience module with MemoryKind enum and SalienceScorer</name>
  <files>crates/memory-types/src/salience.rs, crates/memory-types/src/lib.rs</files>
  <action>
Create new file `crates/memory-types/src/salience.rs` with:

1. MemoryKind enum with 5 variants:
   - Observation (default, no boost)
   - Preference (matches: "prefer", "like", "avoid", "hate", "dislike")
   - Procedure (matches: "step", "first", "then", "finally", "next")
   - Constraint (matches: "must", "should", "need to", "require", "cannot")
   - Definition (matches: "is defined as", "means", "refers to", "definition")

   Implement Default (Observation), Serialize, Deserialize.

2. SalienceConfig struct with:
   - enabled: bool (default true)
   - length_density_weight: f32 (default 0.45)
   - kind_boost: f32 (default 0.20)
   - pinned_boost: f32 (default 0.20)

   Implement Default.

3. SalienceScorer struct with:
   - config: SalienceConfig
   - Methods:
     - `new(config: SalienceConfig) -> Self`
     - `calculate(&self, text: &str, kind: MemoryKind, is_pinned: bool) -> f32`
       Formula: length_density + kind_boost + pinned_boost
       length_density = (text.len() as f32 / 500.0).min(1.0) * config.length_density_weight
       kind_boost = config.kind_boost if kind != Observation, else 0.0
       pinned_boost = config.pinned_boost if is_pinned, else 0.0
     - `classify_kind(&self, text: &str) -> MemoryKind` - keyword pattern matching

4. Free function `calculate_salience(text: &str, kind: MemoryKind, is_pinned: bool) -> f32`
   with default config.

5. Free function `default_salience() -> f32` returning 0.5 for serde defaults.

Export module in lib.rs: `pub mod salience;` and re-export key types.

Include unit tests for:
- MemoryKind classification (test each keyword pattern)
- Salience calculation (test length density, kind boost, pinned boost)
- Default salience value (0.5)
  </action>
  <verify>
```bash
cargo build -p memory-types
cargo test -p memory-types salience
```
  </verify>
  <done>salience.rs exists with SalienceScorer, MemoryKind enum, and all unit tests pass</done>
</task>

<task type="auto">
  <name>Task 2: Add salience fields to TocNode and Grip with serde defaults</name>
  <files>crates/memory-types/src/toc.rs, crates/memory-types/src/grip.rs</files>
  <action>
Update `crates/memory-types/src/toc.rs`:

1. Add imports: `use crate::salience::{MemoryKind, default_salience};`

2. Add fields to TocNode struct (after `created_at`):
   ```rust
   /// Salience score (0.0-1.0+) computed at creation time
   #[serde(default = "default_salience")]
   pub salience_score: f32,

   /// Classification of memory type (observation, preference, procedure, constraint, definition)
   #[serde(default)]
   pub memory_kind: MemoryKind,

   /// Whether this node is pinned (boosted importance)
   #[serde(default)]
   pub is_pinned: bool,
   ```

3. Update TocNode::new() to initialize:
   - salience_score: 0.5 (default neutral)
   - memory_kind: MemoryKind::Observation
   - is_pinned: false

4. Add builder method: `with_salience(mut self, score: f32, kind: MemoryKind, pinned: bool) -> Self`

Update `crates/memory-types/src/grip.rs`:

1. Add imports: `use crate::salience::{MemoryKind, default_salience};`

2. Add fields to Grip struct (after `toc_node_id`):
   ```rust
   /// Salience score (0.0-1.0+) computed at creation time
   #[serde(default = "default_salience")]
   pub salience_score: f32,

   /// Classification of memory type
   #[serde(default)]
   pub memory_kind: MemoryKind,

   /// Whether this grip is pinned (boosted importance)
   #[serde(default)]
   pub is_pinned: bool,
   ```

3. Update Grip::new() to initialize with defaults.

4. Add builder method: `with_salience(mut self, score: f32, kind: MemoryKind, pinned: bool) -> Self`

Add backward compatibility tests in both files:
- Deserialize JSON without salience fields -> defaults applied
- Round-trip serialization preserves salience fields
  </action>
  <verify>
```bash
cargo build -p memory-types
cargo test -p memory-types toc
cargo test -p memory-types grip
```
  </verify>
  <done>TocNode and Grip have salience_score, memory_kind, is_pinned fields with serde defaults; backward compat tests pass</done>
</task>

<task type="auto">
  <name>Task 3: Add salience fields to proto and update config</name>
  <files>proto/memory.proto, crates/memory-types/src/config.rs</files>
  <action>
Update `proto/memory.proto`:

1. Add MemoryKind enum (after existing enums, around line 115):
   ```protobuf
   // Classification of memory type for salience scoring
   enum MemoryKind {
       MEMORY_KIND_UNSPECIFIED = 0;
       MEMORY_KIND_OBSERVATION = 1;
       MEMORY_KIND_PREFERENCE = 2;
       MEMORY_KIND_PROCEDURE = 3;
       MEMORY_KIND_CONSTRAINT = 4;
       MEMORY_KIND_DEFINITION = 5;
   }
   ```

2. Add fields to TocNode message (use field numbers > 100 to avoid conflicts):
   ```protobuf
   // Salience score (0.0-1.0+), default 0.5 for neutral
   float salience_score = 101;
   // Memory type classification
   MemoryKind memory_kind = 102;
   // Whether node is pinned
   bool is_pinned = 103;
   ```

3. Add fields to Grip message (field numbers > 10):
   ```protobuf
   // Salience score (0.0-1.0+), default 0.5 for neutral
   float salience_score = 11;
   // Memory type classification
   MemoryKind memory_kind = 12;
   // Whether grip is pinned
   bool is_pinned = 13;
   ```

Update `crates/memory-types/src/config.rs`:

1. Add SalienceConfig section (if not already present from salience.rs import):
   - Re-export from salience module or add config validation

2. Add RankingConfig struct:
   ```rust
   #[derive(Debug, Clone, Serialize, Deserialize)]
   pub struct RankingConfig {
       /// Master switch for all ranking enhancements
       #[serde(default = "default_true")]
       pub enabled: bool,
       /// Salience scoring configuration
       #[serde(default)]
       pub salience: SalienceConfig,
   }
   ```

3. Add to main Config struct if exists, or document where it should go.
  </action>
  <verify>
```bash
cargo build --workspace
cargo test -p memory-types
```
  </verify>
  <done>Proto has MemoryKind enum and salience fields; config has RankingConfig with salience settings</done>
</task>

</tasks>

<verification>
After all tasks complete:

```bash
# Full workspace build
cargo build --workspace

# All memory-types tests
cargo test -p memory-types --all-features

# Verify backward compatibility
cargo test -p memory-types compat

# Clippy check
cargo clippy -p memory-types -- -D warnings
```
</verification>

<success_criteria>
1. salience.rs module exists with SalienceScorer, MemoryKind, SalienceConfig
2. TocNode has salience_score, memory_kind, is_pinned fields with #[serde(default)]
3. Grip has salience_score, memory_kind, is_pinned fields with #[serde(default)]
4. Proto has MemoryKind enum and salience fields on TocNode and Grip
5. Existing v2.0.0 JSON deserializes with default values (salience=0.5, kind=Observation, pinned=false)
6. All unit tests pass
7. Clippy passes with no warnings
</success_criteria>

<output>
After completion, create `.planning/phases/16-memory-ranking-enhancements/16-01-SUMMARY.md`
</output>
