---
phase: 11-bm25-teleport-tantivy
plan: 04
type: execute
wave: 3
depends_on: ["11-02", "11-03"]
files_modified:
  - crates/memory-daemon/src/commands.rs
  - crates/memory-daemon/src/cli.rs
  - crates/memory-daemon/Cargo.toml
  - crates/memory-scheduler/src/jobs/mod.rs
  - crates/memory-scheduler/src/jobs/search.rs
  - crates/memory-scheduler/Cargo.toml
autonomous: true

must_haves:
  truths:
    - "CLI provides `teleport search <query>` command"
    - "Index commit job runs on schedule"
    - "Search results display in CLI with scores"
    - "Daemon initializes search index on startup"
  artifacts:
    - path: "crates/memory-daemon/src/cli.rs"
      provides: "Teleport CLI subcommand"
      contains: "teleport"
    - path: "crates/memory-scheduler/src/jobs/search.rs"
      provides: "Index commit scheduled job"
      exports: ["create_index_commit_job", "IndexCommitJobConfig"]
  key_links:
    - from: "crates/memory-daemon/src/commands.rs"
      to: "memory_search::SearchIndex"
      via: "initializes search index on daemon start"
      pattern: "SearchIndex::open_or_create"
    - from: "crates/memory-scheduler/src/jobs/search.rs"
      to: "memory_search::SearchIndexer"
      via: "periodic commit job"
      pattern: "indexer.commit"
---

<objective>
Add CLI teleport command and background index commit job.

Purpose: Enable testing teleport search via CLI and ensure index commits happen periodically.
Output: `teleport search` CLI command, scheduled index commit job, daemon integration.
</objective>

<execution_context>
@/Users/richardhightower/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardhightower/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/11-bm25-teleport-tantivy/11-RESEARCH.md
@.planning/phases/11-bm25-teleport-tantivy/11-01-SUMMARY.md
@.planning/phases/11-bm25-teleport-tantivy/11-02-SUMMARY.md
@.planning/phases/11-bm25-teleport-tantivy/11-03-SUMMARY.md
@crates/memory-daemon/src/cli.rs
@crates/memory-daemon/src/commands.rs
@crates/memory-scheduler/src/jobs/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add teleport CLI subcommand</name>
  <files>
    crates/memory-daemon/src/cli.rs
    crates/memory-daemon/Cargo.toml
  </files>
  <action>
Add teleport subcommand to the daemon CLI:

1. Update `crates/memory-daemon/Cargo.toml`:
   - Add: memory-search = { workspace = true }
   - Add: memory-client = { workspace = true }

2. Update `crates/memory-daemon/src/cli.rs`:
   - Add TeleportCommand to the Subcommand enum:
   ```rust
   /// Teleport search commands
   #[command(subcommand)]
   Teleport(TeleportCommand),
   ```

   - Add TeleportCommand enum:
   ```rust
   /// Teleport (BM25 search) commands
   #[derive(Debug, Clone, Subcommand)]
   pub enum TeleportCommand {
       /// Search for TOC nodes or grips by keyword
       Search {
           /// Search query (keywords)
           query: String,

           /// Filter by document type: all, toc, grip
           #[arg(long, short = 't', default_value = "all")]
           doc_type: String,

           /// Maximum results to return
           #[arg(long, short = 'n', default_value = "10")]
           limit: usize,

           /// gRPC server address
           #[arg(long, default_value = "http://127.0.0.1:50051")]
           addr: String,
       },

       /// Show index statistics
       Stats {
           /// gRPC server address
           #[arg(long, default_value = "http://127.0.0.1:50051")]
           addr: String,
       },

       /// Rebuild the search index from storage
       Rebuild {
           /// gRPC server address (for triggering rebuild)
           #[arg(long, default_value = "http://127.0.0.1:50051")]
           addr: String,
       },
   }
   ```
  </action>
  <verify>
    cd /Users/richardhightower/clients/spillwave/src/agent-memory && cargo check -p memory-daemon
  </verify>
  <done>
    TeleportCommand added to CLI with search, stats, and rebuild subcommands.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement teleport command handlers</name>
  <files>
    crates/memory-daemon/src/commands.rs
  </files>
  <action>
Implement the teleport command handlers:

1. Add to `crates/memory-daemon/src/commands.rs`:
   ```rust
   use crate::cli::TeleportCommand;

   /// Handle teleport commands
   pub async fn handle_teleport_command(cmd: TeleportCommand) -> Result<(), MemoryError> {
       match cmd {
           TeleportCommand::Search { query, doc_type, limit, addr } => {
               teleport_search(&query, &doc_type, limit, &addr).await
           }
           TeleportCommand::Stats { addr } => {
               teleport_stats(&addr).await
           }
           TeleportCommand::Rebuild { addr } => {
               teleport_rebuild(&addr).await
           }
       }
   }

   /// Execute teleport search via gRPC
   async fn teleport_search(
       query: &str,
       doc_type: &str,
       limit: usize,
       addr: &str,
   ) -> Result<(), MemoryError> {
       use memory_client::MemoryClient;

       println!("Searching for: \"{}\"", query);
       println!("Filter: {}, Limit: {}", doc_type, limit);
       println!();

       let mut client = MemoryClient::connect(addr).await
           .map_err(|e| MemoryError::Grpc(e.to_string()))?;

       // Map doc_type string to enum value
       let doc_type_value = match doc_type.to_lowercase().as_str() {
           "toc" | "toc_node" => 1,  // TeleportDocType::TocNode
           "grip" | "grips" => 2,    // TeleportDocType::Grip
           _ => 0,                    // TeleportDocType::Unspecified (all)
       };

       let response = client.teleport_search(query, doc_type_value, limit as i32).await
           .map_err(|e| MemoryError::Grpc(e.to_string()))?;

       if response.results.is_empty() {
           println!("No results found.");
           return Ok(());
       }

       println!("Found {} results:", response.results.len());
       println!("{:-<60}", "");

       for (i, result) in response.results.iter().enumerate() {
           let type_str = match result.doc_type {
               1 => "TOC",
               2 => "Grip",
               _ => "?",
           };

           println!("{}. [{}] {} (score: {:.4})",
               i + 1,
               type_str,
               result.doc_id,
               result.score
           );

           if let Some(ref keywords) = result.keywords {
               if !keywords.is_empty() {
                   println!("   Keywords: {}", keywords);
               }
           }
       }

       println!("{:-<60}", "");
       println!("Total documents in index: {}", response.total_docs);

       Ok(())
   }

   /// Show teleport index statistics
   async fn teleport_stats(addr: &str) -> Result<(), MemoryError> {
       use memory_client::MemoryClient;

       let mut client = MemoryClient::connect(addr).await
           .map_err(|e| MemoryError::Grpc(e.to_string()))?;

       // Use empty search to get total_docs
       let response = client.teleport_search("", 0, 0).await
           .map_err(|e| MemoryError::Grpc(e.to_string()))?;

       println!("Teleport Index Statistics");
       println!("{:-<40}", "");
       println!("Total documents: {}", response.total_docs);

       Ok(())
   }

   /// Trigger index rebuild (placeholder - will be implemented in Phase 13)
   async fn teleport_rebuild(_addr: &str) -> Result<(), MemoryError> {
       println!("Index rebuild not yet implemented.");
       println!("This will be available in Phase 13 (Outbox Index Ingestion).");
       Ok(())
   }
   ```

2. Update main.rs to handle TeleportCommand in the match statement:
   ```rust
   Subcommand::Teleport(cmd) => {
       commands::handle_teleport_command(cmd).await?;
   }
   ```

3. Add teleport_search method to MemoryClient (in memory-client crate) if not exists:
   ```rust
   pub async fn teleport_search(
       &mut self,
       query: &str,
       doc_type: i32,
       limit: i32,
   ) -> Result<TeleportSearchResponse, tonic::Status> {
       let request = TeleportSearchRequest {
           query: query.to_string(),
           doc_type,
           limit,
       };
       let response = self.client.teleport_search(request).await?;
       Ok(response.into_inner())
   }
   ```
  </action>
  <verify>
    cd /Users/richardhightower/clients/spillwave/src/agent-memory && cargo build -p memory-daemon
  </verify>
  <done>
    Teleport CLI commands implemented. Search displays results with scores.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add index commit scheduled job</name>
  <files>
    crates/memory-scheduler/src/jobs/search.rs
    crates/memory-scheduler/src/jobs/mod.rs
    crates/memory-scheduler/src/lib.rs
    crates/memory-scheduler/Cargo.toml
  </files>
  <action>
Create the scheduled index commit job:

1. Update `crates/memory-scheduler/Cargo.toml`:
   - Add: memory-search = { workspace = true }

2. Create `crates/memory-scheduler/src/jobs/search.rs`:
   ```rust
   //! Search index scheduled jobs.
   //!
   //! Periodic commit job to make indexed documents searchable.

   use std::sync::Arc;

   use serde::{Deserialize, Serialize};

   use memory_search::SearchIndexer;

   use crate::{
       JitterConfig, OverlapPolicy, SchedulerError, SchedulerService,
   };

   /// Configuration for index commit job
   #[derive(Debug, Clone, Serialize, Deserialize)]
   pub struct IndexCommitJobConfig {
       /// Cron expression (default: "0 * * * * *" = every minute)
       pub cron: String,
       /// Timezone (default: "UTC")
       pub timezone: String,
       /// Max jitter in seconds (default: 10)
       pub jitter_secs: u64,
   }

   impl Default for IndexCommitJobConfig {
       fn default() -> Self {
           Self {
               cron: "0 * * * * *".to_string(),  // Every minute
               timezone: "UTC".to_string(),
               jitter_secs: 10,
           }
       }
   }

   /// Register the index commit job with the scheduler.
   ///
   /// This job periodically commits the search index to make
   /// newly indexed documents visible to search queries.
   pub async fn create_index_commit_job(
       scheduler: &SchedulerService,
       indexer: Arc<SearchIndexer>,
       config: IndexCommitJobConfig,
   ) -> Result<(), SchedulerError> {
       scheduler.register_job(
           "search_index_commit",
           &config.cron,
           Some(&config.timezone),
           OverlapPolicy::Skip,
           JitterConfig::new(config.jitter_secs),
           move || {
               let indexer = indexer.clone();
               async move {
                   match indexer.commit() {
                       Ok(opstamp) => {
                           tracing::debug!(opstamp, "Search index committed");
                           Ok(())
                       }
                       Err(e) => {
                           tracing::warn!(error = %e, "Search index commit failed");
                           Err(e.to_string())
                       }
                   }
               }
           },
       ).await?;

       tracing::info!("Registered search index commit job");
       Ok(())
   }

   #[cfg(test)]
   mod tests {
       use super::*;

       #[test]
       fn test_default_config() {
           let config = IndexCommitJobConfig::default();
           assert_eq!(config.cron, "0 * * * * *");
           assert_eq!(config.timezone, "UTC");
           assert_eq!(config.jitter_secs, 10);
       }
   }
   ```

3. Update `crates/memory-scheduler/src/jobs/mod.rs`:
   ```rust
   pub mod search;
   ```

4. Update `crates/memory-scheduler/src/lib.rs` to export:
   ```rust
   pub use jobs::search::{create_index_commit_job, IndexCommitJobConfig};
   ```
  </action>
  <verify>
    cd /Users/richardhightower/clients/spillwave/src/agent-memory && cargo check -p memory-scheduler
  </verify>
  <done>
    Index commit job defined with configurable schedule. Job commits every minute by default.
  </done>
</task>

</tasks>

<verification>
```bash
cd /Users/richardhightower/clients/spillwave/src/agent-memory

# CLI builds with teleport commands
cargo build -p memory-daemon

# Test CLI help
./target/debug/memory-daemon teleport --help
./target/debug/memory-daemon teleport search --help

# Scheduler builds with search job
cargo build -p memory-scheduler

# Full workspace builds
cargo build

# Tests pass
cargo test -p memory-search
cargo test -p memory-scheduler

# Clippy clean
cargo clippy -- -D warnings
```
</verification>

<success_criteria>
- [ ] `memory-daemon teleport search <query>` works
- [ ] Search results display with doc_id, type, and score
- [ ] `memory-daemon teleport stats` shows index statistics
- [ ] IndexCommitJobConfig has sensible defaults (every minute)
- [ ] create_index_commit_job registers with scheduler
- [ ] memory-daemon depends on memory-search
- [ ] memory-scheduler depends on memory-search
- [ ] All tests pass
- [ ] No clippy warnings
</success_criteria>

<output>
After completion, create `.planning/phases/11-bm25-teleport-tantivy/11-04-SUMMARY.md`
</output>
