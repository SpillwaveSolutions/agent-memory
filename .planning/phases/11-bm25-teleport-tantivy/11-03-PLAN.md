---
phase: 11-bm25-teleport-tantivy
plan: 03
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
  - crates/memory-search/src/searcher.rs
  - crates/memory-search/src/lib.rs
  - proto/memory.proto
  - crates/memory-service/src/handlers/teleport.rs
  - crates/memory-service/src/handlers/mod.rs
  - crates/memory-service/src/server.rs
  - crates/memory-service/Cargo.toml
autonomous: true

must_haves:
  truths:
    - "BM25 search returns ranked results with scores"
    - "Search can filter by document type (toc_node or grip)"
    - "gRPC TeleportSearch RPC accepts query and returns results"
    - "Results include doc_id, doc_type, and relevance score"
  artifacts:
    - path: "crates/memory-search/src/searcher.rs"
      provides: "TeleportSearcher for BM25 queries"
      exports: ["TeleportSearcher", "TeleportResult"]
    - path: "proto/memory.proto"
      provides: "TeleportSearch RPC definition"
      contains: "rpc TeleportSearch"
    - path: "crates/memory-service/src/handlers/teleport.rs"
      provides: "gRPC handler for teleport search"
      exports: ["handle_teleport_search"]
  key_links:
    - from: "crates/memory-search/src/searcher.rs"
      to: "tantivy::query::QueryParser"
      via: "parses query string to BM25 query"
      pattern: "QueryParser::for_index"
    - from: "crates/memory-search/src/searcher.rs"
      to: "tantivy::collector::TopDocs"
      via: "collects top-N results with scores"
      pattern: "TopDocs::with_limit"
    - from: "crates/memory-service/src/handlers/teleport.rs"
      to: "memory_search::TeleportSearcher"
      via: "delegates search to TeleportSearcher"
      pattern: "TeleportSearcher"
---

<objective>
Implement the search API with BM25 ranking and gRPC exposure.

Purpose: Enable keyword search that returns ranked TOC node IDs or grip pointers with relevance scores.
Output: TeleportSearcher for BM25 queries, TeleportSearch gRPC RPC, and handler integration.
</objective>

<execution_context>
@/Users/richardhightower/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardhightower/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/11-bm25-teleport-tantivy/11-RESEARCH.md
@.planning/phases/11-bm25-teleport-tantivy/11-01-SUMMARY.md
@crates/memory-search/src/schema.rs
@crates/memory-search/src/index.rs
@proto/memory.proto
@crates/memory-service/src/server.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement TeleportSearcher with BM25 queries</name>
  <files>
    crates/memory-search/src/searcher.rs
    crates/memory-search/src/lib.rs
  </files>
  <action>
Create the search implementation:

1. Create `crates/memory-search/src/searcher.rs`:
   ```rust
   //! Search implementation using BM25 scoring.
   //!
   //! Provides keyword search over TOC nodes and grips.

   use tantivy::collector::TopDocs;
   use tantivy::query::{BooleanQuery, Occur, QueryParser, TermQuery};
   use tantivy::schema::IndexRecordOption;
   use tantivy::{IndexReader, ReloadPolicy, Score, Term};
   use tracing::{debug, info};

   use crate::error::SearchError;
   use crate::index::SearchIndex;
   use crate::schema::{DocType, SearchSchema};

   /// A search result with relevance score.
   #[derive(Debug, Clone)]
   pub struct TeleportResult {
       /// Document ID (node_id or grip_id)
       pub doc_id: String,
       /// Document type
       pub doc_type: DocType,
       /// BM25 relevance score
       pub score: f32,
       /// Keywords from the document (if stored)
       pub keywords: Option<String>,
       /// Timestamp in milliseconds
       pub timestamp_ms: Option<i64>,
   }

   /// Search options for filtering and limiting results.
   #[derive(Debug, Clone, Default)]
   pub struct SearchOptions {
       /// Filter by document type (None = all types)
       pub doc_type: Option<DocType>,
       /// Maximum results to return
       pub limit: usize,
   }

   impl SearchOptions {
       pub fn new() -> Self {
           Self {
               doc_type: None,
               limit: 10,
           }
       }

       pub fn with_limit(mut self, limit: usize) -> Self {
           self.limit = limit;
           self
       }

       pub fn with_doc_type(mut self, doc_type: DocType) -> Self {
           self.doc_type = Some(doc_type);
           self
       }

       pub fn toc_only() -> Self {
           Self::new().with_doc_type(DocType::TocNode)
       }

       pub fn grips_only() -> Self {
           Self::new().with_doc_type(DocType::Grip)
       }
   }

   /// Searcher for teleport queries using BM25 ranking.
   pub struct TeleportSearcher {
       reader: IndexReader,
       schema: SearchSchema,
       query_parser: QueryParser,
   }

   impl TeleportSearcher {
       /// Create a new searcher from a SearchIndex.
       pub fn new(index: &SearchIndex) -> Result<Self, SearchError> {
           let reader = index.reader()?;
           let schema = index.schema().clone();

           // Create query parser targeting text and keywords fields
           let query_parser = QueryParser::for_index(
               index.index(),
               vec![schema.text, schema.keywords],
           );

           Ok(Self {
               reader,
               schema,
               query_parser,
           })
       }

       /// Reload the reader to see recent commits.
       pub fn reload(&self) -> Result<(), SearchError> {
           self.reader.reload()?;
           debug!("Reloaded search reader");
           Ok(())
       }

       /// Search with a query string.
       ///
       /// Uses BM25 scoring over text and keywords fields.
       pub fn search(&self, query_str: &str, options: SearchOptions) -> Result<Vec<TeleportResult>, SearchError> {
           if query_str.trim().is_empty() {
               return Ok(Vec::new());
           }

           let searcher = self.reader.searcher();

           // Parse the text query
           let text_query = self.query_parser.parse_query(query_str)?;

           // Apply document type filter if specified
           let final_query = if let Some(doc_type) = options.doc_type {
               let type_term = Term::from_field_text(self.schema.doc_type, doc_type.as_str());
               let type_query = TermQuery::new(type_term, IndexRecordOption::Basic);

               Box::new(BooleanQuery::new(vec![
                   (Occur::Must, text_query),
                   (Occur::Must, Box::new(type_query)),
               ]))
           } else {
               text_query
           };

           // Execute search
           let top_docs = searcher.search(&final_query, &TopDocs::with_limit(options.limit))?;

           // Map results
           let mut results = Vec::with_capacity(top_docs.len());
           for (score, doc_address) in top_docs {
               let doc: tantivy::TantivyDocument = searcher.doc(doc_address)?;

               // Extract fields
               let doc_type_str = doc
                   .get_first(self.schema.doc_type)
                   .and_then(|v| v.as_str())
                   .unwrap_or("");

               let doc_id = doc
                   .get_first(self.schema.doc_id)
                   .and_then(|v| v.as_str())
                   .unwrap_or("")
                   .to_string();

               let keywords = doc
                   .get_first(self.schema.keywords)
                   .and_then(|v| v.as_str())
                   .map(|s| s.to_string())
                   .filter(|s| !s.is_empty());

               let timestamp_ms = doc
                   .get_first(self.schema.timestamp_ms)
                   .and_then(|v| v.as_str())
                   .and_then(|s| s.parse::<i64>().ok());

               let doc_type = DocType::from_str(doc_type_str)
                   .unwrap_or(DocType::TocNode);

               results.push(TeleportResult {
                   doc_id,
                   doc_type,
                   score,
                   keywords,
                   timestamp_ms,
               });
           }

           info!(
               query = query_str,
               results = results.len(),
               "Teleport search complete"
           );

           Ok(results)
       }

       /// Search TOC nodes only.
       pub fn search_toc(&self, query_str: &str, limit: usize) -> Result<Vec<TeleportResult>, SearchError> {
           self.search(query_str, SearchOptions::toc_only().with_limit(limit))
       }

       /// Search grips only.
       pub fn search_grips(&self, query_str: &str, limit: usize) -> Result<Vec<TeleportResult>, SearchError> {
           self.search(query_str, SearchOptions::grips_only().with_limit(limit))
       }

       /// Get the number of indexed documents.
       pub fn num_docs(&self) -> u64 {
           let searcher = self.reader.searcher();
           searcher.segment_readers()
               .iter()
               .map(|r| r.num_docs() as u64)
               .sum()
       }
   }

   #[cfg(test)]
   mod tests {
       use super::*;
       use crate::index::{SearchIndex, SearchIndexConfig};
       use crate::indexer::SearchIndexer;
       use chrono::Utc;
       use memory_types::{Grip, TocBullet, TocLevel, TocNode};
       use tempfile::TempDir;

       fn sample_toc_node(id: &str, title: &str, bullet: &str) -> TocNode {
           let mut node = TocNode::new(
               id.to_string(),
               TocLevel::Day,
               title.to_string(),
               Utc::now(),
               Utc::now(),
           );
           node.bullets = vec![TocBullet::new(bullet)];
           node.keywords = vec!["test".to_string()];
           node
       }

       fn sample_grip(id: &str, excerpt: &str) -> Grip {
           Grip::new(
               id.to_string(),
               excerpt.to_string(),
               "event-001".to_string(),
               "event-002".to_string(),
               Utc::now(),
               "test".to_string(),
           )
       }

       fn setup_index() -> (TempDir, SearchIndex) {
           let temp_dir = TempDir::new().unwrap();
           let config = SearchIndexConfig::new(temp_dir.path());
           let index = SearchIndex::open_or_create(config).unwrap();
           (temp_dir, index)
       }

       #[test]
       fn test_search_toc_nodes() {
           let (_temp_dir, index) = setup_index();
           let indexer = SearchIndexer::new(&index).unwrap();

           // Index some nodes
           let node1 = sample_toc_node("node-1", "Rust Memory Safety", "Discussed borrow checker");
           let node2 = sample_toc_node("node-2", "Python Performance", "Talked about async/await");

           indexer.index_toc_node(&node1).unwrap();
           indexer.index_toc_node(&node2).unwrap();
           indexer.commit().unwrap();

           let searcher = TeleportSearcher::new(&index).unwrap();

           // Search for "rust"
           let results = searcher.search_toc("rust", 10).unwrap();
           assert_eq!(results.len(), 1);
           assert_eq!(results[0].doc_id, "node-1");
           assert!(results[0].score > 0.0);
       }

       #[test]
       fn test_search_grips() {
           let (_temp_dir, index) = setup_index();
           let indexer = SearchIndexer::new(&index).unwrap();

           let grip1 = sample_grip("grip-1", "User asked about memory allocation");
           let grip2 = sample_grip("grip-2", "Discussed database performance");

           indexer.index_grip(&grip1).unwrap();
           indexer.index_grip(&grip2).unwrap();
           indexer.commit().unwrap();

           let searcher = TeleportSearcher::new(&index).unwrap();

           let results = searcher.search_grips("memory", 10).unwrap();
           assert_eq!(results.len(), 1);
           assert_eq!(results[0].doc_id, "grip-1");
       }

       #[test]
       fn test_search_all_types() {
           let (_temp_dir, index) = setup_index();
           let indexer = SearchIndexer::new(&index).unwrap();

           let node = sample_toc_node("node-1", "Memory Discussion", "Talked about allocation");
           let grip = sample_grip("grip-1", "Memory allocation in Rust");

           indexer.index_toc_node(&node).unwrap();
           indexer.index_grip(&grip).unwrap();
           indexer.commit().unwrap();

           let searcher = TeleportSearcher::new(&index).unwrap();

           // Search all types
           let results = searcher.search("memory", SearchOptions::new().with_limit(10)).unwrap();
           assert_eq!(results.len(), 2);
       }

       #[test]
       fn test_bm25_ranking() {
           let (_temp_dir, index) = setup_index();
           let indexer = SearchIndexer::new(&index).unwrap();

           // Node with "rust" once
           let node1 = sample_toc_node("node-1", "Rust basics", "Introduction");
           // Node with "rust" multiple times
           let node2 = sample_toc_node("node-2", "Advanced Rust", "Deep dive into Rust ownership and Rust lifetimes");

           indexer.index_toc_node(&node1).unwrap();
           indexer.index_toc_node(&node2).unwrap();
           indexer.commit().unwrap();

           let searcher = TeleportSearcher::new(&index).unwrap();

           let results = searcher.search_toc("rust", 10).unwrap();
           assert_eq!(results.len(), 2);
           // Node2 should rank higher (more occurrences of "rust")
           assert_eq!(results[0].doc_id, "node-2");
           assert!(results[0].score > results[1].score);
       }

       #[test]
       fn test_empty_query() {
           let (_temp_dir, index) = setup_index();
           let searcher = TeleportSearcher::new(&index).unwrap();

           let results = searcher.search("", SearchOptions::new()).unwrap();
           assert!(results.is_empty());
       }

       #[test]
       fn test_num_docs() {
           let (_temp_dir, index) = setup_index();
           let indexer = SearchIndexer::new(&index).unwrap();

           indexer.index_toc_node(&sample_toc_node("node-1", "Test", "Content")).unwrap();
           indexer.index_grip(&sample_grip("grip-1", "Excerpt")).unwrap();
           indexer.commit().unwrap();

           let searcher = TeleportSearcher::new(&index).unwrap();
           assert_eq!(searcher.num_docs(), 2);
       }
   }
   ```

2. Update lib.rs exports:
   ```rust
   pub mod searcher;
   pub use searcher::{TeleportSearcher, TeleportResult, SearchOptions};
   ```
  </action>
  <verify>
    cd /Users/richardhightower/clients/spillwave/src/agent-memory && cargo test -p memory-search searcher
  </verify>
  <done>
    TeleportSearcher performs BM25 search with filtering. Results include scores for ranking.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add TeleportSearch RPC to proto and service</name>
  <files>
    proto/memory.proto
    crates/memory-service/src/handlers/teleport.rs
    crates/memory-service/src/handlers/mod.rs
    crates/memory-service/src/server.rs
    crates/memory-service/Cargo.toml
  </files>
  <action>
Add gRPC RPC for teleport search:

1. Update `proto/memory.proto` - Add after existing RPCs in MemoryService:
   ```protobuf
   // Teleport RPCs (TEL-01 through TEL-04)

   // Search for TOC nodes or grips by keyword
   rpc TeleportSearch(TeleportSearchRequest) returns (TeleportSearchResponse);
   ```

   Add message definitions after scheduler messages:
   ```protobuf
   // ===== Teleport Search Messages (TEL-01 through TEL-04) =====

   // Document type filter for teleport search
   enum TeleportDocType {
       TELEPORT_DOC_TYPE_UNSPECIFIED = 0;  // Search all types
       TELEPORT_DOC_TYPE_TOC_NODE = 1;     // TOC nodes only
       TELEPORT_DOC_TYPE_GRIP = 2;         // Grips only
   }

   // Request for teleport search
   message TeleportSearchRequest {
       // Search query (keywords)
       string query = 1;
       // Filter by document type (optional)
       TeleportDocType doc_type = 2;
       // Maximum results to return (default: 10)
       int32 limit = 3;
   }

   // A single teleport search result
   message TeleportSearchResult {
       // Document ID (node_id or grip_id)
       string doc_id = 1;
       // Document type
       TeleportDocType doc_type = 2;
       // BM25 relevance score
       float score = 3;
       // Keywords from the document (if available)
       optional string keywords = 4;
       // Timestamp in milliseconds
       optional int64 timestamp_ms = 5;
   }

   // Response from teleport search
   message TeleportSearchResponse {
       // Ranked search results
       repeated TeleportSearchResult results = 1;
       // Total documents in index
       uint64 total_docs = 2;
   }
   ```

2. Update `crates/memory-service/Cargo.toml`:
   - Add: memory-search = { workspace = true }

3. Create `crates/memory-service/src/handlers/teleport.rs`:
   ```rust
   //! Teleport search handler.

   use std::sync::Arc;

   use memory_search::{DocType, SearchOptions, TeleportSearcher};
   use tonic::{Request, Response, Status};
   use tracing::debug;

   use crate::proto::{
       TeleportDocType, TeleportSearchRequest, TeleportSearchResponse, TeleportSearchResult,
   };

   /// Handle TeleportSearch RPC.
   pub async fn handle_teleport_search(
       searcher: Arc<TeleportSearcher>,
       request: Request<TeleportSearchRequest>,
   ) -> Result<Response<TeleportSearchResponse>, Status> {
       let req = request.into_inner();

       debug!(query = %req.query, "Processing teleport search");

       // Build search options
       let mut options = SearchOptions::new();

       // Set limit (default 10, max 100)
       let limit = if req.limit > 0 {
           (req.limit as usize).min(100)
       } else {
           10
       };
       options = options.with_limit(limit);

       // Set doc type filter
       if req.doc_type == TeleportDocType::TocNode as i32 {
           options = options.with_doc_type(DocType::TocNode);
       } else if req.doc_type == TeleportDocType::Grip as i32 {
           options = options.with_doc_type(DocType::Grip);
       }

       // Execute search (blocking operation, use spawn_blocking)
       let query = req.query.clone();
       let results = tokio::task::spawn_blocking(move || {
           searcher.search(&query, options)
       })
       .await
       .map_err(|e| Status::internal(format!("Search task failed: {}", e)))?
       .map_err(|e| Status::internal(format!("Search failed: {}", e)))?;

       // Map to proto results
       let proto_results: Vec<TeleportSearchResult> = results
           .into_iter()
           .map(|r| TeleportSearchResult {
               doc_id: r.doc_id,
               doc_type: match r.doc_type {
                   DocType::TocNode => TeleportDocType::TocNode as i32,
                   DocType::Grip => TeleportDocType::Grip as i32,
               },
               score: r.score,
               keywords: r.keywords,
               timestamp_ms: r.timestamp_ms,
           })
           .collect();

       // Get total docs for info
       // Note: This is approximate after commits
       let total_docs = 0; // Will be filled from searcher.num_docs() if available

       Ok(Response::new(TeleportSearchResponse {
           results: proto_results,
           total_docs,
       }))
   }
   ```

4. Update `crates/memory-service/src/handlers/mod.rs`:
   - Add: pub mod teleport;

5. Update server.rs to include TeleportSearch handler in the service implementation.
   The service needs to hold an Arc<TeleportSearcher> and call handle_teleport_search.

   In MemoryServiceImpl struct, add:
   ```rust
   searcher: Option<Arc<TeleportSearcher>>,
   ```

   In the TeleportSearch method:
   ```rust
   async fn teleport_search(
       &self,
       request: Request<TeleportSearchRequest>,
   ) -> Result<Response<TeleportSearchResponse>, Status> {
       match &self.searcher {
           Some(searcher) => {
               handlers::teleport::handle_teleport_search(searcher.clone(), request).await
           }
           None => Err(Status::unavailable("Search index not configured")),
       }
   }
   ```

Note: The searcher is optional because the daemon may not have search configured.
This allows graceful degradation when BM25 index is not available.
  </action>
  <verify>
    cd /Users/richardhightower/clients/spillwave/src/agent-memory && cargo build -p memory-service
  </verify>
  <done>
    TeleportSearch RPC defined in proto. Handler uses spawn_blocking for Tantivy operations.
  </done>
</task>

</tasks>

<verification>
```bash
cd /Users/richardhightower/clients/spillwave/src/agent-memory

# Rebuild protos
cargo build -p memory-service

# Searcher tests pass
cargo test -p memory-search searcher

# Full search crate tests
cargo test -p memory-search

# Service builds with teleport handler
cargo build -p memory-service

# Clippy clean
cargo clippy -p memory-search -p memory-service -- -D warnings
```
</verification>

<success_criteria>
- [ ] TeleportSearcher performs BM25 search over text and keywords fields
- [ ] SearchOptions supports doc_type filtering and limit
- [ ] TeleportResult includes doc_id, doc_type, score, keywords, timestamp
- [ ] search_toc and search_grips convenience methods work
- [ ] TeleportSearch RPC defined in memory.proto
- [ ] Handler uses spawn_blocking for Tantivy operations
- [ ] Service gracefully handles missing search index
- [ ] All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/11-bm25-teleport-tantivy/11-03-SUMMARY.md`
</output>
