---
phase: 11-bm25-teleport-tantivy
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - crates/memory-search/Cargo.toml
  - crates/memory-search/src/lib.rs
  - crates/memory-search/src/schema.rs
  - crates/memory-search/src/index.rs
  - crates/memory-search/src/error.rs
  - crates/memory-types/src/config.rs
autonomous: true

must_haves:
  truths:
    - "Tantivy index can be created and opened"
    - "Schema defines searchable fields for TOC nodes and grips"
    - "Index path is configurable via Settings"
    - "Index survives restart (MmapDirectory persistence)"
  artifacts:
    - path: "crates/memory-search/Cargo.toml"
      provides: "Search crate dependencies"
      contains: "tantivy"
    - path: "crates/memory-search/src/schema.rs"
      provides: "Tantivy schema definition"
      exports: ["SearchSchema", "build_teleport_schema"]
    - path: "crates/memory-search/src/index.rs"
      provides: "Index creation and management"
      exports: ["SearchIndex", "open_or_create_index"]
    - path: "crates/memory-types/src/config.rs"
      provides: "Search configuration"
      contains: "search_index_path"
  key_links:
    - from: "crates/memory-search/src/index.rs"
      to: "tantivy::Index"
      via: "opens MmapDirectory-backed index"
      pattern: "Index::open_in_dir"
    - from: "crates/memory-search/src/schema.rs"
      to: "tantivy::schema::Schema"
      via: "defines doc_type, doc_id, text, keywords fields"
      pattern: "Schema::builder"
---

<objective>
Create the memory-search crate with Tantivy integration, schema definition, and index management.

Purpose: Establish the foundation for BM25 keyword search by setting up the Tantivy embedded index with a schema designed for TOC nodes and grips.
Output: New memory-search crate with SearchSchema, SearchIndex, and index path configuration.
</objective>

<execution_context>
@/Users/richardhightower/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardhightower/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/11-bm25-teleport-tantivy/11-RESEARCH.md
@crates/memory-types/src/config.rs
@crates/memory-types/src/toc.rs
@crates/memory-types/src/grip.rs
@Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create memory-search crate structure</name>
  <files>
    crates/memory-search/Cargo.toml
    crates/memory-search/src/lib.rs
    crates/memory-search/src/error.rs
    Cargo.toml
  </files>
  <action>
Create the new memory-search crate:

1. Create `crates/memory-search/Cargo.toml`:
   - Package name: memory-search
   - Inherit workspace.package fields (version, edition, license, repository)
   - Dependencies:
     - tantivy = "0.25"
     - memory-types = { workspace = true }
     - tokio = { workspace = true }
     - chrono = { workspace = true }
     - tracing = { workspace = true }
     - thiserror = { workspace = true }
     - serde = { workspace = true }
   - Dev dependencies:
     - tempfile = { workspace = true }
     - tokio = { workspace = true, features = ["test-util", "macros", "rt-multi-thread"] }

2. Create `crates/memory-search/src/lib.rs`:
   ```rust
   //! # memory-search
   //!
   //! Full-text search for Agent Memory using Tantivy.
   //!
   //! This crate provides BM25 keyword search for "teleporting" directly to
   //! relevant TOC nodes or grips without traversing the hierarchy.
   //!
   //! ## Features
   //! - Embedded Tantivy index with MmapDirectory for persistence
   //! - Schema for indexing TOC node summaries and grip excerpts
   //! - BM25 scoring for relevance ranking
   //! - Document type filtering (toc_node vs grip)
   //!
   //! ## Requirements
   //! - TEL-01: Tantivy embedded index
   //! - TEL-02: BM25 search returns ranked results
   //! - TEL-03: Relevance scores for agent decision-making
   //! - TEL-04: Incremental index updates

   pub mod error;
   pub mod schema;
   pub mod index;

   pub use error::SearchError;
   pub use schema::{SearchSchema, build_teleport_schema, DocType};
   pub use index::{SearchIndex, open_or_create_index};
   ```

3. Create `crates/memory-search/src/error.rs`:
   ```rust
   //! Search error types.

   use thiserror::Error;

   /// Errors that can occur during search operations.
   #[derive(Debug, Error)]
   pub enum SearchError {
       /// Tantivy index error
       #[error("Tantivy error: {0}")]
       Tantivy(#[from] tantivy::TantivyError),

       /// Query parse error
       #[error("Query parse error: {0}")]
       QueryParse(#[from] tantivy::query::QueryParserError),

       /// IO error
       #[error("IO error: {0}")]
       Io(#[from] std::io::Error),

       /// Index not found
       #[error("Index not found at path: {0}")]
       IndexNotFound(String),

       /// Document not found
       #[error("Document not found: {0}")]
       DocumentNotFound(String),

       /// Schema mismatch
       #[error("Schema mismatch: {0}")]
       SchemaMismatch(String),

       /// Index is locked (another process has it open)
       #[error("Index is locked: {0}")]
       IndexLocked(String),
   }
   ```

4. Update workspace `Cargo.toml`:
   - Add "crates/memory-search" to workspace members
   - Add memory-search = { path = "crates/memory-search" } to workspace.dependencies
   - Add tantivy = "0.25" to workspace.dependencies
  </action>
  <verify>
    cd /Users/richardhightower/clients/spillwave/src/agent-memory && cargo check -p memory-search
  </verify>
  <done>
    Crate compiles, error types defined, workspace includes memory-search
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement SearchSchema for TOC and Grip documents</name>
  <files>
    crates/memory-search/src/schema.rs
  </files>
  <action>
Create the Tantivy schema definition:

1. Create `crates/memory-search/src/schema.rs`:
   ```rust
   //! Tantivy schema definition for teleport search.
   //!
   //! Indexes two document types:
   //! - TOC nodes: title + bullets + keywords
   //! - Grips: excerpt text

   use tantivy::schema::{
       Field, Schema, SchemaBuilder, TextFieldIndexing, TextOptions,
       STRING, STORED, TEXT,
   };
   use tantivy::tokenizer::TextAnalyzer;

   /// Document types stored in the index
   #[derive(Debug, Clone, Copy, PartialEq, Eq)]
   pub enum DocType {
       TocNode,
       Grip,
   }

   impl DocType {
       pub fn as_str(&self) -> &'static str {
           match self {
               DocType::TocNode => "toc_node",
               DocType::Grip => "grip",
           }
       }

       pub fn from_str(s: &str) -> Option<Self> {
           match s {
               "toc_node" => Some(DocType::TocNode),
               "grip" => Some(DocType::Grip),
               _ => None,
           }
       }
   }

   /// Schema field handles for efficient access
   #[derive(Debug, Clone)]
   pub struct SearchSchema {
       schema: Schema,
       /// Document type: "toc_node" or "grip" (STRING | STORED)
       pub doc_type: Field,
       /// Primary key: node_id or grip_id (STRING | STORED)
       pub doc_id: Field,
       /// TOC level for toc_node: "year", "month", etc. (STRING)
       pub level: Field,
       /// Searchable text: title+bullets for TOC, excerpt for grip (TEXT)
       pub text: Field,
       /// Keywords/tags (TEXT | STORED)
       pub keywords: Field,
       /// Timestamp in milliseconds (STRING | STORED for recency)
       pub timestamp_ms: Field,
   }

   impl SearchSchema {
       /// Get the underlying Tantivy schema
       pub fn schema(&self) -> &Schema {
           &self.schema
       }

       /// Create a SearchSchema from an existing Tantivy Schema
       pub fn from_schema(schema: Schema) -> Result<Self, crate::SearchError> {
           let doc_type = schema.get_field("doc_type")
               .map_err(|_| crate::SearchError::SchemaMismatch("missing doc_type field".into()))?;
           let doc_id = schema.get_field("doc_id")
               .map_err(|_| crate::SearchError::SchemaMismatch("missing doc_id field".into()))?;
           let level = schema.get_field("level")
               .map_err(|_| crate::SearchError::SchemaMismatch("missing level field".into()))?;
           let text = schema.get_field("text")
               .map_err(|_| crate::SearchError::SchemaMismatch("missing text field".into()))?;
           let keywords = schema.get_field("keywords")
               .map_err(|_| crate::SearchError::SchemaMismatch("missing keywords field".into()))?;
           let timestamp_ms = schema.get_field("timestamp_ms")
               .map_err(|_| crate::SearchError::SchemaMismatch("missing timestamp_ms field".into()))?;

           Ok(Self {
               schema,
               doc_type,
               doc_id,
               level,
               text,
               keywords,
               timestamp_ms,
           })
       }
   }

   /// Build the teleport search schema.
   ///
   /// Schema fields:
   /// - doc_type: STRING | STORED - "toc_node" or "grip"
   /// - doc_id: STRING | STORED - node_id or grip_id
   /// - level: STRING - TOC level (for filtering)
   /// - text: TEXT - searchable content
   /// - keywords: TEXT | STORED - keywords/tags
   /// - timestamp_ms: STRING | STORED - for recency info
   pub fn build_teleport_schema() -> SearchSchema {
       let mut schema_builder = Schema::builder();

       // Document type for filtering: "toc_node" or "grip"
       let doc_type = schema_builder.add_text_field("doc_type", STRING | STORED);

       // Primary key - node_id or grip_id
       let doc_id = schema_builder.add_text_field("doc_id", STRING | STORED);

       // TOC level (for toc_node only): "year", "month", "week", "day", "segment"
       let level = schema_builder.add_text_field("level", STRING);

       // Searchable text content (title + bullets for TOC, excerpt for grip)
       let text = schema_builder.add_text_field("text", TEXT);

       // Keywords (indexed and stored for retrieval)
       let keywords = schema_builder.add_text_field("keywords", TEXT | STORED);

       // Timestamp for recency (stored as string for simplicity)
       let timestamp_ms = schema_builder.add_text_field("timestamp_ms", STRING | STORED);

       let schema = schema_builder.build();

       SearchSchema {
           schema,
           doc_type,
           doc_id,
           level,
           text,
           keywords,
           timestamp_ms,
       }
   }

   #[cfg(test)]
   mod tests {
       use super::*;

       #[test]
       fn test_build_schema() {
           let schema = build_teleport_schema();
           assert!(schema.schema.get_field("doc_type").is_ok());
           assert!(schema.schema.get_field("doc_id").is_ok());
           assert!(schema.schema.get_field("text").is_ok());
       }

       #[test]
       fn test_doc_type_conversion() {
           assert_eq!(DocType::TocNode.as_str(), "toc_node");
           assert_eq!(DocType::from_str("grip"), Some(DocType::Grip));
           assert_eq!(DocType::from_str("invalid"), None);
       }
   }
   ```
  </action>
  <verify>
    cd /Users/richardhightower/clients/spillwave/src/agent-memory && cargo test -p memory-search schema
  </verify>
  <done>
    SearchSchema builds with all required fields. DocType enum works correctly.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement SearchIndex with MmapDirectory persistence</name>
  <files>
    crates/memory-search/src/index.rs
    crates/memory-types/src/config.rs
  </files>
  <action>
Implement index creation and configuration:

1. Create `crates/memory-search/src/index.rs`:
   ```rust
   //! Tantivy index management.
   //!
   //! Handles index creation, opening, and lifecycle.

   use std::path::{Path, PathBuf};
   use std::sync::Arc;

   use tantivy::{Index, IndexReader, IndexWriter, ReloadPolicy};
   use tracing::{debug, info};

   use crate::error::SearchError;
   use crate::schema::{build_teleport_schema, SearchSchema};

   /// Default memory budget for IndexWriter (50MB)
   const DEFAULT_WRITER_MEMORY_MB: usize = 50;

   /// Search index configuration
   #[derive(Debug, Clone)]
   pub struct SearchIndexConfig {
       /// Path to index directory
       pub index_path: PathBuf,
       /// Memory budget for writer in MB
       pub writer_memory_mb: usize,
   }

   impl Default for SearchIndexConfig {
       fn default() -> Self {
           Self {
               index_path: PathBuf::from("./bm25-index"),
               writer_memory_mb: DEFAULT_WRITER_MEMORY_MB,
           }
       }
   }

   impl SearchIndexConfig {
       pub fn new(index_path: impl Into<PathBuf>) -> Self {
           Self {
               index_path: index_path.into(),
               writer_memory_mb: DEFAULT_WRITER_MEMORY_MB,
           }
       }

       pub fn with_memory_mb(mut self, mb: usize) -> Self {
           self.writer_memory_mb = mb;
           self
       }
   }

   /// Wrapper for Tantivy index with schema access.
   pub struct SearchIndex {
       index: Index,
       schema: SearchSchema,
       config: SearchIndexConfig,
   }

   impl SearchIndex {
       /// Open existing index or create new one.
       pub fn open_or_create(config: SearchIndexConfig) -> Result<Self, SearchError> {
           let index = open_or_create_index(&config.index_path)?;
           let schema = SearchSchema::from_schema(index.schema())?;

           info!(path = ?config.index_path, "Opened search index");

           Ok(Self {
               index,
               schema,
               config,
           })
       }

       /// Get the search schema
       pub fn schema(&self) -> &SearchSchema {
           &self.schema
       }

       /// Get the underlying Tantivy index
       pub fn index(&self) -> &Index {
           &self.index
       }

       /// Create an IndexWriter with configured memory budget
       pub fn writer(&self) -> Result<IndexWriter, SearchError> {
           let memory_budget = self.config.writer_memory_mb * 1024 * 1024;
           let writer = self.index.writer(memory_budget)?;
           debug!(memory_mb = self.config.writer_memory_mb, "Created index writer");
           Ok(writer)
       }

       /// Create an IndexReader with OnCommit reload policy
       pub fn reader(&self) -> Result<IndexReader, SearchError> {
           let reader = self.index
               .reader_builder()
               .reload_policy(ReloadPolicy::OnCommitWithDelay)
               .try_into()?;
           debug!("Created index reader");
           Ok(reader)
       }

       /// Get the index path
       pub fn path(&self) -> &Path {
           &self.config.index_path
       }

       /// Check if index exists at the configured path
       pub fn exists(&self) -> bool {
           self.config.index_path.join("meta.json").exists()
       }
   }

   /// Open an existing index or create a new one.
   ///
   /// Uses MmapDirectory for persistence.
   pub fn open_or_create_index(path: &Path) -> Result<Index, SearchError> {
       if path.join("meta.json").exists() {
           debug!(path = ?path, "Opening existing index");
           let index = Index::open_in_dir(path)?;
           Ok(index)
       } else {
           info!(path = ?path, "Creating new index");
           std::fs::create_dir_all(path)?;
           let schema = build_teleport_schema();
           let index = Index::create_in_dir(path, schema.schema().clone())?;
           Ok(index)
       }
   }

   #[cfg(test)]
   mod tests {
       use super::*;
       use tempfile::TempDir;

       #[test]
       fn test_create_new_index() {
           let temp_dir = TempDir::new().unwrap();
           let config = SearchIndexConfig::new(temp_dir.path());

           let index = SearchIndex::open_or_create(config).unwrap();
           assert!(index.exists());
       }

       #[test]
       fn test_reopen_existing_index() {
           let temp_dir = TempDir::new().unwrap();
           let config = SearchIndexConfig::new(temp_dir.path());

           // Create index
           let _index1 = SearchIndex::open_or_create(config.clone()).unwrap();

           // Reopen
           let index2 = SearchIndex::open_or_create(config).unwrap();
           assert!(index2.exists());
       }

       #[test]
       fn test_create_writer_and_reader() {
           let temp_dir = TempDir::new().unwrap();
           let config = SearchIndexConfig::new(temp_dir.path());
           let index = SearchIndex::open_or_create(config).unwrap();

           let _writer = index.writer().unwrap();
           let _reader = index.reader().unwrap();
       }
   }
   ```

2. Update `crates/memory-types/src/config.rs` to add search index path:
   - Add `search_index_path: Option<String>` to Settings struct
   - Add default function: `default_search_index_path()` returning `~/.local/share/agent-memory/bm25-index`
   - Document the field as "Path to BM25 search index directory"
  </action>
  <verify>
    cd /Users/richardhightower/clients/spillwave/src/agent-memory && cargo test -p memory-search index && cargo test -p memory-types config
  </verify>
  <done>
    SearchIndex opens/creates persistent index. Settings includes search_index_path. All tests pass.
  </done>
</task>

</tasks>

<verification>
```bash
cd /Users/richardhightower/clients/spillwave/src/agent-memory

# Crate compiles
cargo build -p memory-search

# All tests pass
cargo test -p memory-search

# Schema works correctly
cargo test -p memory-search schema

# Index persistence works
cargo test -p memory-search index

# Config includes search path
cargo test -p memory-types config

# Clippy clean
cargo clippy -p memory-search -- -D warnings
```
</verification>

<success_criteria>
- [ ] memory-search crate exists in workspace
- [ ] Tantivy 0.25 added to workspace dependencies
- [ ] SearchSchema defines doc_type, doc_id, level, text, keywords, timestamp_ms fields
- [ ] DocType enum distinguishes toc_node from grip
- [ ] SearchIndex opens or creates MmapDirectory-backed index
- [ ] IndexWriter and IndexReader can be created
- [ ] Settings.search_index_path configured with default
- [ ] All tests pass
- [ ] No clippy warnings
</success_criteria>

<output>
After completion, create `.planning/phases/11-bm25-teleport-tantivy/11-01-SUMMARY.md`
</output>
