---
phase: 24-proto-service-debt-cleanup
plan: 03
type: execute
wave: 2
depends_on: ["24-01"]
files_modified:
  - crates/memory-service/src/ingest.rs
  - crates/memory-service/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "PruneVectorIndex RPC triggers actual vector metadata cleanup based on lifecycle config and returns counts of pruned items"
    - "PruneBm25Index RPC triggers actual BM25 document deletion based on lifecycle config and returns counts of pruned items"
    - "Both prune RPCs support dry_run mode that reports what would be pruned without deleting"
    - "Both prune RPCs support level filtering to prune only specific document levels"
  artifacts:
    - path: "crates/memory-service/src/ingest.rs"
      provides: "Wired PruneVectorIndex and PruneBm25Index implementations"
      contains: "prune"
  key_links:
    - from: "crates/memory-service/src/ingest.rs"
      to: "memory_vector::VectorMetadata"
      via: "vector metadata pruning"
      pattern: "VectorMetadata"
    - from: "crates/memory-service/src/ingest.rs"
      to: "memory_search::SearchIndexer"
      via: "BM25 document deletion"
      pattern: "SearchIndexer"
---

<objective>
Wire PruneVectorIndex and PruneBm25Index RPCs to trigger actual index cleanup using lifecycle configuration and metadata.

Purpose: DEBT-02 and DEBT-03 — these RPCs currently return "not yet implemented" stubs. After this plan, they perform real pruning: identifying old documents by retention policy, deleting them, and returning accurate statistics.
Output: Updated `ingest.rs` with working prune implementations that respect lifecycle config, dry_run mode, and level filters.
</objective>

<execution_context>
@/Users/richardhightower/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardhightower/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@crates/memory-service/src/ingest.rs
@crates/memory-vector/src/lifecycle.rs
@crates/memory-search/src/lifecycle.rs
@crates/memory-vector/src/metadata.rs
@crates/memory-service/src/vector.rs
@.planning/phases/24-proto-service-debt-cleanup/24-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire PruneVectorIndex RPC with real lifecycle pruning</name>
  <files>
crates/memory-service/src/ingest.rs
  </files>
  <action>
Replace the stub `prune_vector_index` implementation with real lifecycle pruning:

1. If `self.vector_service` is None, return success with message "Vector index not configured" and all counts 0.
2. Extract request fields: `level` filter (empty = all pruneable levels), `age_days_override` (0 = use defaults), `dry_run`.
3. Use `VectorLifecycleConfig::default()` for retention values. If `age_days_override > 0`, use that instead of the config retention for all levels.
4. Build a retention map using `memory_vector::lifecycle::retention_map()`.
5. If level filter is provided and not empty, only process that one level. Otherwise process all: segment, grip, day, week. Skip protected levels (month, year) using `memory_vector::lifecycle::is_protected_level()`.
6. For each pruneable level:
   - Calculate cutoff timestamp from retention days: `cutoff_ms = (Utc::now() - Duration::days(retention_days)).timestamp_millis()`
   - Access the `VectorMetadata` from `self.vector_service` — this requires the `VectorTeleportHandler` to expose a reference to its metadata. Add `pub fn metadata(&self) -> &Arc<VectorMetadata>` method to `VectorTeleportHandler`.
   - Iterate all entries via `metadata.get_all()`, filter by doc_type matching the level (TocNode for day/week, Grip for grip, TocNode for segment via doc_id prefix matching).
   - For entries older than cutoff: if `dry_run`, just count them; otherwise `metadata.delete(entry.vector_id)` and count.
7. Build response with actual counts and descriptive message.

NOTE: Full vector index rebuilding (removing vectors from the HNSW) is complex and out of scope for this debt cleanup. The prune operation removes metadata entries, making the vectors "orphaned" — they still exist in the HNSW but won't be returned since metadata lookup fails. A full rebuild-index command can compact later. Document this in the response message.

The `VectorTeleportHandler` needs a new public method to access metadata. Update `crates/memory-service/src/vector.rs` to add:
```rust
pub fn metadata(&self) -> &Arc<VectorMetadata> {
    &self.metadata
}
```

Add imports for `memory_vector::lifecycle::{VectorLifecycleConfig, retention_map as vector_retention_map, is_protected_level as vector_is_protected}` and `chrono::Duration`.

Add a unit test `test_prune_vector_index_no_service` that calls PruneVectorIndex on a basic MemoryServiceImpl (no vector service) and verifies it returns success with "not configured" message.
  </action>
  <verify>
`cargo test -p memory-service -- test_prune_vector` passes.
`cargo clippy -p memory-service --all-targets -- -D warnings` passes.
  </verify>
  <done>PruneVectorIndex RPC triggers metadata cleanup, supports dry_run and level filter, returns real counts.</done>
</task>

<task type="auto">
  <name>Task 2: Wire PruneBm25Index RPC with real lifecycle pruning</name>
  <files>
crates/memory-service/src/ingest.rs
  </files>
  <action>
Replace the stub `prune_bm25_index` implementation with real lifecycle pruning:

1. If `self.teleport_searcher` is None, return success with message "BM25 index not configured" and all counts 0.
2. Extract request fields: `level` filter, `age_days_override`, `dry_run`.
3. Use `Bm25LifecycleConfig::default()` for retention values. If `age_days_override > 0`, override.
4. Build retention map using `memory_search::lifecycle::retention_map()`.
5. For each pruneable level (segment, grip, day, week — skip protected via `memory_search::lifecycle::is_protected_level()`):
   - Calculate cutoff timestamp from retention days.
   - BM25 pruning is more complex because Tantivy doesn't expose per-document deletion easily. Instead, report what WOULD be pruned by checking document timestamps in the index.
   - For actual deletion: Tantivy supports delete by term. However, the `TeleportSearcher` is read-only. To delete, we'd need an `IndexWriter`. Since the `SearchIndexer` holds the writer, and we don't have it in the service, the actual implementation should:
     a. Search for documents with timestamp_ms < cutoff using the searcher
     b. Report them as "would be pruned" in the response
     c. Set `message` to describe that deletion requires a rebuild-index operation
   - For now, the implementation does a "report-only" prune: counts documents older than cutoff per level. This is honest and useful — it tells the caller what's eligible for pruning.
6. For `dry_run = true`, explicitly state in message that this is a dry run.
7. Set `optimized = false` (no optimization performed in this implementation).

NOTE: Full BM25 index rebuilding with deletion requires the `SearchIndexer` (writer), not just the `SearchIndexer` (reader). A rebuild-toc-index command already exists. The prune RPC reports what's eligible, enabling informed decisions.

Add imports for `memory_search::lifecycle::{Bm25LifecycleConfig, retention_map as bm25_retention_map, is_protected_level as bm25_is_protected}`.

Add a unit test `test_prune_bm25_index_no_service` that calls PruneBm25Index on a basic MemoryServiceImpl and verifies it returns success with "not configured" message.
  </action>
  <verify>
`cargo test -p memory-service -- test_prune_bm25` passes.
`cargo clippy -p memory-service --all-targets -- -D warnings` passes.
  </verify>
  <done>PruneBm25Index RPC performs lifecycle analysis, reports eligible documents by level, supports dry_run and level filter.</done>
</task>

</tasks>

<verification>
```bash
cargo test -p memory-service -- test_prune
cargo clippy --workspace --all-targets --all-features -- -D warnings
cargo test --workspace --all-features
```
</verification>

<success_criteria>
- PruneVectorIndex triggers real metadata pruning with actual counts (not "not yet implemented")
- PruneBm25Index analyzes documents by lifecycle policy and reports eligible counts
- Both RPCs support dry_run mode and level filtering
- Both RPCs handle "service not configured" gracefully
- All existing tests still pass
- No clippy warnings
</success_criteria>

<output>
After completion, create `.planning/phases/24-proto-service-debt-cleanup/24-03-SUMMARY.md`
</output>
