---
phase: 20-opencode-event-capture
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/memory-ingest/src/main.rs
  - crates/memory-client/src/hook_mapping.rs
  - crates/memory-service/src/retrieval.rs
autonomous: true

must_haves:
  truths:
    - "memory-ingest binary accepts JSON with agent field and propagates it to Event"
    - "Events ingested via memory-ingest carry the agent identifier through the full pipeline"
    - "RetrievalResult.agent is populated from event metadata for all query types"
    - "Existing tests pass - backward compatible with JSON missing agent field"
  artifacts:
    - path: "crates/memory-ingest/src/main.rs"
      provides: "CchEvent with agent field, propagation to Event.with_agent()"
      contains: "agent: Option<String>"
    - path: "crates/memory-client/src/hook_mapping.rs"
      provides: "HookEvent with agent field, map_hook_event propagation"
      contains: "pub agent: Option<String>"
    - path: "crates/memory-service/src/retrieval.rs"
      provides: "RetrievalResult.agent populated from search result metadata"
      contains: "r.metadata.get"
  key_links:
    - from: "crates/memory-ingest/src/main.rs"
      to: "crates/memory-client/src/hook_mapping.rs"
      via: "CchEvent.agent -> HookEvent.agent -> map_hook_event -> Event.with_agent()"
      pattern: "with_agent"
    - from: "crates/memory-service/src/retrieval.rs"
      to: "proto/memory.proto"
      via: "RetrievalResult.agent populated from metadata"
      pattern: 'agent.*metadata'
---

<objective>
Wire agent identifier through the ingest-to-retrieval pipeline so that events from any agent (OpenCode, Claude, Gemini) carry their source agent tag and retrieval results expose it.

Purpose: This is the backend plumbing that enables Phase 20's cross-agent query features. Without it, the OpenCode plugin cannot tag events and CLI cannot display agent provenance.

Output: Three modified Rust files that complete the agent data flow from JSON ingest through gRPC retrieval.
</objective>

<execution_context>
@/Users/richardhightower/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardhightower/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-opencode-event-capture/20-RESEARCH.md

# Key source files
@crates/memory-ingest/src/main.rs
@crates/memory-client/src/hook_mapping.rs
@crates/memory-service/src/retrieval.rs
@crates/memory-types/src/event.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add agent field to CchEvent and propagate through ingest</name>
  <files>
    crates/memory-ingest/src/main.rs
    crates/memory-client/src/hook_mapping.rs
  </files>
  <action>
**Step 1: Add agent to HookEvent** in `crates/memory-client/src/hook_mapping.rs`:

1. Add `pub agent: Option<String>` field to `HookEvent` struct (after `metadata` field at line 44).
2. Initialize it to `None` in `HookEvent::new()` (line 54-61).
3. Add builder method:
   ```rust
   pub fn with_agent(mut self, agent: impl Into<String>) -> Self {
       self.agent = Some(agent.into());
       self
   }
   ```
4. In `map_hook_event()` (line 86-128), after the existing metadata handling (lines 118-125), add agent propagation:
   ```rust
   if let Some(agent) = hook.agent {
       event = event.with_agent(agent);
   }
   ```
5. Add a test:
   ```rust
   #[test]
   fn test_map_with_agent() {
       let hook = HookEvent::new("session-1", HookEventType::UserPromptSubmit, "Test")
           .with_agent("opencode");
       let event = map_hook_event(hook);
       assert_eq!(event.agent, Some("opencode".to_string()));
   }
   ```

**Step 2: Add agent to CchEvent** in `crates/memory-ingest/src/main.rs`:

1. Add `agent: Option<String>` field to `CchEvent` struct (after `cwd` field at line 42) with `#[serde(default)]` attribute:
   ```rust
   /// Agent identifier (e.g., "opencode", "claude")
   #[serde(default)]
   agent: Option<String>,
   ```
2. In `map_cch_to_hook()` function (line 62-90), after the cwd handling (line 83-87), add:
   ```rust
   if let Some(agent) = &cch.agent {
       hook = hook.with_agent(agent.clone());
   }
   ```
3. Update all existing tests that construct `CchEvent` manually (e.g., `test_map_cch_to_hook_basic` at line 234) to include `agent: None`.
4. Add new tests:
   ```rust
   #[test]
   fn test_parse_with_agent() {
       let json = r#"{"hook_event_name":"SessionStart","session_id":"test-123","agent":"opencode"}"#;
       let cch: CchEvent = serde_json::from_str(json).unwrap();
       assert_eq!(cch.agent, Some("opencode".to_string()));
   }

   #[test]
   fn test_parse_without_agent_backward_compat() {
       let json = r#"{"hook_event_name":"SessionStart","session_id":"test-123"}"#;
       let cch: CchEvent = serde_json::from_str(json).unwrap();
       assert!(cch.agent.is_none());
   }

   #[test]
   fn test_end_to_end_with_agent() {
       let json = r#"{"hook_event_name":"UserPromptSubmit","session_id":"test-123","message":"Hello","agent":"opencode"}"#;
       let cch: CchEvent = serde_json::from_str(json).unwrap();
       let hook = map_cch_to_hook(&cch);
       let event = map_hook_event(hook);
       assert_eq!(event.agent, Some("opencode".to_string()));
   }
   ```
  </action>
  <verify>
Run `cargo test -p memory-ingest --all-features` and `cargo test -p memory-client --all-features` -- all tests pass including the new agent propagation tests. Run `cargo clippy -p memory-ingest -p memory-client --all-targets --all-features -- -D warnings` -- no warnings.
  </verify>
  <done>
CchEvent accepts `agent` from JSON input. HookEvent carries `agent` field. `map_hook_event()` calls `Event.with_agent()`. End-to-end test proves JSON `{"agent":"opencode"}` flows through to `Event.agent == Some("opencode")`. Backward compatible: missing agent field defaults to None.
  </done>
</task>

<task type="auto">
  <name>Task 2: Populate RetrievalResult.agent from search result metadata</name>
  <files>
    crates/memory-service/src/retrieval.rs
  </files>
  <action>
In `crates/memory-service/src/retrieval.rs`, in the `route_query()` method:

1. **Fix line 281** -- Replace `agent: None, // Phase 18: Agent populated when available` with:
   ```rust
   agent: r.metadata.get("agent").cloned(),
   ```
   This reads the agent from the `SearchResult.metadata` HashMap which is populated during search when events have agent tags.

2. **Ensure metadata propagation in SimpleLayerExecutor** -- The `execute()` implementations for BM25, Vector, Topics, and Hybrid layers currently create `SearchResult` with `metadata: HashMap::new()`. For the agent field to flow through, we need to propagate it when available. However, this depends on the search layer returning agent info. For now, the change on line 281 is sufficient because:
   - The metadata on SearchResult comes from the search layer
   - When indexes are rebuilt with agent-tagged events, metadata will include agent
   - This is a forward-compatible change that starts working once index data includes agent

3. **Add a unit test** that verifies the conversion handles both present and absent agent:
   ```rust
   #[test]
   fn test_retrieval_result_agent_from_metadata() {
       use memory_retrieval::executor::SearchResult;
       use memory_retrieval::types::RetrievalLayer;
       use std::collections::HashMap;

       // Result with agent in metadata
       let mut metadata = HashMap::new();
       metadata.insert("agent".to_string(), "opencode".to_string());
       let result = SearchResult {
           doc_id: "doc-1".to_string(),
           doc_type: "toc".to_string(),
           score: 0.95,
           text_preview: "test".to_string(),
           source_layer: RetrievalLayer::BM25,
           metadata,
       };
       let proto_result = ProtoResult {
           doc_id: result.doc_id.clone(),
           doc_type: result.doc_type.clone(),
           score: result.score,
           text_preview: result.text_preview.clone(),
           source_layer: layer_to_proto(result.source_layer) as i32,
           metadata: result.metadata.clone(),
           agent: result.metadata.get("agent").cloned(),
       };
       assert_eq!(proto_result.agent, Some("opencode".to_string()));

       // Result without agent
       let result_no_agent = SearchResult {
           doc_id: "doc-2".to_string(),
           doc_type: "grip".to_string(),
           score: 0.5,
           text_preview: "test".to_string(),
           source_layer: RetrievalLayer::Vector,
           metadata: HashMap::new(),
       };
       let proto_no_agent = ProtoResult {
           doc_id: result_no_agent.doc_id.clone(),
           doc_type: result_no_agent.doc_type.clone(),
           score: result_no_agent.score,
           text_preview: result_no_agent.text_preview.clone(),
           source_layer: layer_to_proto(result_no_agent.source_layer) as i32,
           metadata: result_no_agent.metadata.clone(),
           agent: result_no_agent.metadata.get("agent").cloned(),
       };
       assert_eq!(proto_no_agent.agent, None);
   }
   ```
  </action>
  <verify>
Run `cargo test -p memory-service --all-features` -- all tests pass. Run `cargo clippy -p memory-service --all-targets --all-features -- -D warnings` -- no warnings. The `agent: None` placeholder from Phase 18 is replaced with actual metadata lookup.
  </verify>
  <done>
RetrievalResult.agent is populated from `r.metadata.get("agent")` instead of hardcoded `None`. Query results now carry the source agent identifier when available. Pre-phase-18 events without agent continue to return `None` (backward compatible).
  </done>
</task>

</tasks>

<verification>
```bash
# Full pipeline verification
cargo test -p memory-client --all-features
cargo test -p memory-ingest --all-features
cargo test -p memory-service --all-features

# Clippy across affected crates
cargo clippy -p memory-client -p memory-ingest -p memory-service --all-targets --all-features -- -D warnings

# Format check
cargo fmt --all -- --check
```
</verification>

<success_criteria>
1. `echo '{"hook_event_name":"SessionStart","session_id":"s1","agent":"opencode"}' | cargo run -p memory-ingest` would produce an Event with agent="opencode" (if daemon running)
2. All existing tests pass (backward compatibility with JSON missing agent field)
3. New tests prove agent flows through CchEvent -> HookEvent -> Event -> RetrievalResult
4. Zero clippy warnings
</success_criteria>

<output>
After completion, create `.planning/phases/20-opencode-event-capture/20-01-SUMMARY.md`
</output>
