---
phase: 20-opencode-event-capture
plan: 02
type: execute
wave: 2
depends_on: ["20-01"]
files_modified:
  - plugins/memory-opencode-plugin/.opencode/plugin/memory-capture.ts
autonomous: true

must_haves:
  truths:
    - "OpenCode plugin captures session start and end events"
    - "Events are tagged with agent:opencode via memory-ingest binary"
    - "Plugin uses fail-open pattern - never blocks OpenCode on ingest failure"
    - "Project directory is included in every captured event"
    - "Tool execution events are captured with tool name and arguments"
  artifacts:
    - path: "plugins/memory-opencode-plugin/.opencode/plugin/memory-capture.ts"
      provides: "TypeScript plugin for OpenCode session lifecycle event capture"
      contains: "MemoryCapturePlugin"
  key_links:
    - from: "plugins/memory-opencode-plugin/.opencode/plugin/memory-capture.ts"
      to: "crates/memory-ingest/src/main.rs"
      via: "JSON piped to memory-ingest binary via Bun $ shell API"
      pattern: "memory-ingest"
---

<objective>
Create the OpenCode TypeScript plugin that captures session lifecycle events (start, end, tool use, messages) and sends them to the memory-ingest binary with `agent:opencode` tagging and project directory context.

Purpose: This enables OpenCode sessions to be automatically ingested into agent-memory, fulfilling R1.4.1 (session end capture), R1.4.2 (checkpoint capture via session.idle), R1.4.3 (agent identifier tagging), and R1.4.4 (project context preservation).

Output: A single TypeScript plugin file in the OpenCode plugin directory that auto-activates on session events.
</objective>

<execution_context>
@/Users/richardhightower/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardhightower/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-opencode-event-capture/20-RESEARCH.md
@.planning/phases/20-opencode-event-capture/20-01-SUMMARY.md

# Existing plugin structure
@plugins/memory-opencode-plugin/.opencode/command/memory-search.md
@plugins/memory-opencode-plugin/README.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create OpenCode event capture plugin</name>
  <files>
    plugins/memory-opencode-plugin/.opencode/plugin/memory-capture.ts
  </files>
  <action>
Create the directory `plugins/memory-opencode-plugin/.opencode/plugin/` and the file `memory-capture.ts` with the following implementation:

```typescript
// memory-capture.ts
// OpenCode plugin for capturing session events into agent-memory.
//
// This plugin hooks into OpenCode lifecycle events and forwards them
// to the memory-ingest binary with agent:opencode tagging.
//
// Requires: memory-ingest binary in PATH (installed via agent-memory)
//
// Fail-open: All event capture is wrapped in try/catch. If memory-ingest
// is not available or the daemon is down, OpenCode continues normally.

import type { Plugin } from "@opencode-ai/plugin"

export const MemoryCapturePlugin: Plugin = async ({ $, directory }) => {
  const MEMORY_INGEST = process.env.MEMORY_INGEST_PATH || "memory-ingest"

  // Helper: extract session ID from various event input shapes.
  // OpenCode events provide session ID in different fields depending on event type.
  function extractSessionId(input: Record<string, unknown>): string {
    return (
      (input.id as string) ||
      (input.sessionID as string) ||
      (input.session_id as string) ||
      ((input as any).properties?.sessionID as string) ||
      "unknown"
    )
  }

  // Helper: send event to memory-ingest via stdin JSON pipe.
  // Uses fail-open pattern - silently catches all errors.
  async function captureEvent(event: {
    hook_event_name: string
    session_id: string
    message?: string
    tool_name?: string
    tool_input?: unknown
    cwd?: string
    timestamp?: string
  }): Promise<void> {
    try {
      const payload = JSON.stringify({
        ...event,
        agent: "opencode",
        cwd: event.cwd || directory,
        timestamp: event.timestamp || new Date().toISOString(),
      })
      await $`echo ${payload} | ${MEMORY_INGEST}`.quiet()
    } catch {
      // Fail-open: never block OpenCode on ingest failure
    }
  }

  return {
    // Session created - capture session start with project directory
    "session.created": async (input) => {
      await captureEvent({
        hook_event_name: "SessionStart",
        session_id: extractSessionId(input as Record<string, unknown>),
        cwd: directory,
      })
    },

    // Session idle - agent finished responding, treat as checkpoint/session end
    // Fulfills R1.4.1 (session end capture) and R1.4.2 (checkpoint capture)
    "session.idle": async (input) => {
      await captureEvent({
        hook_event_name: "Stop",
        session_id: extractSessionId(input as Record<string, unknown>),
        cwd: directory,
      })
    },

    // Message updated - capture user prompts and assistant responses
    "message.updated": async (input) => {
      const props = (input as any).properties
      const message = props?.message
      if (!message) return

      // Map role to hook event name
      const eventName =
        message.role === "user"
          ? "UserPromptSubmit"
          : message.role === "assistant"
            ? "AssistantResponse"
            : null

      if (!eventName) return

      // Handle content that may be string or array of content blocks
      const content =
        typeof message.content === "string"
          ? message.content
          : JSON.stringify(message.content)

      await captureEvent({
        hook_event_name: eventName,
        session_id: extractSessionId(input as Record<string, unknown>),
        message: content,
        cwd: directory,
      })
    },

    // Tool execution completed - capture tool results
    "tool.execute.after": async (input) => {
      const typedInput = input as Record<string, unknown>
      await captureEvent({
        hook_event_name: "PostToolUse",
        session_id: extractSessionId(typedInput),
        tool_name: typedInput.tool as string,
        tool_input: typedInput.args,
        cwd: directory,
      })
    },
  }
}
```

**Key design decisions:**
- `extractSessionId()` helper tries multiple field names because OpenCode events provide session ID differently per event type (research finding: Pitfall 3).
- `agent: "opencode"` is hardcoded in the payload -- the plugin IS OpenCode, no detection needed.
- `directory` from plugin context provides project directory for R1.4.4.
- `.quiet()` suppresses stdout/stderr from memory-ingest to avoid polluting OpenCode output.
- `session.idle` maps to `Stop` hook event which triggers session end ingest (R1.4.1). It also serves as checkpoint capture (R1.4.2) since it fires when the agent finishes responding.
- `message.updated` filters by role to avoid capturing system messages.
- Content blocks are stringified when not already strings (research finding: Open Question 3).

**Do NOT:**
- Add a package.json or node_modules -- the plugin uses only the built-in `$` API and does not need NPM packages.
- Add complex error handling or retry logic -- fail-open means silently drop errors.
- Use `child_process` or `exec` -- use Bun `$` API which is built into the plugin context.
  </action>
  <verify>
1. File exists at `plugins/memory-opencode-plugin/.opencode/plugin/memory-capture.ts`
2. File exports `MemoryCapturePlugin` constant
3. File contains all four event handlers: `session.created`, `session.idle`, `message.updated`, `tool.execute.after`
4. File contains `agent: "opencode"` in the captureEvent helper
5. File contains `directory` usage for project context (R1.4.4)
6. All event handlers are wrapped in try/catch via the captureEvent helper
7. TypeScript syntax is valid (no syntax errors when checked with `npx tsc --noEmit` if available, or manual inspection)
  </verify>
  <done>
OpenCode plugin file exists at `.opencode/plugin/memory-capture.ts` with all four lifecycle hooks. Events are tagged with `agent:opencode` and include project directory. Fail-open pattern ensures OpenCode is never blocked. Session start, session end/checkpoint, user messages, assistant responses, and tool executions are all captured.
  </done>
</task>

</tasks>

<verification>
```bash
# Verify file exists and has expected structure
ls -la plugins/memory-opencode-plugin/.opencode/plugin/memory-capture.ts
grep -c "session.created\|session.idle\|message.updated\|tool.execute.after" plugins/memory-opencode-plugin/.opencode/plugin/memory-capture.ts
# Should output 4 (one per event handler)

grep "agent.*opencode" plugins/memory-opencode-plugin/.opencode/plugin/memory-capture.ts
# Should find the agent tagging line

grep "directory" plugins/memory-opencode-plugin/.opencode/plugin/memory-capture.ts
# Should find project context usage
```
</verification>

<success_criteria>
1. Plugin file exists with correct TypeScript syntax
2. All four OpenCode lifecycle events are handled
3. Every event includes `agent: "opencode"` and `cwd: directory`
4. Fail-open pattern in place (try/catch around all ingest calls)
5. Session ID extraction handles multiple input shapes defensively
</success_criteria>

<output>
After completion, create `.planning/phases/20-opencode-event-capture/20-02-SUMMARY.md`
</output>
