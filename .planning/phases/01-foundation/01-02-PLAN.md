---
phase: 01-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-00"]
files_modified:
  - crates/memory-types/src/lib.rs
  - crates/memory-types/src/event.rs
  - crates/memory-types/src/toc.rs
  - crates/memory-types/src/grip.rs
  - crates/memory-types/src/config.rs
  - crates/memory-types/src/outbox.rs
autonomous: true

must_haves:
  truths:
    - "Event struct contains session_id, timestamp, role, text, metadata"
    - "TocNode struct contains title, bullets, keywords, child_ids"
    - "Grip struct contains excerpt, event_id_start, event_id_end, timestamp"
    - "All types implement Serialize/Deserialize for storage"
    - "Configuration supports layered loading (defaults, file, env, CLI)"
    - "Settings includes multi_agent_mode config option (separate/unified) per STOR-06"
  artifacts:
    - path: "crates/memory-types/src/event.rs"
      provides: "Event type definition"
      exports: ["Event", "EventRole"]
    - path: "crates/memory-types/src/toc.rs"
      provides: "TOC node type definitions"
      exports: ["TocNode", "TocLevel"]
    - path: "crates/memory-types/src/grip.rs"
      provides: "Grip type definition"
      exports: ["Grip"]
    - path: "crates/memory-types/src/config.rs"
      provides: "Configuration loading"
      exports: ["Settings", "SummarizerSettings"]
    - path: "crates/memory-types/src/outbox.rs"
      provides: "Outbox entry type"
      exports: ["OutboxEntry"]
  key_links:
    - from: "crates/memory-types/src/event.rs"
      to: "ulid"
      via: "event_id field"
      pattern: "Ulid"
    - from: "crates/memory-types/src/config.rs"
      to: "config crate"
      via: "layered config loading"
      pattern: "Config::builder"
---

<objective>
Define the core domain types: Event, TocNode, Grip, OutboxEntry, and Settings configuration.

Purpose: Establish the data model that all other components use, ensuring consistent serialization and type safety across crates.
Output: memory-types crate with all domain structs implementing Serialize/Deserialize, plus layered configuration loading.
</objective>

<execution_context>
@/Users/richardhightower/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardhightower/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-00-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Event and OutboxEntry types</name>
  <files>
    - crates/memory-types/src/event.rs
    - crates/memory-types/src/outbox.rs
  </files>
  <action>
Define Event per ING-02 (session_id, timestamp, role, text, metadata) and OutboxEntry for async index updates.

**crates/memory-types/src/event.rs:**
```rust
//! Event type for conversation storage.
//!
//! Events are immutable records of conversation turns, tool calls,
//! session boundaries, and other agent interactions.

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// Role of the message author
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum EventRole {
    /// User input
    User,
    /// Assistant response
    Assistant,
    /// System message
    System,
    /// Tool invocation or result
    Tool,
}

impl std::fmt::Display for EventRole {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            EventRole::User => write!(f, "user"),
            EventRole::Assistant => write!(f, "assistant"),
            EventRole::System => write!(f, "system"),
            EventRole::Tool => write!(f, "tool"),
        }
    }
}

/// Event type indicating the kind of conversation event
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum EventType {
    /// Session started
    SessionStart,
    /// User message submitted
    UserMessage,
    /// Assistant response
    AssistantMessage,
    /// Tool was called and returned result
    ToolResult,
    /// Assistant finished responding
    AssistantStop,
    /// Subagent started
    SubagentStart,
    /// Subagent stopped
    SubagentStop,
    /// Session ended
    SessionEnd,
}

/// A conversation event.
///
/// Events are the fundamental unit of storage. They are immutable and
/// stored with time-prefixed keys for efficient range queries.
///
/// Per ING-02: Includes session_id, timestamp, role, text, metadata.
/// Per ING-04: Uses source timestamp for ordering, not ingestion time.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Event {
    /// Unique identifier (ULID string)
    pub event_id: String,

    /// Session this event belongs to
    pub session_id: String,

    /// Source timestamp (when the event occurred, not when ingested)
    /// Per ING-04: Used for ordering
    #[serde(with = "chrono::serde::ts_milliseconds")]
    pub timestamp: DateTime<Utc>,

    /// Type of event
    pub event_type: EventType,

    /// Role of the author
    pub role: EventRole,

    /// Event content/text
    pub text: String,

    /// Additional metadata (tool names, file paths, etc.)
    #[serde(default)]
    pub metadata: HashMap<String, String>,
}

impl Event {
    /// Create a new event with the given parameters
    pub fn new(
        event_id: String,
        session_id: String,
        timestamp: DateTime<Utc>,
        event_type: EventType,
        role: EventRole,
        text: String,
    ) -> Self {
        Self {
            event_id,
            session_id,
            timestamp,
            event_type,
            role,
            text,
            metadata: HashMap::new(),
        }
    }

    /// Create a new event with metadata
    pub fn with_metadata(mut self, metadata: HashMap<String, String>) -> Self {
        self.metadata = metadata;
        self
    }

    /// Get timestamp as milliseconds since Unix epoch
    pub fn timestamp_ms(&self) -> i64 {
        self.timestamp.timestamp_millis()
    }

    /// Serialize event to JSON bytes for storage
    pub fn to_bytes(&self) -> Result<Vec<u8>, serde_json::Error> {
        serde_json::to_vec(self)
    }

    /// Deserialize event from JSON bytes
    pub fn from_bytes(bytes: &[u8]) -> Result<Self, serde_json::Error> {
        serde_json::from_slice(bytes)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_event_serialization_roundtrip() {
        let event = Event::new(
            "01HN4QXKN6YWXVKZ3JMHP4BCDE".to_string(),
            "session-123".to_string(),
            Utc::now(),
            EventType::UserMessage,
            EventRole::User,
            "Hello, world!".to_string(),
        );

        let bytes = event.to_bytes().unwrap();
        let decoded = Event::from_bytes(&bytes).unwrap();

        assert_eq!(event.event_id, decoded.event_id);
        assert_eq!(event.session_id, decoded.session_id);
        assert_eq!(event.text, decoded.text);
    }

    #[test]
    fn test_event_with_metadata() {
        let mut metadata = HashMap::new();
        metadata.insert("tool_name".to_string(), "Read".to_string());
        metadata.insert("file_path".to_string(), "/tmp/test.rs".to_string());

        let event = Event::new(
            "01HN4QXKN6YWXVKZ3JMHP4BCDE".to_string(),
            "session-123".to_string(),
            Utc::now(),
            EventType::ToolResult,
            EventRole::Tool,
            "File contents here".to_string(),
        ).with_metadata(metadata);

        assert_eq!(event.metadata.get("tool_name"), Some(&"Read".to_string()));
    }
}
```

**crates/memory-types/src/outbox.rs:**
```rust
//! Outbox entry type for async index updates.
//!
//! Per ING-05: Outbox entries are written atomically with events.
//! Background workers consume outbox entries to update indexes.

use serde::{Deserialize, Serialize};

/// Type of outbox action
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum OutboxAction {
    /// Index this event for BM25/vector search
    IndexEvent,
    /// Update TOC node with new event
    UpdateToc,
}

/// An outbox entry for async processing.
///
/// Written atomically with events to ensure index updates are not lost.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OutboxEntry {
    /// Reference to the event that triggered this entry
    pub event_id: String,

    /// Timestamp of the source event (for ordering)
    pub timestamp_ms: i64,

    /// What action should be performed
    pub action: OutboxAction,
}

impl OutboxEntry {
    /// Create a new outbox entry for event indexing
    pub fn for_index(event_id: String, timestamp_ms: i64) -> Self {
        Self {
            event_id,
            timestamp_ms,
            action: OutboxAction::IndexEvent,
        }
    }

    /// Create a new outbox entry for TOC update
    pub fn for_toc(event_id: String, timestamp_ms: i64) -> Self {
        Self {
            event_id,
            timestamp_ms,
            action: OutboxAction::UpdateToc,
        }
    }

    /// Serialize to JSON bytes
    pub fn to_bytes(&self) -> Result<Vec<u8>, serde_json::Error> {
        serde_json::to_vec(self)
    }

    /// Deserialize from JSON bytes
    pub fn from_bytes(bytes: &[u8]) -> Result<Self, serde_json::Error> {
        serde_json::from_slice(bytes)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_outbox_entry_roundtrip() {
        let entry = OutboxEntry::for_index("event-123".to_string(), 1706540400000);
        let bytes = entry.to_bytes().unwrap();
        let decoded = OutboxEntry::from_bytes(&bytes).unwrap();

        assert_eq!(entry.event_id, decoded.event_id);
        assert_eq!(entry.timestamp_ms, decoded.timestamp_ms);
        assert_eq!(entry.action, decoded.action);
    }
}
```
  </action>
  <verify>
`cargo test -p memory-types` passes all event and outbox tests.
  </verify>
  <done>
Event type with all required fields (ING-02) and OutboxEntry for async processing created.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create TocNode and Grip types</name>
  <files>
    - crates/memory-types/src/toc.rs
    - crates/memory-types/src/grip.rs
  </files>
  <action>
Define TOC node structure and Grip for provenance anchoring.

**crates/memory-types/src/toc.rs:**
```rust
//! Table of Contents (TOC) node types.
//!
//! The TOC is a time-based hierarchy:
//! Year -> Month -> Week -> Day -> Segment
//!
//! Each node contains a summary with title, bullets, and keywords.

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};

/// Level in the TOC hierarchy
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum TocLevel {
    Year,
    Month,
    Week,
    Day,
    Segment,
}

impl TocLevel {
    /// Get the parent level, if any
    pub fn parent(&self) -> Option<TocLevel> {
        match self {
            TocLevel::Year => None,
            TocLevel::Month => Some(TocLevel::Year),
            TocLevel::Week => Some(TocLevel::Month),
            TocLevel::Day => Some(TocLevel::Week),
            TocLevel::Segment => Some(TocLevel::Day),
        }
    }

    /// Get the child level, if any
    pub fn child(&self) -> Option<TocLevel> {
        match self {
            TocLevel::Year => Some(TocLevel::Month),
            TocLevel::Month => Some(TocLevel::Week),
            TocLevel::Week => Some(TocLevel::Day),
            TocLevel::Day => Some(TocLevel::Segment),
            TocLevel::Segment => None,
        }
    }
}

impl std::fmt::Display for TocLevel {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            TocLevel::Year => write!(f, "year"),
            TocLevel::Month => write!(f, "month"),
            TocLevel::Week => write!(f, "week"),
            TocLevel::Day => write!(f, "day"),
            TocLevel::Segment => write!(f, "segment"),
        }
    }
}

/// A bullet point in a TOC node summary
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TocBullet {
    /// The bullet text
    pub text: String,

    /// Optional grip IDs that support this bullet (provenance)
    #[serde(default)]
    pub grip_ids: Vec<String>,
}

impl TocBullet {
    pub fn new(text: impl Into<String>) -> Self {
        Self {
            text: text.into(),
            grip_ids: Vec::new(),
        }
    }

    pub fn with_grips(mut self, grip_ids: Vec<String>) -> Self {
        self.grip_ids = grip_ids;
        self
    }
}

/// A node in the Table of Contents hierarchy.
///
/// TOC nodes summarize time periods and link to children for drill-down.
/// Per TOC-02: Stores title, bullets, keywords, child_node_ids.
/// Per TOC-06: Nodes are versioned (append new version, don't mutate).
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TocNode {
    /// Unique identifier for this node
    pub node_id: String,

    /// Level in the hierarchy
    pub level: TocLevel,

    /// Human-readable title (e.g., "January 2024", "Week of Jan 15")
    pub title: String,

    /// Start of the time period this node covers
    #[serde(with = "chrono::serde::ts_milliseconds")]
    pub start_time: DateTime<Utc>,

    /// End of the time period this node covers
    #[serde(with = "chrono::serde::ts_milliseconds")]
    pub end_time: DateTime<Utc>,

    /// Summary bullet points
    pub bullets: Vec<TocBullet>,

    /// Keywords for search/filtering
    #[serde(default)]
    pub keywords: Vec<String>,

    /// IDs of child nodes (for drill-down)
    #[serde(default)]
    pub child_node_ids: Vec<String>,

    /// Version number (for TOC-06 versioning)
    pub version: u32,

    /// When this version was created
    #[serde(with = "chrono::serde::ts_milliseconds")]
    pub created_at: DateTime<Utc>,
}

impl TocNode {
    /// Create a new TOC node
    pub fn new(
        node_id: String,
        level: TocLevel,
        title: String,
        start_time: DateTime<Utc>,
        end_time: DateTime<Utc>,
    ) -> Self {
        Self {
            node_id,
            level,
            title,
            start_time,
            end_time,
            bullets: Vec::new(),
            keywords: Vec::new(),
            child_node_ids: Vec::new(),
            version: 1,
            created_at: Utc::now(),
        }
    }

    /// Serialize to JSON bytes
    pub fn to_bytes(&self) -> Result<Vec<u8>, serde_json::Error> {
        serde_json::to_vec(self)
    }

    /// Deserialize from JSON bytes
    pub fn from_bytes(bytes: &[u8]) -> Result<Self, serde_json::Error> {
        serde_json::from_slice(bytes)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_toc_level_hierarchy() {
        assert_eq!(TocLevel::Segment.parent(), Some(TocLevel::Day));
        assert_eq!(TocLevel::Day.parent(), Some(TocLevel::Week));
        assert_eq!(TocLevel::Year.parent(), None);
        assert_eq!(TocLevel::Year.child(), Some(TocLevel::Month));
        assert_eq!(TocLevel::Segment.child(), None);
    }

    #[test]
    fn test_toc_node_serialization() {
        let node = TocNode::new(
            "node-123".to_string(),
            TocLevel::Day,
            "Monday, January 15, 2024".to_string(),
            Utc::now(),
            Utc::now(),
        );

        let bytes = node.to_bytes().unwrap();
        let decoded = TocNode::from_bytes(&bytes).unwrap();

        assert_eq!(node.node_id, decoded.node_id);
        assert_eq!(node.level, decoded.level);
        assert_eq!(node.title, decoded.title);
    }
}
```

**crates/memory-types/src/grip.rs:**
```rust
//! Grip type for provenance anchoring.
//!
//! Grips link TOC summaries to source events, providing evidence
//! for claims made in bullet points.

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};

/// A grip anchors a summary excerpt to source events.
///
//! Per GRIP-01: Contains excerpt, event_id_start, event_id_end, timestamp, source.
/// Per GRIP-02: TOC node bullets link to supporting grips.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Grip {
    /// Unique identifier for this grip
    pub grip_id: String,

    /// The excerpt text that this grip anchors
    pub excerpt: String,

    /// First event in the range that supports this excerpt
    pub event_id_start: String,

    /// Last event in the range that supports this excerpt
    pub event_id_end: String,

    /// Timestamp of the excerpt (typically the start event's timestamp)
    #[serde(with = "chrono::serde::ts_milliseconds")]
    pub timestamp: DateTime<Utc>,

    /// Source context (e.g., which summarization produced this)
    pub source: String,

    /// Optional: The TOC node ID that uses this grip
    #[serde(default)]
    pub toc_node_id: Option<String>,
}

impl Grip {
    /// Create a new grip
    pub fn new(
        grip_id: String,
        excerpt: String,
        event_id_start: String,
        event_id_end: String,
        timestamp: DateTime<Utc>,
        source: String,
    ) -> Self {
        Self {
            grip_id,
            excerpt,
            event_id_start,
            event_id_end,
            timestamp,
            source,
            toc_node_id: None,
        }
    }

    /// Link this grip to a TOC node
    pub fn with_toc_node(mut self, toc_node_id: String) -> Self {
        self.toc_node_id = Some(toc_node_id);
        self
    }

    /// Serialize to JSON bytes
    pub fn to_bytes(&self) -> Result<Vec<u8>, serde_json::Error> {
        serde_json::to_vec(self)
    }

    /// Deserialize from JSON bytes
    pub fn from_bytes(bytes: &[u8]) -> Result<Self, serde_json::Error> {
        serde_json::from_slice(bytes)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_grip_serialization() {
        let grip = Grip::new(
            "grip-123".to_string(),
            "User asked about Rust memory safety".to_string(),
            "event-001".to_string(),
            "event-003".to_string(),
            Utc::now(),
            "segment_summarizer".to_string(),
        ).with_toc_node("toc-day-20240115".to_string());

        let bytes = grip.to_bytes().unwrap();
        let decoded = Grip::from_bytes(&bytes).unwrap();

        assert_eq!(grip.grip_id, decoded.grip_id);
        assert_eq!(grip.excerpt, decoded.excerpt);
        assert_eq!(grip.toc_node_id, decoded.toc_node_id);
    }
}
```
  </action>
  <verify>
`cargo test -p memory-types` passes all TOC and Grip tests.
  </verify>
  <done>
TocNode with hierarchy support and Grip for provenance anchoring created with full serialization support.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Settings configuration with layered loading</name>
  <files>
    - crates/memory-types/src/config.rs
    - crates/memory-types/Cargo.toml
    - crates/memory-types/src/lib.rs
  </files>
  <action>
Implement layered configuration per CFG-01, CFG-02, CFG-03.

**Update crates/memory-types/Cargo.toml** to add config and dirs dependencies:
```toml
[package]
name = "memory-types"
version.workspace = true
edition.workspace = true

[dependencies]
serde = { workspace = true }
serde_json = { workspace = true }
chrono = { workspace = true }
ulid = { workspace = true }
thiserror = { workspace = true }
config = { workspace = true }
dirs = "5"
```

**crates/memory-types/src/config.rs:**
```rust
//! Configuration loading for agent-memory.
//!
//! Per CFG-01: Layered config: defaults -> config file -> env vars -> CLI flags
//! Per CFG-02: Config includes db_path, grpc_port, summarizer settings
//! Per CFG-03: Config file at ~/.config/agent-memory/config.toml

use config::{Config, Environment, File};
use serde::{Deserialize, Serialize};
use std::path::PathBuf;

use crate::error::MemoryError;

/// Summarizer configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SummarizerSettings {
    /// Provider name (e.g., "openai", "anthropic", "local")
    #[serde(default = "default_summarizer_provider")]
    pub provider: String,

    /// Model name (e.g., "gpt-4o-mini", "claude-3-haiku")
    #[serde(default = "default_summarizer_model")]
    pub model: String,

    /// API key (loaded from env var, not stored in config file)
    #[serde(default)]
    pub api_key: Option<String>,

    /// API base URL (for custom endpoints)
    #[serde(default)]
    pub api_base_url: Option<String>,
}

fn default_summarizer_provider() -> String {
    "openai".to_string()
}

fn default_summarizer_model() -> String {
    "gpt-4o-mini".to_string()
}

impl Default for SummarizerSettings {
    fn default() -> Self {
        Self {
            provider: default_summarizer_provider(),
            model: default_summarizer_model(),
            api_key: None,
            api_base_url: None,
        }
    }
}

/// Multi-agent storage mode (STOR-06)
#[derive(Debug, Clone, Serialize, Deserialize, Default, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum MultiAgentMode {
    /// Each project gets its own RocksDB instance (default)
    #[default]
    Separate,
    /// Single unified store with agent_id tags for isolation
    Unified,
}

/// Main application settings
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Settings {
    /// Path to RocksDB storage directory
    #[serde(default = "default_db_path")]
    pub db_path: String,

    /// gRPC server port
    #[serde(default = "default_grpc_port")]
    pub grpc_port: u16,

    /// gRPC server host
    #[serde(default = "default_grpc_host")]
    pub grpc_host: String,

    /// Multi-agent mode: separate stores per project OR unified store with tags (STOR-06)
    #[serde(default)]
    pub multi_agent_mode: MultiAgentMode,

    /// Agent ID for unified mode (used as tag prefix)
    #[serde(default)]
    pub agent_id: Option<String>,

    /// Summarizer configuration
    #[serde(default)]
    pub summarizer: SummarizerSettings,

    /// Log level (trace, debug, info, warn, error)
    #[serde(default = "default_log_level")]
    pub log_level: String,
}

fn default_db_path() -> String {
    dirs::data_local_dir()
        .map(|p| p.join("agent-memory").join("db"))
        .unwrap_or_else(|| PathBuf::from("./data"))
        .to_string_lossy()
        .to_string()
}

fn default_grpc_port() -> u16 {
    50051
}

fn default_grpc_host() -> String {
    "0.0.0.0".to_string()
}

fn default_log_level() -> String {
    "info".to_string()
}

impl Default for Settings {
    fn default() -> Self {
        Self {
            db_path: default_db_path(),
            grpc_port: default_grpc_port(),
            grpc_host: default_grpc_host(),
            multi_agent_mode: MultiAgentMode::default(),
            agent_id: None,
            summarizer: SummarizerSettings::default(),
            log_level: default_log_level(),
        }
    }
}

impl Settings {
    /// Load settings with layered precedence:
    /// 1. Built-in defaults
    /// 2. Config file (~/.config/agent-memory/config.toml)
    /// 3. CLI-specified config file (optional)
    /// 4. Environment variables (MEMORY_*)
    ///
    /// CLI flags should be applied by the caller after this returns.
    pub fn load(cli_config_path: Option<&str>) -> Result<Self, MemoryError> {
        // Get default config file location (CFG-03)
        let config_dir = dirs::config_dir()
            .map(|p| p.join("agent-memory"))
            .unwrap_or_else(|| PathBuf::from("."));

        let default_config_path = config_dir.join("config");

        let mut builder = Config::builder()
            // 1. Built-in defaults
            .set_default("db_path", default_db_path())
            .map_err(|e| MemoryError::Config(e.to_string()))?
            .set_default("grpc_port", default_grpc_port() as i64)
            .map_err(|e| MemoryError::Config(e.to_string()))?
            .set_default("grpc_host", default_grpc_host())
            .map_err(|e| MemoryError::Config(e.to_string()))?
            .set_default("log_level", default_log_level())
            .map_err(|e| MemoryError::Config(e.to_string()))?
            .set_default("summarizer.provider", default_summarizer_provider())
            .map_err(|e| MemoryError::Config(e.to_string()))?
            .set_default("summarizer.model", default_summarizer_model())
            .map_err(|e| MemoryError::Config(e.to_string()))?
            // 2. Default config file (~/.config/agent-memory/config.toml)
            .add_source(
                File::with_name(&default_config_path.to_string_lossy())
                    .required(false)
            );

        // 3. CLI-specified config file (higher precedence than default)
        if let Some(path) = cli_config_path {
            builder = builder.add_source(
                File::with_name(path)
                    .required(true)
            );
        }

        // 4. Environment variables (highest precedence before CLI flags)
        // Format: MEMORY_DB_PATH, MEMORY_GRPC_PORT, MEMORY_SUMMARIZER_PROVIDER, etc.
        builder = builder.add_source(
            Environment::with_prefix("MEMORY")
                .separator("_")
                .try_parsing(true)
        );

        let config = builder
            .build()
            .map_err(|e| MemoryError::Config(e.to_string()))?;

        config
            .try_deserialize()
            .map_err(|e| MemoryError::Config(e.to_string()))
    }

    /// Get the socket address for the gRPC server
    pub fn grpc_addr(&self) -> String {
        format!("{}:{}", self.grpc_host, self.grpc_port)
    }

    /// Expand ~ in db_path to actual home directory
    pub fn expanded_db_path(&self) -> PathBuf {
        if self.db_path.starts_with("~/") {
            if let Some(home) = dirs::home_dir() {
                return home.join(&self.db_path[2..]);
            }
        }
        PathBuf::from(&self.db_path)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_default_settings() {
        let settings = Settings::default();
        assert_eq!(settings.grpc_port, 50051);
        assert_eq!(settings.grpc_host, "0.0.0.0");
        assert_eq!(settings.summarizer.provider, "openai");
    }

    #[test]
    fn test_load_with_env_override() {
        // Note: This test would need actual env vars set
        // For unit testing, we verify the defaults load correctly
        let settings = Settings::load(None).unwrap();
        assert_eq!(settings.grpc_port, 50051);
    }

    #[test]
    fn test_grpc_addr() {
        let settings = Settings::default();
        assert_eq!(settings.grpc_addr(), "0.0.0.0:50051");
    }
}
```

**Update crates/memory-types/src/lib.rs:**
```rust
//! Shared types for agent-memory system.
//!
//! This crate defines core data structures used across the memory system:
//! - Event types for conversation storage
//! - TOC (Table of Contents) hierarchy types
//! - Grip types for provenance anchoring
//! - Configuration structures
//! - Error types

pub mod config;
pub mod error;
pub mod event;
pub mod grip;
pub mod outbox;
pub mod toc;

// Re-export main types at crate root
pub use config::{MultiAgentMode, Settings, SummarizerSettings};
pub use error::MemoryError;
pub use event::{Event, EventRole, EventType};
pub use grip::Grip;
pub use outbox::{OutboxAction, OutboxEntry};
pub use toc::{TocBullet, TocLevel, TocNode};
```
  </action>
  <verify>
`cargo test -p memory-types` passes all tests.
`cargo build -p memory-types` compiles without errors.
  </verify>
  <done>
Settings struct with layered config loading (defaults, file, env vars). All domain types exported from crate root.
  </done>
</task>

</tasks>

<verification>
1. `cargo build -p memory-types` compiles without errors
2. `cargo test -p memory-types` passes all tests
3. Types implemented:
   - Event with session_id, timestamp, role, text, metadata (ING-02)
   - TocNode with title, bullets, keywords, child_node_ids (TOC-02)
   - Grip with excerpt, event_id_start, event_id_end (GRIP-01)
   - OutboxEntry for async processing
   - Settings with layered loading (CFG-01)
4. All types serialize/deserialize via serde
</verification>

<success_criteria>
- Event struct contains all required fields per ING-02
- TocNode struct supports full hierarchy (TOC-02)
- Grip struct supports provenance anchoring (GRIP-01)
- Settings loads from defaults -> file -> env vars (CFG-01)
- Config file location is ~/.config/agent-memory/config.toml (CFG-03)
- Settings includes MultiAgentMode enum (Separate/Unified) per STOR-06
- All types implement Serialize/Deserialize
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
