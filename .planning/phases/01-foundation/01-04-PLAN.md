---
phase: 01-foundation
plan: 04
type: execute
wave: 4
depends_on: ["01-02", "01-03"]
files_modified:
  - crates/memory-daemon/src/main.rs
  - crates/memory-daemon/src/cli.rs
  - crates/memory-daemon/src/commands.rs
  - crates/memory-daemon/Cargo.toml
autonomous: true

must_haves:
  truths:
    - "Daemon starts with `memory-daemon start --foreground`"
    - "Daemon accepts gRPC connections on configured port"
    - "Configuration loads from file, env vars, and CLI flags in correct precedence"
    - "Status command reports if daemon is running"
    - "Graceful shutdown on SIGINT/SIGTERM"
  artifacts:
    - path: "crates/memory-daemon/src/cli.rs"
      provides: "CLI argument parsing with clap"
      exports: ["Cli", "Commands"]
    - path: "crates/memory-daemon/src/commands.rs"
      provides: "Command implementations (start, stop, status)"
      exports: ["start_daemon", "stop_daemon", "show_status"]
    - path: "crates/memory-daemon/src/main.rs"
      provides: "Binary entry point"
  key_links:
    - from: "crates/memory-daemon/src/main.rs"
      to: "memory_types::Settings"
      via: "config loading"
      pattern: "Settings::load"
    - from: "crates/memory-daemon/src/commands.rs"
      to: "memory_service::run_server"
      via: "server startup"
      pattern: "run_server"
---

<objective>
Implement the daemon binary with CLI (start/stop/status), configuration loading, and graceful shutdown.

Purpose: Provide the executable that users run to start the memory service, with proper configuration layering and process management.
Output: Working `memory-daemon` binary that can be started via CLI, loads configuration from multiple sources, and handles shutdown gracefully.
</objective>

<execution_context>
@/Users/richardhightower/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardhightower/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-00-SUMMARY.md
@.planning/phases/01-foundation/01-02-SUMMARY.md
@.planning/phases/01-foundation/01-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement CLI argument parsing with clap</name>
  <files>
    - crates/memory-daemon/src/cli.rs
    - crates/memory-daemon/Cargo.toml
  </files>
  <action>
Create CLI structure with start/stop/status subcommands per CLI-01.

**Update crates/memory-daemon/Cargo.toml:**
```toml
[package]
name = "memory-daemon"
version.workspace = true
edition.workspace = true

[[bin]]
name = "memory-daemon"
path = "src/main.rs"

[dependencies]
memory-types = { workspace = true }
memory-service = { workspace = true }
memory-storage = { workspace = true }
clap = { workspace = true }
config = { workspace = true }
tokio = { workspace = true }
tracing = { workspace = true }
tracing-subscriber = { workspace = true }
anyhow = { workspace = true }
serde = { workspace = true }
dirs = "5"
```

**crates/memory-daemon/src/cli.rs:**
```rust
//! CLI argument parsing for the memory daemon.
//!
//! Per CLI-01: Memory daemon binary with start/stop/status commands.
//! Per CFG-01: CLI flags override all other config sources.

use clap::{Parser, Subcommand};

/// Agent Memory Daemon
///
/// A local, append-only conversational memory system for AI agents.
#[derive(Parser, Debug)]
#[command(name = "memory-daemon")]
#[command(author, version, about, long_about = None)]
pub struct Cli {
    /// Path to config file (overrides default ~/.config/agent-memory/config.toml)
    #[arg(short, long, global = true)]
    pub config: Option<String>,

    /// Set log level (trace, debug, info, warn, error)
    #[arg(short, long, global = true)]
    pub log_level: Option<String>,

    #[command(subcommand)]
    pub command: Commands,
}

/// Daemon commands
#[derive(Subcommand, Debug)]
pub enum Commands {
    /// Start the memory daemon
    Start {
        /// Run in foreground (don't daemonize)
        #[arg(short, long)]
        foreground: bool,

        /// Override gRPC port
        #[arg(short, long)]
        port: Option<u16>,

        /// Override database path
        #[arg(long)]
        db_path: Option<String>,
    },

    /// Stop the running daemon
    Stop,

    /// Show daemon status
    Status,
}

impl Cli {
    /// Parse CLI arguments
    pub fn parse_args() -> Self {
        Cli::parse()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_cli_start_foreground() {
        let cli = Cli::parse_from(["memory-daemon", "start", "--foreground"]);
        match cli.command {
            Commands::Start { foreground, .. } => assert!(foreground),
            _ => panic!("Expected Start command"),
        }
    }

    #[test]
    fn test_cli_start_with_port() {
        let cli = Cli::parse_from(["memory-daemon", "start", "-p", "9999"]);
        match cli.command {
            Commands::Start { port, .. } => assert_eq!(port, Some(9999)),
            _ => panic!("Expected Start command"),
        }
    }

    #[test]
    fn test_cli_with_config() {
        let cli = Cli::parse_from(["memory-daemon", "--config", "/path/to/config.toml", "start"]);
        assert_eq!(cli.config, Some("/path/to/config.toml".to_string()));
    }

    #[test]
    fn test_cli_status() {
        let cli = Cli::parse_from(["memory-daemon", "status"]);
        assert!(matches!(cli.command, Commands::Status));
    }
}
```
  </action>
  <verify>
`cargo test -p memory-daemon` passes CLI parsing tests.
  </verify>
  <done>
CLI structure with start/stop/status subcommands and global config/log-level flags.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement command handlers (start, stop, status)</name>
  <files>
    - crates/memory-daemon/src/commands.rs
  </files>
  <action>
Implement the command handlers with configuration loading and server startup.

**crates/memory-daemon/src/commands.rs:**
```rust
//! Command implementations for the memory daemon.
//!
//! Handles:
//! - start: Load config, open storage, start gRPC server
//! - stop: Signal running daemon to stop (via PID file)
//! - status: Check if daemon is running

use std::fs;
use std::net::SocketAddr;
use std::path::PathBuf;
use std::sync::Arc;

use anyhow::{Context, Result};
use tokio::signal;
use tracing::{error, info, warn};

use memory_service::run_server_with_shutdown;
use memory_storage::Storage;
use memory_types::Settings;

/// Get the PID file path
fn pid_file_path() -> PathBuf {
    dirs::runtime_dir()
        .or_else(|| dirs::state_dir())
        .unwrap_or_else(|| PathBuf::from("/tmp"))
        .join("agent-memory")
        .join("daemon.pid")
}

/// Write PID to file
fn write_pid_file() -> Result<()> {
    let pid_path = pid_file_path();
    if let Some(parent) = pid_path.parent() {
        fs::create_dir_all(parent)?;
    }
    fs::write(&pid_path, std::process::id().to_string())?;
    info!("Wrote PID file: {:?}", pid_path);
    Ok(())
}

/// Remove PID file
fn remove_pid_file() {
    let pid_path = pid_file_path();
    if pid_path.exists() {
        if let Err(e) = fs::remove_file(&pid_path) {
            warn!("Failed to remove PID file: {}", e);
        } else {
            info!("Removed PID file");
        }
    }
}

/// Read PID from file
fn read_pid_file() -> Option<u32> {
    let pid_path = pid_file_path();
    fs::read_to_string(&pid_path)
        .ok()
        .and_then(|s| s.trim().parse().ok())
}

/// Check if a process is running
fn is_process_running(pid: u32) -> bool {
    // On Unix, sending signal 0 checks if process exists
    #[cfg(unix)]
    {
        use std::os::unix::process::CommandExt;
        // kill -0 doesn't actually kill, just checks if process exists
        unsafe {
            libc::kill(pid as i32, 0) == 0
        }
    }

    #[cfg(not(unix))]
    {
        // On Windows, we'd need a different approach
        // For now, assume running if PID file exists
        true
    }
}

/// Start the memory daemon.
///
/// 1. Load configuration (CFG-01: defaults -> file -> env -> CLI)
/// 2. Open RocksDB storage
/// 3. Start gRPC server
/// 4. Handle graceful shutdown on SIGINT/SIGTERM
pub async fn start_daemon(
    config_path: Option<&str>,
    foreground: bool,
    port_override: Option<u16>,
    db_path_override: Option<&str>,
    log_level_override: Option<&str>,
) -> Result<()> {
    // Load configuration (CFG-01)
    let mut settings = Settings::load(config_path)
        .context("Failed to load configuration")?;

    // Apply CLI overrides (highest precedence per CFG-01)
    if let Some(port) = port_override {
        settings.grpc_port = port;
    }
    if let Some(db_path) = db_path_override {
        settings.db_path = db_path.to_string();
    }
    if let Some(log_level) = log_level_override {
        settings.log_level = log_level.to_string();
    }

    // Initialize logging
    let subscriber = tracing_subscriber::fmt()
        .with_env_filter(
            tracing_subscriber::EnvFilter::try_from_default_env()
                .unwrap_or_else(|_| {
                    tracing_subscriber::EnvFilter::new(&settings.log_level)
                })
        )
        .finish();
    tracing::subscriber::set_global_default(subscriber)
        .context("Failed to set tracing subscriber")?;

    info!("Memory daemon starting...");
    info!("Configuration:");
    info!("  Database path: {}", settings.db_path);
    info!("  gRPC address: {}", settings.grpc_addr());
    info!("  Log level: {}", settings.log_level);

    if !foreground {
        // TODO: Implement actual daemonization (double-fork on Unix)
        // For Phase 1, just warn and continue in foreground
        warn!("Background mode not yet implemented, running in foreground");
        warn!("Use a process manager (systemd, launchd) for background operation");
    }

    // Open storage (STOR-04: per-project RocksDB instance)
    let db_path = settings.expanded_db_path();
    info!("Opening storage at {:?}", db_path);

    // Create parent directories if needed
    if let Some(parent) = db_path.parent() {
        fs::create_dir_all(parent)
            .context("Failed to create database directory")?;
    }

    let storage = Storage::open(&db_path)
        .context("Failed to open storage")?;
    let storage = Arc::new(storage);

    // Write PID file
    write_pid_file()?;

    // Parse address
    let addr: SocketAddr = settings.grpc_addr().parse()
        .context("Invalid gRPC address")?;

    // Create shutdown signal handler
    let shutdown_signal = async {
        let ctrl_c = async {
            signal::ctrl_c()
                .await
                .expect("Failed to install Ctrl+C handler");
        };

        #[cfg(unix)]
        let terminate = async {
            signal::unix::signal(signal::unix::SignalKind::terminate())
                .expect("Failed to install SIGTERM handler")
                .recv()
                .await;
        };

        #[cfg(not(unix))]
        let terminate = std::future::pending::<()>();

        tokio::select! {
            _ = ctrl_c => {
                info!("Received Ctrl+C, shutting down...");
            }
            _ = terminate => {
                info!("Received SIGTERM, shutting down...");
            }
        }
    };

    // Start server
    let result = run_server_with_shutdown(addr, storage, shutdown_signal).await;

    // Cleanup
    remove_pid_file();

    result.map_err(|e| anyhow::anyhow!("Server error: {}", e))
}

/// Stop the running daemon by sending SIGTERM.
pub fn stop_daemon() -> Result<()> {
    let pid = read_pid_file().context("No PID file found - daemon may not be running")?;

    if !is_process_running(pid) {
        remove_pid_file();
        anyhow::bail!("Daemon not running (stale PID file removed)");
    }

    info!("Stopping daemon (PID {})", pid);

    #[cfg(unix)]
    {
        unsafe {
            if libc::kill(pid as i32, libc::SIGTERM) != 0 {
                anyhow::bail!("Failed to send SIGTERM to daemon");
            }
        }
        info!("Sent SIGTERM to daemon");
    }

    #[cfg(not(unix))]
    {
        anyhow::bail!("Stop command not yet implemented on this platform");
    }

    Ok(())
}

/// Show daemon status.
pub fn show_status() -> Result<()> {
    let pid_path = pid_file_path();

    match read_pid_file() {
        Some(pid) if is_process_running(pid) => {
            println!("Memory daemon is running (PID {})", pid);
            println!("PID file: {:?}", pid_path);
            Ok(())
        }
        Some(pid) => {
            println!("Memory daemon is NOT running (stale PID {} in {:?})", pid, pid_path);
            Ok(())
        }
        None => {
            println!("Memory daemon is NOT running (no PID file)");
            Ok(())
        }
    }
}
```

Add libc dependency to Cargo.toml for Unix signal handling:
```toml
[target.'cfg(unix)'.dependencies]
libc = "0.2"
```
  </action>
  <verify>
`cargo build -p memory-daemon` compiles without errors.
  </verify>
  <done>
Command handlers implement start (with config loading and server startup), stop (via PID file), and status checking.
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire up main entry point</name>
  <files>
    - crates/memory-daemon/src/main.rs
    - crates/memory-daemon/src/lib.rs
  </files>
  <action>
Create the main entry point that parses CLI and dispatches to command handlers.

**crates/memory-daemon/src/lib.rs:**
```rust
//! Memory daemon library exports.

pub mod cli;
pub mod commands;

pub use cli::{Cli, Commands};
pub use commands::{start_daemon, stop_daemon, show_status};
```

**crates/memory-daemon/src/main.rs:**
```rust
//! Agent Memory Daemon
//!
//! A local, append-only conversational memory system for AI agents.
//!
//! Usage:
//!   memory-daemon start [--foreground] [--port PORT] [--db-path PATH]
//!   memory-daemon stop
//!   memory-daemon status
//!
//! Configuration is loaded in order (later sources override earlier):
//! 1. Built-in defaults
//! 2. Config file (~/.config/agent-memory/config.toml)
//! 3. Environment variables (MEMORY_*)
//! 4. CLI flags

use anyhow::Result;
use clap::Parser;

use memory_daemon::{Cli, Commands, start_daemon, stop_daemon, show_status};

#[tokio::main]
async fn main() -> Result<()> {
    let cli = Cli::parse();

    match cli.command {
        Commands::Start { foreground, port, db_path } => {
            start_daemon(
                cli.config.as_deref(),
                foreground,
                port,
                db_path.as_deref(),
                cli.log_level.as_deref(),
            ).await?;
        }
        Commands::Stop => {
            stop_daemon()?;
        }
        Commands::Status => {
            show_status()?;
        }
    }

    Ok(())
}
```
  </action>
  <verify>
`cargo build -p memory-daemon` succeeds.
`cargo run -p memory-daemon -- --help` shows usage.
`cargo run -p memory-daemon -- start --help` shows start options.
  </verify>
  <done>
Main entry point wired to CLI parsing and command dispatch. Binary is ready for use.
  </done>
</task>

</tasks>

<verification>
1. `cargo build -p memory-daemon` compiles without errors
2. `cargo run -p memory-daemon -- --help` shows usage
3. `cargo run -p memory-daemon -- start --help` shows start options
4. `cargo run -p memory-daemon -- start --foreground` starts the daemon:
   - Loads configuration
   - Opens RocksDB storage
   - Starts gRPC server
   - Responds to health check: `grpcurl -plaintext localhost:50051 grpc.health.v1.Health/Check`
5. Ctrl+C gracefully shuts down the daemon
6. `cargo run -p memory-daemon -- status` reports daemon state
</verification>

<success_criteria>
- `memory-daemon start --foreground` starts daemon and accepts gRPC connections
- Configuration loads in correct precedence: defaults -> file -> env -> CLI (CFG-01)
- CLI supports --config, --port, --db-path, --log-level flags
- start/stop/status commands work (CLI-01)
- Health check endpoint responds (GRPC-03)
- Reflection endpoint works: `grpcurl -plaintext localhost:50051 list` (GRPC-04)
- Graceful shutdown on SIGINT/SIGTERM
- PID file management for stop/status commands
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-04-SUMMARY.md`
</output>
