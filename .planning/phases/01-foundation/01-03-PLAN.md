---
phase: 01-foundation
plan: 03
type: execute
wave: 3
depends_on: ["01-01", "01-02"]
files_modified:
  - proto/memory.proto
  - crates/memory-service/build.rs
  - crates/memory-service/src/lib.rs
  - crates/memory-service/src/server.rs
  - crates/memory-service/src/ingest.rs
autonomous: true

must_haves:
  truths:
    - "gRPC server starts and accepts connections"
    - "IngestEvent RPC persists events to RocksDB"
    - "Health check endpoint responds to queries"
    - "Reflection endpoint lists available services"
    - "Idempotent ingestion returns created=false for duplicates"
  artifacts:
    - path: "proto/memory.proto"
      provides: "Full proto definitions for Event, IngestEvent RPC"
      contains: "rpc IngestEvent"
    - path: "crates/memory-service/src/server.rs"
      provides: "gRPC server setup with health and reflection"
      exports: ["run_server"]
    - path: "crates/memory-service/src/ingest.rs"
      provides: "IngestEvent RPC implementation"
      exports: ["MemoryServiceImpl"]
  key_links:
    - from: "crates/memory-service/src/ingest.rs"
      to: "crates/memory-storage/src/db.rs"
      via: "Storage.put_event"
      pattern: "storage\\.put_event"
    - from: "crates/memory-service/src/server.rs"
      to: "tonic_health"
      via: "health service registration"
      pattern: "health_reporter"
---

<objective>
Implement the gRPC service layer with IngestEvent RPC, health checks, and reflection.

Purpose: Enable external clients (hook handlers) to send events to the daemon for persistence, with standard gRPC health/reflection for debugging.
Output: Working gRPC server that accepts IngestEvent requests, persists to RocksDB, and exposes health/reflection endpoints.
</objective>

<execution_context>
@/Users/richardhightower/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardhightower/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-00-SUMMARY.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
@.planning/phases/01-foundation/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define complete proto file with Event message and IngestEvent RPC</name>
  <files>
    - proto/memory.proto
    - crates/memory-service/build.rs
  </files>
  <action>
Update proto file with full message definitions per GRPC-02 and ING-01/ING-02.

**proto/memory.proto:**
```protobuf
syntax = "proto3";

package memory;

// Memory service for agent conversation storage.
//
// This service provides:
// - Event ingestion for conversation capture
// - Health check for monitoring
// - Reflection for debugging
service MemoryService {
    // Ingest a conversation event.
    //
    // Events are persisted to RocksDB with time-prefixed keys.
    // Idempotent: returns created=false if event_id already exists.
    rpc IngestEvent(IngestEventRequest) returns (IngestEventResponse);
}

// Role of the message author
enum EventRole {
    EVENT_ROLE_UNSPECIFIED = 0;
    EVENT_ROLE_USER = 1;
    EVENT_ROLE_ASSISTANT = 2;
    EVENT_ROLE_SYSTEM = 3;
    EVENT_ROLE_TOOL = 4;
}

// Type of conversation event
enum EventType {
    EVENT_TYPE_UNSPECIFIED = 0;
    EVENT_TYPE_SESSION_START = 1;
    EVENT_TYPE_USER_MESSAGE = 2;
    EVENT_TYPE_ASSISTANT_MESSAGE = 3;
    EVENT_TYPE_TOOL_RESULT = 4;
    EVENT_TYPE_ASSISTANT_STOP = 5;
    EVENT_TYPE_SUBAGENT_START = 6;
    EVENT_TYPE_SUBAGENT_STOP = 7;
    EVENT_TYPE_SESSION_END = 8;
}

// A conversation event to be stored.
//
// Per ING-02: Includes session_id, timestamp, role, text, metadata.
message Event {
    // Unique identifier (ULID string, generated by client)
    string event_id = 1;

    // Session this event belongs to
    string session_id = 2;

    // Source timestamp in milliseconds since Unix epoch.
    // Per ING-04: Used for ordering, not ingestion time.
    int64 timestamp_ms = 3;

    // Type of event
    EventType event_type = 4;

    // Role of the author
    EventRole role = 5;

    // Event content/text
    string text = 6;

    // Additional metadata (tool names, file paths, etc.)
    map<string, string> metadata = 7;
}

// Request to ingest an event
message IngestEventRequest {
    // The event to ingest
    Event event = 1;
}

// Response from event ingestion
message IngestEventResponse {
    // The event_id that was stored
    string event_id = 1;

    // True if event was newly created, false if already existed (idempotent)
    bool created = 2;
}
```

**Verify crates/memory-service/build.rs is correct:**
```rust
use std::{env, path::PathBuf};

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());

    tonic_build::configure()
        .file_descriptor_set_path(out_dir.join("memory_descriptor.bin"))
        .compile_protos(&["../../proto/memory.proto"], &["../../proto"])?;

    Ok(())
}
```
  </action>
  <verify>
`cargo build -p memory-service` compiles proto file successfully and generates Rust code.
  </verify>
  <done>
Proto file defines Event message with all required fields and IngestEvent RPC. Build generates Rust types.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement IngestEvent RPC handler</name>
  <files>
    - crates/memory-service/src/ingest.rs
    - crates/memory-service/src/lib.rs
  </files>
  <action>
Implement the MemoryService trait with IngestEvent handler that persists to Storage.

**crates/memory-service/src/ingest.rs:**
```rust
//! IngestEvent RPC implementation.
//!
//! Handles event ingestion by:
//! 1. Converting proto Event to domain Event
//! 2. Storing in RocksDB with atomic outbox entry (ING-05)
//! 3. Returning idempotent result (ING-03)

use std::collections::HashMap;
use std::sync::Arc;

use chrono::{TimeZone, Utc};
use tonic::{Request, Response, Status};
use tracing::{debug, error, info};

use memory_storage::Storage;
use memory_types::{Event, EventRole, EventType, OutboxEntry};

use crate::pb::{
    memory_service_server::MemoryService,
    Event as ProtoEvent,
    EventRole as ProtoEventRole,
    EventType as ProtoEventType,
    IngestEventRequest,
    IngestEventResponse,
};

/// Implementation of the MemoryService gRPC service.
pub struct MemoryServiceImpl {
    storage: Arc<Storage>,
}

impl MemoryServiceImpl {
    /// Create a new MemoryServiceImpl with the given storage.
    pub fn new(storage: Arc<Storage>) -> Self {
        Self { storage }
    }

    /// Convert proto EventRole to domain EventRole
    fn convert_role(proto_role: ProtoEventRole) -> EventRole {
        match proto_role {
            ProtoEventRole::User => EventRole::User,
            ProtoEventRole::Assistant => EventRole::Assistant,
            ProtoEventRole::System => EventRole::System,
            ProtoEventRole::Tool => EventRole::Tool,
            ProtoEventRole::Unspecified => EventRole::User, // Default
        }
    }

    /// Convert proto EventType to domain EventType
    fn convert_event_type(proto_type: ProtoEventType) -> EventType {
        match proto_type {
            ProtoEventType::SessionStart => EventType::SessionStart,
            ProtoEventType::UserMessage => EventType::UserMessage,
            ProtoEventType::AssistantMessage => EventType::AssistantMessage,
            ProtoEventType::ToolResult => EventType::ToolResult,
            ProtoEventType::AssistantStop => EventType::AssistantStop,
            ProtoEventType::SubagentStart => EventType::SubagentStart,
            ProtoEventType::SubagentStop => EventType::SubagentStop,
            ProtoEventType::SessionEnd => EventType::SessionEnd,
            ProtoEventType::Unspecified => EventType::UserMessage, // Default
        }
    }

    /// Convert proto Event to domain Event
    fn convert_event(proto: ProtoEvent) -> Result<Event, Status> {
        let timestamp = Utc
            .timestamp_millis_opt(proto.timestamp_ms)
            .single()
            .ok_or_else(|| Status::invalid_argument("Invalid timestamp"))?;

        let role = Self::convert_role(
            ProtoEventRole::try_from(proto.role).unwrap_or(ProtoEventRole::Unspecified)
        );
        let event_type = Self::convert_event_type(
            ProtoEventType::try_from(proto.event_type).unwrap_or(ProtoEventType::Unspecified)
        );

        let mut event = Event::new(
            proto.event_id,
            proto.session_id,
            timestamp,
            event_type,
            role,
            proto.text,
        );

        if !proto.metadata.is_empty() {
            event = event.with_metadata(proto.metadata);
        }

        Ok(event)
    }
}

#[tonic::async_trait]
impl MemoryService for MemoryServiceImpl {
    /// Ingest a conversation event.
    ///
    /// Per ING-01: Accepts Event message via gRPC.
    /// Per ING-03: Idempotent using event_id as key.
    /// Per ING-05: Outbox entry written atomically with event.
    async fn ingest_event(
        &self,
        request: Request<IngestEventRequest>,
    ) -> Result<Response<IngestEventResponse>, Status> {
        let req = request.into_inner();

        let proto_event = req.event.ok_or_else(|| {
            Status::invalid_argument("Event is required")
        })?;

        // Validate event_id
        if proto_event.event_id.is_empty() {
            return Err(Status::invalid_argument("event_id is required"));
        }

        // Validate session_id
        if proto_event.session_id.is_empty() {
            return Err(Status::invalid_argument("session_id is required"));
        }

        debug!("Ingesting event: {}", proto_event.event_id);

        // Convert proto to domain type
        let event = Self::convert_event(proto_event)?;
        let event_id = event.event_id.clone();
        let timestamp_ms = event.timestamp_ms();

        // Serialize event for storage
        let event_bytes = event.to_bytes().map_err(|e| {
            error!("Failed to serialize event: {}", e);
            Status::internal("Failed to serialize event")
        })?;

        // Create outbox entry for async index updates (ING-05)
        let outbox_entry = OutboxEntry::for_toc(event_id.clone(), timestamp_ms);
        let outbox_bytes = outbox_entry.to_bytes().map_err(|e| {
            error!("Failed to serialize outbox entry: {}", e);
            Status::internal("Failed to serialize outbox entry")
        })?;

        // Store event with atomic outbox write
        let (_, created) = self.storage.put_event(&event_id, &event_bytes, &outbox_bytes)
            .map_err(|e| {
                error!("Failed to store event: {}", e);
                Status::internal(format!("Storage error: {}", e))
            })?;

        if created {
            info!("Stored new event: {}", event_id);
        } else {
            debug!("Event already exists (idempotent): {}", event_id);
        }

        Ok(Response::new(IngestEventResponse {
            event_id,
            created,
        }))
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;

    fn create_test_service() -> (MemoryServiceImpl, TempDir) {
        let temp_dir = TempDir::new().unwrap();
        let storage = Storage::open(temp_dir.path()).unwrap();
        let service = MemoryServiceImpl::new(Arc::new(storage));
        (service, temp_dir)
    }

    #[tokio::test]
    async fn test_ingest_event_success() {
        let (service, _temp) = create_test_service();

        let request = Request::new(IngestEventRequest {
            event: Some(ProtoEvent {
                event_id: ulid::Ulid::new().to_string(),
                session_id: "session-123".to_string(),
                timestamp_ms: chrono::Utc::now().timestamp_millis(),
                event_type: ProtoEventType::UserMessage as i32,
                role: ProtoEventRole::User as i32,
                text: "Hello, world!".to_string(),
                metadata: HashMap::new(),
            }),
        });

        let response = service.ingest_event(request).await.unwrap();
        let resp = response.into_inner();

        assert!(resp.created);
        assert!(!resp.event_id.is_empty());
    }

    #[tokio::test]
    async fn test_ingest_event_idempotent() {
        let (service, _temp) = create_test_service();

        let event_id = ulid::Ulid::new().to_string();
        let event = ProtoEvent {
            event_id: event_id.clone(),
            session_id: "session-123".to_string(),
            timestamp_ms: chrono::Utc::now().timestamp_millis(),
            event_type: ProtoEventType::UserMessage as i32,
            role: ProtoEventRole::User as i32,
            text: "Hello, world!".to_string(),
            metadata: HashMap::new(),
        };

        // First ingestion
        let response1 = service.ingest_event(Request::new(IngestEventRequest {
            event: Some(event.clone()),
        })).await.unwrap();

        // Second ingestion (same event_id)
        let response2 = service.ingest_event(Request::new(IngestEventRequest {
            event: Some(event),
        })).await.unwrap();

        assert!(response1.into_inner().created);
        assert!(!response2.into_inner().created); // Idempotent
    }

    #[tokio::test]
    async fn test_ingest_event_missing_event() {
        let (service, _temp) = create_test_service();

        let request = Request::new(IngestEventRequest { event: None });
        let result = service.ingest_event(request).await;

        assert!(result.is_err());
        assert_eq!(result.unwrap_err().code(), tonic::Code::InvalidArgument);
    }
}
```

**Update crates/memory-service/src/lib.rs:**
```rust
//! gRPC service implementation for agent-memory.
//!
//! Provides:
//! - IngestEvent RPC for event ingestion (ING-01)
//! - Health check endpoint (GRPC-03)
//! - Reflection endpoint for debugging (GRPC-04)

pub mod ingest;
pub mod server;

pub mod pb {
    tonic::include_proto!("memory");

    pub const FILE_DESCRIPTOR_SET: &[u8] =
        tonic::include_file_descriptor_set!("memory_descriptor");
}

pub use ingest::MemoryServiceImpl;
pub use server::run_server;
```
  </action>
  <verify>
`cargo test -p memory-service` passes all ingest tests.
  </verify>
  <done>
MemoryServiceImpl handles IngestEvent RPC with idempotent storage and outbox writes.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement gRPC server with health and reflection</name>
  <files>
    - crates/memory-service/src/server.rs
  </files>
  <action>
Create the gRPC server setup with health check and reflection per GRPC-01, GRPC-03, GRPC-04.

**crates/memory-service/src/server.rs:**
```rust
//! gRPC server setup with health check and reflection.
//!
//! Per GRPC-01: Memory daemon exposes gRPC service via tonic.
//! Per GRPC-03: Health check endpoint via tonic-health.
//! Per GRPC-04: Reflection endpoint via tonic-reflection.

use std::net::SocketAddr;
use std::sync::Arc;

use tonic::transport::Server;
use tonic_health::server::health_reporter;
use tonic_reflection::server::Builder as ReflectionBuilder;
use tracing::{error, info};

use memory_storage::Storage;

use crate::ingest::MemoryServiceImpl;
use crate::pb::{memory_service_server::MemoryServiceServer, FILE_DESCRIPTOR_SET};

/// Run the gRPC server with health check and reflection.
///
/// This function:
/// 1. Sets up the health check service (GRPC-03)
/// 2. Sets up the reflection service (GRPC-04)
/// 3. Registers the MemoryService
/// 4. Starts serving on the given address
pub async fn run_server(
    addr: SocketAddr,
    storage: Arc<Storage>,
) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
    info!("Starting gRPC server on {}", addr);

    // Health check service (GRPC-03)
    let (mut health_reporter, health_service) = health_reporter();

    // Mark MemoryService as serving
    health_reporter
        .set_serving::<MemoryServiceServer<MemoryServiceImpl>>()
        .await;

    // Reflection service (GRPC-04)
    let reflection_service = ReflectionBuilder::configure()
        .register_encoded_file_descriptor_set(FILE_DESCRIPTOR_SET)
        .build_v1()?;

    // Main service implementation
    let memory_service = MemoryServiceImpl::new(storage);

    info!("gRPC server ready on {}", addr);

    Server::builder()
        .add_service(health_service)
        .add_service(reflection_service)
        .add_service(MemoryServiceServer::new(memory_service))
        .serve(addr)
        .await?;

    Ok(())
}

/// Run the gRPC server with graceful shutdown support.
///
/// Accepts a shutdown signal future that, when resolved, triggers graceful shutdown.
pub async fn run_server_with_shutdown<F>(
    addr: SocketAddr,
    storage: Arc<Storage>,
    shutdown_signal: F,
) -> Result<(), Box<dyn std::error::Error + Send + Sync>>
where
    F: std::future::Future<Output = ()> + Send + 'static,
{
    info!("Starting gRPC server on {} (with graceful shutdown)", addr);

    // Health check service (GRPC-03)
    let (mut health_reporter, health_service) = health_reporter();

    // Mark MemoryService as serving
    health_reporter
        .set_serving::<MemoryServiceServer<MemoryServiceImpl>>()
        .await;

    // Reflection service (GRPC-04)
    let reflection_service = ReflectionBuilder::configure()
        .register_encoded_file_descriptor_set(FILE_DESCRIPTOR_SET)
        .build_v1()?;

    // Main service implementation
    let memory_service = MemoryServiceImpl::new(storage);

    info!("gRPC server ready on {}", addr);

    Server::builder()
        .add_service(health_service)
        .add_service(reflection_service)
        .add_service(MemoryServiceServer::new(memory_service))
        .serve_with_shutdown(addr, shutdown_signal)
        .await?;

    info!("gRPC server shutdown complete");
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::time::Duration;
    use tempfile::TempDir;
    use tokio::time::timeout;

    #[tokio::test]
    async fn test_server_starts_and_shuts_down() {
        let temp_dir = TempDir::new().unwrap();
        let storage = Arc::new(Storage::open(temp_dir.path()).unwrap());

        let addr: SocketAddr = "127.0.0.1:0".parse().unwrap();

        // Create a shutdown signal that fires immediately
        let (tx, rx) = tokio::sync::oneshot::channel::<()>();

        let server_handle = tokio::spawn(async move {
            run_server_with_shutdown(addr, storage, async {
                rx.await.ok();
            }).await
        });

        // Give server time to start
        tokio::time::sleep(Duration::from_millis(100)).await;

        // Trigger shutdown
        tx.send(()).ok();

        // Server should shut down within reasonable time
        let result = timeout(Duration::from_secs(5), server_handle).await;
        assert!(result.is_ok());
    }
}
```
  </action>
  <verify>
`cargo test -p memory-service` passes server tests.
`cargo build -p memory-service` compiles without errors.
  </verify>
  <done>
gRPC server setup with health check (GRPC-03) and reflection (GRPC-04) services. Supports graceful shutdown.
  </done>
</task>

</tasks>

<verification>
1. `cargo build -p memory-service` compiles without errors
2. `cargo test -p memory-service` passes all tests
3. Proto file defines:
   - Event message with all required fields
   - IngestEvent RPC
4. Server implements:
   - Health check endpoint
   - Reflection endpoint
   - MemoryService with IngestEvent handler
5. IngestEvent:
   - Persists to RocksDB via Storage
   - Returns created=false for duplicates (idempotent)
   - Writes outbox entry atomically
</verification>

<success_criteria>
- Proto defines Event, EventRole, EventType, IngestEventRequest/Response
- IngestEvent RPC accepts Event and persists to RocksDB
- Idempotent writes return created=false for duplicates (ING-03)
- Outbox entry written atomically with event (ING-05)
- Health check endpoint responds (GRPC-03)
- Reflection endpoint lists services (GRPC-04)
- Server supports graceful shutdown
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-03-SUMMARY.md`
</output>
