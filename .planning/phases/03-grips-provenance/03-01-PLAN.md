---
phase: 03-grips-provenance
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/memory-storage/src/db.rs
  - crates/memory-toc/src/grip_id.rs
  - crates/memory-toc/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "Grips stored in CF_GRIPS column family"
    - "Grip IDs encode timestamp and ULID for ordering"
    - "Grips can be retrieved by ID"
    - "Grips can be queried by TOC node ID"
  artifacts:
    - path: "crates/memory-storage/src/db.rs"
      provides: "Grip storage methods"
      exports: ["put_grip", "get_grip", "get_grips_for_node"]
    - path: "crates/memory-toc/src/grip_id.rs"
      provides: "Grip ID generation"
      exports: ["generate_grip_id"]
  key_links:
    - from: "crates/memory-toc/src/grip_id.rs"
      to: "crates/memory-types/src/grip.rs"
      via: "Grip type"
      pattern: "Grip"
---

<objective>
Implement grip storage layer and ID generation utilities.

Purpose: Enable storage and retrieval of grips that anchor TOC summaries to source events.
Output: Storage methods for grip CRUD operations and grip ID generation.
</objective>

<execution_context>
@/Users/richardhightower/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardhightower/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-grips-provenance/03-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Grip storage methods to Storage</name>
  <files>
    - crates/memory-storage/src/db.rs
  </files>
  <action>
Add methods for storing and retrieving grips.

**Update crates/memory-storage/src/db.rs:**

Add import for CF_GRIPS and add these methods to the Storage impl block:

```rust
use crate::column_families::{..., CF_GRIPS};

impl Storage {
    // ... existing methods ...

    /// Store a grip.
    pub fn put_grip(&self, grip: &memory_types::Grip) -> Result<(), StorageError> {
        let grips_cf = self.db.cf_handle(CF_GRIPS)
            .ok_or_else(|| StorageError::ColumnFamilyNotFound(CF_GRIPS.to_string()))?;

        let grip_bytes = grip.to_bytes()
            .map_err(|e| StorageError::Serialization(e.to_string()))?;

        self.db.put_cf(&grips_cf, grip.grip_id.as_bytes(), &grip_bytes)?;

        // If linked to a TOC node, create index entry
        if let Some(ref node_id) = grip.toc_node_id {
            let index_key = format!("node:{}:{}", node_id, grip.grip_id);
            self.db.put_cf(&grips_cf, index_key.as_bytes(), &[])?;
        }

        debug!(grip_id = %grip.grip_id, "Stored grip");
        Ok(())
    }

    /// Get a grip by ID.
    pub fn get_grip(&self, grip_id: &str) -> Result<Option<memory_types::Grip>, StorageError> {
        let grips_cf = self.db.cf_handle(CF_GRIPS)
            .ok_or_else(|| StorageError::ColumnFamilyNotFound(CF_GRIPS.to_string()))?;

        match self.db.get_cf(&grips_cf, grip_id.as_bytes())? {
            Some(bytes) => {
                let grip = memory_types::Grip::from_bytes(&bytes)
                    .map_err(|e| StorageError::Serialization(e.to_string()))?;
                Ok(Some(grip))
            }
            None => Ok(None),
        }
    }

    /// Get all grips linked to a TOC node.
    pub fn get_grips_for_node(&self, node_id: &str) -> Result<Vec<memory_types::Grip>, StorageError> {
        let grips_cf = self.db.cf_handle(CF_GRIPS)
            .ok_or_else(|| StorageError::ColumnFamilyNotFound(CF_GRIPS.to_string()))?;

        let prefix = format!("node:{}:", node_id);
        let mut grips = Vec::new();

        let iter = self.db.iterator_cf(
            &grips_cf,
            IteratorMode::From(prefix.as_bytes(), Direction::Forward),
        );

        for item in iter {
            let (key, _) = item?;
            let key_str = String::from_utf8_lossy(&key);

            // Stop if we've passed this node's prefix
            if !key_str.starts_with(&prefix) {
                break;
            }

            // Extract grip_id from key
            let grip_id = key_str.trim_start_matches(&prefix);
            if let Some(grip) = self.get_grip(grip_id)? {
                grips.push(grip);
            }
        }

        Ok(grips)
    }

    /// Delete a grip and its index entry.
    pub fn delete_grip(&self, grip_id: &str) -> Result<(), StorageError> {
        let grips_cf = self.db.cf_handle(CF_GRIPS)
            .ok_or_else(|| StorageError::ColumnFamilyNotFound(CF_GRIPS.to_string()))?;

        // Get grip first to find index entry
        if let Some(grip) = self.get_grip(grip_id)? {
            // Delete index entry if exists
            if let Some(ref node_id) = grip.toc_node_id {
                let index_key = format!("node:{}:{}", node_id, grip_id);
                self.db.delete_cf(&grips_cf, index_key.as_bytes())?;
            }
        }

        // Delete grip itself
        self.db.delete_cf(&grips_cf, grip_id.as_bytes())?;

        debug!(grip_id = %grip_id, "Deleted grip");
        Ok(())
    }
}
```

Add tests:

```rust
#[test]
fn test_grip_roundtrip() {
    let (storage, _temp) = create_test_storage();

    let grip = memory_types::Grip::new(
        "grip:1706540400000:test123".to_string(),
        "User asked about authentication".to_string(),
        "event-001".to_string(),
        "event-003".to_string(),
        chrono::Utc::now(),
        "segment_summarizer".to_string(),
    );

    storage.put_grip(&grip).unwrap();
    let retrieved = storage.get_grip("grip:1706540400000:test123").unwrap();

    assert!(retrieved.is_some());
    let retrieved_grip = retrieved.unwrap();
    assert_eq!(retrieved_grip.excerpt, grip.excerpt);
}

#[test]
fn test_grip_with_node_index() {
    let (storage, _temp) = create_test_storage();

    let grip = memory_types::Grip::new(
        "grip:1706540400000:test456".to_string(),
        "Discussed JWT tokens".to_string(),
        "event-010".to_string(),
        "event-015".to_string(),
        chrono::Utc::now(),
        "segment_summarizer".to_string(),
    ).with_toc_node("toc:day:2024-01-29".to_string());

    storage.put_grip(&grip).unwrap();

    let grips = storage.get_grips_for_node("toc:day:2024-01-29").unwrap();
    assert_eq!(grips.len(), 1);
    assert_eq!(grips[0].grip_id, "grip:1706540400000:test456");
}

#[test]
fn test_grip_not_found() {
    let (storage, _temp) = create_test_storage();

    let result = storage.get_grip("grip:nonexistent").unwrap();
    assert!(result.is_none());
}

#[test]
fn test_delete_grip() {
    let (storage, _temp) = create_test_storage();

    let grip = memory_types::Grip::new(
        "grip:1706540400000:del123".to_string(),
        "Test excerpt".to_string(),
        "event-001".to_string(),
        "event-002".to_string(),
        chrono::Utc::now(),
        "test".to_string(),
    ).with_toc_node("toc:day:2024-01-30".to_string());

    storage.put_grip(&grip).unwrap();
    assert!(storage.get_grip("grip:1706540400000:del123").unwrap().is_some());

    storage.delete_grip("grip:1706540400000:del123").unwrap();
    assert!(storage.get_grip("grip:1706540400000:del123").unwrap().is_none());

    // Index should also be deleted
    let grips = storage.get_grips_for_node("toc:day:2024-01-30").unwrap();
    assert!(grips.is_empty());
}
```
  </action>
  <verify>
`cargo build -p memory-storage` compiles with grip methods.
`cargo test -p memory-storage` passes all tests including new grip tests.
  </verify>
  <done>
Storage has methods for grip CRUD operations with node indexing.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement Grip ID generation</name>
  <files>
    - crates/memory-toc/src/grip_id.rs
    - crates/memory-toc/src/lib.rs
  </files>
  <action>
Create grip ID generation utilities.

**Create crates/memory-toc/src/grip_id.rs:**

```rust
//! Grip ID generation utilities.
//!
//! Grip IDs encode timestamp and ULID for ordering and uniqueness.

use chrono::{DateTime, Utc};

/// Generate a grip ID with timestamp and ULID.
///
/// Format: "grip:{timestamp_ms}:{ulid}"
///
/// The timestamp prefix enables time-ordered iteration.
pub fn generate_grip_id(timestamp: DateTime<Utc>) -> String {
    let timestamp_ms = timestamp.timestamp_millis();
    let ulid = ulid::Ulid::new();
    format!("grip:{}:{}", timestamp_ms, ulid)
}

/// Parse timestamp from grip ID.
pub fn parse_grip_timestamp(grip_id: &str) -> Option<DateTime<Utc>> {
    let parts: Vec<&str> = grip_id.split(':').collect();
    if parts.len() < 2 || parts[0] != "grip" {
        return None;
    }

    parts[1].parse::<i64>().ok()
        .and_then(|ms| chrono::DateTime::from_timestamp_millis(ms))
}

/// Check if a string is a valid grip ID format.
pub fn is_valid_grip_id(grip_id: &str) -> bool {
    let parts: Vec<&str> = grip_id.split(':').collect();
    if parts.len() != 3 || parts[0] != "grip" {
        return false;
    }

    // Check timestamp is numeric
    if parts[1].parse::<i64>().is_err() {
        return false;
    }

    // Check ULID format (26 characters, alphanumeric)
    parts[2].len() == 26 && parts[2].chars().all(|c| c.is_ascii_alphanumeric())
}

#[cfg(test)]
mod tests {
    use super::*;
    use chrono::TimeZone;

    #[test]
    fn test_generate_grip_id() {
        let timestamp = Utc.with_ymd_and_hms(2024, 1, 29, 12, 0, 0).unwrap();
        let grip_id = generate_grip_id(timestamp);

        assert!(grip_id.starts_with("grip:1706529600000:"));
        assert!(is_valid_grip_id(&grip_id));
    }

    #[test]
    fn test_parse_grip_timestamp() {
        let timestamp = Utc.with_ymd_and_hms(2024, 1, 29, 12, 0, 0).unwrap();
        let grip_id = generate_grip_id(timestamp);

        let parsed = parse_grip_timestamp(&grip_id).unwrap();
        assert_eq!(parsed.timestamp_millis(), timestamp.timestamp_millis());
    }

    #[test]
    fn test_is_valid_grip_id() {
        assert!(is_valid_grip_id("grip:1706529600000:01HN4QXKN6ABCDEFGHIJKLMNO"));
        assert!(!is_valid_grip_id("invalid"));
        assert!(!is_valid_grip_id("grip:abc:123"));
        assert!(!is_valid_grip_id("toc:day:2024-01-29"));
    }

    #[test]
    fn test_parse_invalid_grip_id() {
        assert!(parse_grip_timestamp("invalid").is_none());
        assert!(parse_grip_timestamp("grip:abc:123").is_none());
    }
}
```

**Update crates/memory-toc/src/lib.rs:**

Add the new module and exports:

```rust
pub mod grip_id;

pub use grip_id::{generate_grip_id, is_valid_grip_id, parse_grip_timestamp};
```
  </action>
  <verify>
`cargo build -p memory-toc` compiles with grip_id module.
`cargo test -p memory-toc -- grip_id` passes.
  </verify>
  <done>
Grip ID generation utilities with timestamp encoding and validation.
  </done>
</task>

</tasks>

<verification>
1. `cargo build -p memory-storage` compiles without errors
2. `cargo build -p memory-toc` compiles without errors
3. `cargo test -p memory-storage` passes all tests (should have 4+ new grip tests)
4. `cargo test -p memory-toc` passes all tests (should have 4+ new grip_id tests)
5. Grips can be stored and retrieved by ID
6. Grips can be queried by TOC node ID
7. Grip IDs follow the format "grip:{timestamp_ms}:{ulid}"
</verification>

<success_criteria>
- GRIP-03: Grips stored in dedicated column family (CF_GRIPS)
- Grip CRUD operations work correctly
- Node index enables efficient grip lookup by TOC node
- Grip IDs are time-ordered and unique
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-grips-provenance/03-01-SUMMARY.md`
</output>
