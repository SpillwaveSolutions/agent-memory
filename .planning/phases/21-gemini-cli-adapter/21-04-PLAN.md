---
phase: 21-gemini-cli-adapter
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - plugins/memory-gemini-adapter/.gemini/hooks/memory-capture.sh
  - plugins/memory-gemini-adapter/.gemini/skills/memory-gemini-install/SKILL.md
  - plugins/memory-gemini-adapter/README.md
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Hook script works correctly on systems with jq 1.5 (redaction uses del-based fallback instead of walk)"
    - "ANSI stripping handles OSC hyperlink sequences and other escape forms, not just CSI"
    - "Per-project install via the install skill automatically rewrites hook command paths to project-relative paths"
  artifacts:
    - path: "plugins/memory-gemini-adapter/.gemini/hooks/memory-capture.sh"
      provides: "jq version detection, fallback redaction filter, broader ANSI stripping"
      contains: "JQ_HAS_WALK"
    - path: "plugins/memory-gemini-adapter/.gemini/skills/memory-gemini-install/SKILL.md"
      provides: "Per-project path rewriting logic in install instructions"
      contains: "project"
    - path: "plugins/memory-gemini-adapter/README.md"
      provides: "Updated jq version note and per-project install clarity"
      contains: "jq 1.6"
  key_links:
    - from: "memory-capture.sh (jq version check)"
      to: "REDACT_FILTER variable"
      via: "conditional assignment based on JQ_HAS_WALK flag"
      pattern: "JQ_HAS_WALK.*REDACT_FILTER"
    - from: "memory-capture.sh (ANSI strip)"
      to: "INPUT variable"
      via: "perl with sed fallback for broad escape removal"
      pattern: "perl.*\\\\e\\]"
    - from: "SKILL.md (install skill)"
      to: "settings.json command paths"
      via: "per-project path rewrite logic"
      pattern: "\\.gemini/hooks/memory-capture\\.sh"
---

<objective>
Fix 3 UAT findings from Phase 21 post-execution review.

Purpose: Close silent failure gaps in the Gemini CLI adapter -- jq 1.5 compatibility, robust ANSI stripping, and correct per-project install paths.
Output: Updated memory-capture.sh, install skill SKILL.md, and README.md.
</objective>

<execution_context>
@/Users/richardhightower/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardhightower/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-gemini-cli-adapter/21-UAT.md
@plugins/memory-gemini-adapter/.gemini/hooks/memory-capture.sh
@plugins/memory-gemini-adapter/.gemini/skills/memory-gemini-install/SKILL.md
@plugins/memory-gemini-adapter/README.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Harden memory-capture.sh -- jq version check and ANSI stripping</name>
  <files>plugins/memory-gemini-adapter/.gemini/hooks/memory-capture.sh</files>
  <action>
Fix Finding 1 (jq walk requires 1.6+) and Finding 2 (ANSI stripping is partial) in the hook script. All changes go inside the existing `main_logic()` function.

**Finding 1 fix -- jq version detection and fallback redaction filter:**

After the existing jq availability guard (line 40-42), add a jq version check that detects whether `walk` is available. The approach:

1. After `command -v jq` check passes, test jq version:
   ```bash
   JQ_HAS_WALK=false
   if jq -n 'walk(.)' >/dev/null 2>&1; then
     JQ_HAS_WALK=true
   fi
   ```
   This is a runtime capability check (not string parsing) -- it directly tests whether the installed jq supports `walk`. This is more reliable than parsing version strings since some distributions backport features.

2. Replace the single `REDACT_FILTER` assignment (currently line 74) with a conditional:
   ```bash
   if [ "$JQ_HAS_WALK" = "true" ]; then
     REDACT_FILTER='walk(if type == "object" then with_entries(select(.key | test("api_key|token|secret|password|credential|authorization"; "i") | not)) else . end)'
   else
     # Fallback for jq < 1.6: delete known sensitive keys at top level and one level deep
     # Does not recurse into nested objects, but catches the common case
     REDACT_FILTER='del(.api_key, .token, .secret, .password, .credential, .authorization, .API_KEY, .TOKEN, .SECRET, .PASSWORD, .CREDENTIAL, .AUTHORIZATION) | if type == "object" then to_entries | map(if (.value | type) == "object" then .value |= del(.api_key, .token, .secret, .password, .credential, .authorization, .API_KEY, .TOKEN, .SECRET, .PASSWORD, .CREDENTIAL, .AUTHORIZATION) else . end) | from_entries else . end'
   fi
   ```
   The fallback uses `del()` on known key names at top level and one level deep. It is not recursive like `walk` but covers the practical cases (tool_input fields are typically flat or one level deep). This is explicitly better than silent data loss from a failed `walk` call.

3. The rest of the script uses `$REDACT_FILTER` unchanged -- the lines at ~101, ~116, ~130, ~144 that apply the filter do not need modification since they reference the variable.

**Finding 2 fix -- broader ANSI stripping:**

Replace line 54 (the sed-based ANSI strip) with a broader approach using `perl` with `sed` fallback:

```bash
# Strip ANSI escape sequences from input
# Gemini CLI can emit colored/streaming output that contaminates JSON
# Handles CSI sequences (ESC[...X), OSC sequences (ESC]...ST), and other escapes
if command -v perl >/dev/null 2>&1; then
  INPUT=$(printf '%s' "$INPUT" | perl -pe 's/\e\[[0-9;]*[A-Za-z]//g; s/\e\][^\a\e]*(?:\a|\e\\)//g; s/\e[^[\]].//g') || return 0
else
  # Fallback: sed handles CSI only (most common case)
  INPUT=$(printf '%s' "$INPUT" | sed $'s/\x1b\[[0-9;]*[a-zA-Z]//g') || return 0
fi
```

The `perl` regex handles three categories:
- `\e\[[0-9;]*[A-Za-z]` -- CSI sequences (colors, cursor movement)
- `\e\][^\a\e]*(?:\a|\e\\)` -- OSC sequences (hyperlinks, window titles) terminated by BEL or ST
- `\e[^[\]].` -- Other two-byte escape sequences (SS2, SS3, etc.)

The `sed` fallback is retained for minimal systems without perl (rare -- perl is on virtually all macOS and Linux).

**Important constraints:**
- Preserve the existing fail-open design. Every new code path must `return 0` on failure.
- Do NOT change the trap, the function structure, or the stdin reading logic.
- Do NOT modify the event mapping case statement logic (only the REDACT_FILTER variable and ANSI strip are changing).
- Keep the `set -euo pipefail` and existing guards intact.
  </action>
  <verify>
Run these validation checks from the repository root:

```bash
# 1. Verify script has valid bash syntax
bash -n plugins/memory-gemini-adapter/.gemini/hooks/memory-capture.sh

# 2. Verify JQ_HAS_WALK detection is present
grep -q 'JQ_HAS_WALK' plugins/memory-gemini-adapter/.gemini/hooks/memory-capture.sh

# 3. Verify fallback redaction path exists (del-based)
grep -q 'del(.api_key' plugins/memory-gemini-adapter/.gemini/hooks/memory-capture.sh

# 4. Verify perl-based ANSI stripping is present
grep -q 'perl.*\\\\e\\]' plugins/memory-gemini-adapter/.gemini/hooks/memory-capture.sh || grep -q 'perl.*OSC\|perl.*escape' plugins/memory-gemini-adapter/.gemini/hooks/memory-capture.sh

# 5. Verify sed fallback for ANSI stripping still exists
grep -q 'sed.*\\\\x1b' plugins/memory-gemini-adapter/.gemini/hooks/memory-capture.sh

# 6. Verify fail-open trap is still intact
grep -q 'trap fail_open' plugins/memory-gemini-adapter/.gemini/hooks/memory-capture.sh

# 7. Dry-run test: script handles empty stdin without error
echo '' | MEMORY_INGEST_DRY_RUN=1 bash plugins/memory-gemini-adapter/.gemini/hooks/memory-capture.sh

# 8. Dry-run test: script handles valid JSON event
echo '{"hook_event_name":"SessionStart","session_id":"test-123","timestamp":"2026-01-01T00:00:00Z","cwd":"/tmp"}' | MEMORY_INGEST_DRY_RUN=1 bash plugins/memory-gemini-adapter/.gemini/hooks/memory-capture.sh
```

All commands should exit 0. The dry-run tests should output `{}`.
  </verify>
  <done>
memory-capture.sh detects jq walk capability at startup and uses del-based fallback redaction when walk is unavailable. ANSI stripping handles CSI, OSC, and other escape sequences using perl with sed fallback. Script passes bash -n syntax check and dry-run tests on both empty and valid JSON input.
  </done>
</task>

<task type="auto">
  <name>Task 2: Fix per-project install paths and update documentation</name>
  <files>plugins/memory-gemini-adapter/.gemini/skills/memory-gemini-install/SKILL.md, plugins/memory-gemini-adapter/README.md</files>
  <action>
Fix Finding 3 (per-project installs point to wrong hook path) in the install skill and improve documentation.

**SKILL.md changes -- add per-project path rewriting:**

1. In "Step 2: Create Directories" (currently lines ~93-108), add a conditional for per-project mode:

   After the existing `mkdir -p ~/.gemini/...` commands, add a section:

   ```markdown
   ### Per-Project Mode

   If the user requests a per-project install (e.g., "install memory for this project", "project-level install", or uses `--project` flag), create directories under the current project root instead of `$HOME`:

   ```bash
   mkdir -p .gemini/hooks
   mkdir -p .gemini/commands
   mkdir -p .gemini/skills
   ```

   All subsequent copy operations in Steps 3-6 should target `.gemini/` instead of `~/.gemini/`.
   ```

2. In "Step 4: Merge Hook Configuration" (currently lines ~140-268), add a critical instruction for per-project path rewriting:

   After the merge section, before the "Validate the merge result" subsection, add:

   ```markdown
   ### Per-Project Path Rewriting

   **CRITICAL:** When performing a per-project install, the hook command paths MUST be rewritten from global (`$HOME/.gemini/hooks/memory-capture.sh`) to project-relative (`.gemini/hooks/memory-capture.sh`).

   After writing settings.json, rewrite the command paths:

   ```bash
   # For per-project installs, rewrite hook paths to project-relative
   jq '.hooks |= (if . then
     walk(if type == "object" and has("command") and (.command | contains("$HOME/.gemini/hooks/")) then
       .command = (.command | sub("\\$HOME/\\.gemini/hooks/"; ".gemini/hooks/"))
     else . end)
   else . end)' .gemini/settings.json > .gemini/settings.json.tmp \
     && mv .gemini/settings.json.tmp .gemini/settings.json
   ```

   If jq does not support `walk` (jq < 1.6), use sed as fallback:

   ```bash
   sed -i.bak 's|\$HOME/\.gemini/hooks/|.gemini/hooks/|g' .gemini/settings.json && rm -f .gemini/settings.json.bak
   ```

   Verify the rewrite:

   ```bash
   # Should show .gemini/hooks/memory-capture.sh (NOT $HOME/.gemini/hooks/...)
   grep "command" .gemini/settings.json
   ```
   ```

3. In "Step 8: Report Results" (currently lines ~365-404), add a note for per-project installs:

   In the "Installed Files" section, add a conditional note:
   ```markdown
   For per-project installs, report paths relative to the project root (`.gemini/...`) instead of `~/.gemini/...`.
   ```

4. In the Prerequisites Check (Step 1), add a jq version note after the jq check (lines ~70-78):

   ```markdown
   If jq is found, also check its version for `walk` support:

   ```bash
   if ! jq -n 'walk(.)' >/dev/null 2>&1; then
     echo "NOTE: jq $(jq --version 2>&1) does not support walk(). The hook handler will use a simplified redaction filter. Consider upgrading to jq 1.6+ for full recursive redaction."
   fi
   ```
   ```

**README.md changes -- add jq version note and clarify per-project:**

1. In the Prerequisites table (lines ~33-38), add a note to the jq row:
   Change `| jq | Yes | JSON processing in the hook handler script |`
   to `| jq | Yes | JSON processing in the hook handler script (1.6+ recommended for full redaction; 1.5 works with simplified filter) |`

2. In the "Manual: Per-Project Installation" section (lines ~100-108), replace the note about editing paths manually. Currently it says:
   ```
   Note: For per-project installs, the hook handler path in `settings.json` should reference the project-relative path. Edit the command paths from `$HOME/.gemini/hooks/memory-capture.sh` to `.gemini/hooks/memory-capture.sh` (or use `$GEMINI_PROJECT_DIR/.gemini/hooks/memory-capture.sh`).
   ```

   Replace with a concrete sed command:
   ```markdown
   After copying, rewrite hook paths from global to project-relative:

   ```bash
   # Rewrite hook paths for per-project use
   sed -i.bak 's|\$HOME/\.gemini/hooks/|.gemini/hooks/|g' .gemini/settings.json && rm -f .gemini/settings.json.bak

   # Verify paths are project-relative
   grep "command" .gemini/settings.json
   # Should show: .gemini/hooks/memory-capture.sh
   ```
   ```

3. In the Compatibility section (lines ~27-29), add jq version detail:
   After `- **jq:** Required for the hook handler script (JSON processing)` add:
   `  - jq 1.6+ recommended (full recursive redaction via `walk`). jq 1.5 is supported with a simplified non-recursive redaction filter.`

4. In the Troubleshooting section, add a new subsection after "jq not installed" (after line ~420):

   ```markdown
   ### jq version too old (redaction limited)

   **Symptom:** Hook handler works but uses simplified redaction (does not recursively strip sensitive keys from deeply nested objects).

   **Check:**

   ```bash
   jq --version
   # jq-1.5 = simplified redaction, jq-1.6+ = full recursive redaction
   ```

   **Solution:** Upgrade jq to 1.6 or later:

   ```bash
   # macOS
   brew upgrade jq

   # Debian/Ubuntu (may need a PPA for 1.6+)
   sudo apt install jq

   # Or download directly from https://jqlang.github.io/jq/
   ```
   ```

**Important constraints:**
- Do NOT rewrite existing sections wholesale. Add new subsections and modify specific lines.
- Preserve all existing content in SKILL.md and README.md that is not directly related to the 3 findings.
- The install skill is a SKILL.md (instructions for Gemini to follow), not executable code. Write instructions in natural language with code examples.
  </action>
  <verify>
```bash
# 1. Verify SKILL.md mentions per-project path rewriting
grep -q 'Per-Project Path Rewriting' plugins/memory-gemini-adapter/.gemini/skills/memory-gemini-install/SKILL.md

# 2. Verify SKILL.md has jq walk version note
grep -q 'walk' plugins/memory-gemini-adapter/.gemini/skills/memory-gemini-install/SKILL.md

# 3. Verify README mentions jq 1.6
grep -q '1\.6' plugins/memory-gemini-adapter/README.md

# 4. Verify README per-project section has sed command (not just "edit manually")
grep -q 'sed.*gemini/hooks' plugins/memory-gemini-adapter/README.md

# 5. Verify README has new troubleshooting section for jq version
grep -q 'jq version too old' plugins/memory-gemini-adapter/README.md

# 6. Verify SKILL.md YAML frontmatter is still valid (starts with ---)
head -1 plugins/memory-gemini-adapter/.gemini/skills/memory-gemini-install/SKILL.md | grep -q '^---'
```

All grep commands should find matches (exit 0).
  </verify>
  <done>
Install skill SKILL.md includes per-project path rewriting instructions with jq walk and sed fallback approaches. README.md documents jq 1.6+ recommendation, provides concrete sed command for per-project path rewriting (replacing the vague "edit manually" note), and adds a troubleshooting section for jq version issues.
  </done>
</task>

</tasks>

<verification>
Run all checks as a single validation:

```bash
# --- memory-capture.sh ---
bash -n plugins/memory-gemini-adapter/.gemini/hooks/memory-capture.sh && echo "PASS: syntax"
grep -q 'JQ_HAS_WALK' plugins/memory-gemini-adapter/.gemini/hooks/memory-capture.sh && echo "PASS: jq version detection"
grep -q 'del(.api_key' plugins/memory-gemini-adapter/.gemini/hooks/memory-capture.sh && echo "PASS: fallback redaction"
grep -q 'perl' plugins/memory-gemini-adapter/.gemini/hooks/memory-capture.sh && echo "PASS: perl ANSI strip"
grep -q 'trap fail_open' plugins/memory-gemini-adapter/.gemini/hooks/memory-capture.sh && echo "PASS: fail-open preserved"

# Dry-run tests
echo '' | MEMORY_INGEST_DRY_RUN=1 bash plugins/memory-gemini-adapter/.gemini/hooks/memory-capture.sh && echo "PASS: empty input"
echo '{"hook_event_name":"SessionStart","session_id":"s1","timestamp":"t1","cwd":"/tmp"}' | MEMORY_INGEST_DRY_RUN=1 bash plugins/memory-gemini-adapter/.gemini/hooks/memory-capture.sh && echo "PASS: valid event"

# Test with ANSI-contaminated input (OSC sequence)
printf '{"hook_event_name":"SessionStart","session_id":"s1","timestamp":"t1","cwd":"/tmp"}\x1b]8;;https://example.com\x07link\x1b]8;;\x07' | MEMORY_INGEST_DRY_RUN=1 bash plugins/memory-gemini-adapter/.gemini/hooks/memory-capture.sh && echo "PASS: OSC ANSI input"

# --- SKILL.md ---
grep -q 'Per-Project Path Rewriting' plugins/memory-gemini-adapter/.gemini/skills/memory-gemini-install/SKILL.md && echo "PASS: skill per-project"
grep -q 'walk' plugins/memory-gemini-adapter/.gemini/skills/memory-gemini-install/SKILL.md && echo "PASS: skill walk note"

# --- README.md ---
grep -q '1\.6' plugins/memory-gemini-adapter/README.md && echo "PASS: readme jq 1.6"
grep -q "sed.*gemini/hooks" plugins/memory-gemini-adapter/README.md && echo "PASS: readme sed command"
grep -q 'jq version too old' plugins/memory-gemini-adapter/README.md && echo "PASS: readme troubleshooting"
```
</verification>

<success_criteria>
1. memory-capture.sh passes `bash -n` syntax check
2. memory-capture.sh dry-run tests pass with empty, valid JSON, and ANSI-contaminated input
3. JQ_HAS_WALK detection present with conditional REDACT_FILTER assignment
4. Fallback redaction uses del() on known sensitive key names
5. ANSI stripping uses perl (CSI + OSC + other escapes) with sed fallback
6. Install skill SKILL.md documents per-project path rewriting with code examples
7. README.md documents jq 1.6+ recommendation and provides concrete per-project install commands
8. All existing functionality preserved (fail-open, event mapping, backgrounded ingest)
</success_criteria>

<output>
After completion, create `.planning/phases/21-gemini-cli-adapter/21-04-SUMMARY.md`
</output>
