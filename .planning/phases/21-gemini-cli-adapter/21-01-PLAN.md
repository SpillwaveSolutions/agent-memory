---
phase: 21-gemini-cli-adapter
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - plugins/memory-gemini-adapter/.gemini/hooks/memory-capture.sh
  - plugins/memory-gemini-adapter/.gemini/settings.json
autonomous: true

must_haves:
  truths:
    - "Gemini CLI lifecycle events are transformed into memory-ingest JSON format and piped to memory-ingest"
    - "Hook script always returns {} to stdout and exits 0, even on errors (fail-open)"
    - "Hook script backgrounds memory-ingest call to avoid blocking Gemini's synchronous hook loop"
    - "settings.json registers hooks for all 6 captured event types with correct nested structure"
    - "All events include agent:gemini tag in the payload"
  artifacts:
    - path: "plugins/memory-gemini-adapter/.gemini/hooks/memory-capture.sh"
      provides: "Shell hook handler that transforms Gemini JSON to memory-ingest format"
      min_lines: 80
    - path: "plugins/memory-gemini-adapter/.gemini/settings.json"
      provides: "Gemini CLI hook configuration for all captured event types"
      contains: "SessionStart"
  key_links:
    - from: "plugins/memory-gemini-adapter/.gemini/hooks/memory-capture.sh"
      to: "memory-ingest binary"
      via: "stdin JSON pipe (backgrounded)"
      pattern: "memory-ingest.*>/dev/null"
    - from: "plugins/memory-gemini-adapter/.gemini/settings.json"
      to: "plugins/memory-gemini-adapter/.gemini/hooks/memory-capture.sh"
      via: "command field in hook config"
      pattern: "memory-capture\\.sh"
---

<objective>
Create the Gemini CLI event capture infrastructure: a shell hook handler script that transforms Gemini lifecycle events into memory-ingest format, and the settings.json hook configuration that registers all captured event types.

Purpose: Enable Gemini CLI sessions to be captured into agent-memory with `agent:gemini` tagging, using the existing `memory-ingest` binary (same as Claude Code hooks).

Output: Working hook script + settings.json template that captures SessionStart, SessionEnd, BeforeAgent, AfterAgent, BeforeTool, and AfterTool events.
</objective>

<execution_context>
@/Users/richardhightower/.claude/get-shit-done/workflows/execute-plan.md
@/Users/richardhightower/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-gemini-cli-adapter/21-RESEARCH.md
@crates/memory-ingest/src/main.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create memory-capture.sh hook handler script</name>
  <files>plugins/memory-gemini-adapter/.gemini/hooks/memory-capture.sh</files>
  <action>
Create the shell script that serves as Gemini CLI's hook handler. This script:

1. Reads JSON from stdin (Gemini sends hook event data via stdin)
2. Extracts `hook_event_name` to determine event type
3. Maps Gemini events to memory-ingest event names:
   - SessionStart -> "SessionStart"
   - SessionEnd -> "Stop"
   - BeforeAgent -> "UserPromptSubmit" (extract `.prompt` field as `message`)
   - AfterAgent -> "AssistantResponse" (extract `.prompt_response` field as `message`)
   - BeforeTool -> "PreToolUse" (extract `.tool_name` and `.tool_input`)
   - AfterTool -> "PostToolUse" (extract `.tool_name` and `.tool_input`)
4. Builds a JSON payload with fields: `hook_event_name`, `session_id`, `timestamp`, `cwd`, `agent` (always "gemini"), and event-specific fields (`message`, `tool_name`, `tool_input`)
5. Pipes payload to `memory-ingest` in BACKGROUND with stdout/stderr redirected to /dev/null
6. Outputs exactly `{}` to stdout (Gemini expects valid JSON response)
7. Exits with code 0

Use `jq` for all JSON manipulation. The script must use `set -euo pipefail` for safety. For unknown event types, output `{}` and exit 0 (skip silently).

CRITICAL requirements from research:
- NEVER print anything to stdout except the final `{}` -- stdout pollution breaks Gemini CLI parsing
- Background the memory-ingest call: `echo "$PAYLOAD" | memory-ingest >/dev/null 2>/dev/null &`
- Always exit 0 with `{}` even if jq fails or input is malformed (fail-open)
- Use `|| true` or trap to ensure fail-open behavior even with `set -e`

Reference the research code example in 21-RESEARCH.md (Example 1) as the baseline implementation. Adapt it to wrap the main logic in a function with error trapping so that `set -e` does not prevent fail-open behavior. Add a guard at script start: if stdin is empty or jq is not available, output `{}` and exit 0 immediately.

Make the script executable (chmod +x).
  </action>
  <verify>
1. `file plugins/memory-gemini-adapter/.gemini/hooks/memory-capture.sh` shows "shell script"
2. `head -1 plugins/memory-gemini-adapter/.gemini/hooks/memory-capture.sh` shows `#!/usr/bin/env bash`
3. Script is executable: `test -x plugins/memory-gemini-adapter/.gemini/hooks/memory-capture.sh`
4. Test with simulated input:
   - `echo '{"hook_event_name":"SessionStart","session_id":"test-1","timestamp":"2026-01-30T12:00:00Z","cwd":"/tmp"}' | bash plugins/memory-gemini-adapter/.gemini/hooks/memory-capture.sh` outputs `{}`
   - `echo '{"hook_event_name":"BeforeAgent","session_id":"test-1","timestamp":"2026-01-30T12:00:00Z","cwd":"/tmp","prompt":"Hello"}' | bash plugins/memory-gemini-adapter/.gemini/hooks/memory-capture.sh` outputs `{}`
   - `echo '' | bash plugins/memory-gemini-adapter/.gemini/hooks/memory-capture.sh` outputs `{}` (empty input)
   - `echo 'not json' | bash plugins/memory-gemini-adapter/.gemini/hooks/memory-capture.sh` outputs `{}` (invalid JSON)
5. Script contains `agent.*gemini` in payload construction
6. Script contains `>/dev/null 2>/dev/null &` for backgrounding memory-ingest
  </verify>
  <done>
Hook handler script exists, is executable, handles all 6 mapped event types (SessionStart, SessionEnd, BeforeAgent, AfterAgent, BeforeTool, AfterTool), includes agent:gemini tag, backgrounds memory-ingest, and returns {} on all inputs (including malformed/empty).
  </done>
</task>

<task type="auto">
  <name>Task 2: Create settings.json hook configuration</name>
  <files>plugins/memory-gemini-adapter/.gemini/settings.json</files>
  <action>
Create the Gemini CLI hook configuration file that registers the memory-capture.sh script for all 6 captured event types.

The settings.json structure uses Gemini's nested array-of-objects format:
```json
{
  "hooks": {
    "EventName": [
      {
        "hooks": [
          {
            "name": "memory-capture-event-name",
            "type": "command",
            "command": "path/to/memory-capture.sh",
            "timeout": 5000,
            "description": "Capture event into agent-memory"
          }
        ]
      }
    ]
  }
}
```

Register hooks for these events:
1. SessionStart -- `"command": "$HOME/.gemini/hooks/memory-capture.sh"` (global install path; install skill will update)
2. SessionEnd -- same command
3. BeforeAgent -- same command
4. AfterAgent -- same command
5. BeforeTool -- add `"matcher": "*"` to the wrapper object (tool hooks require a matcher)
6. AfterTool -- add `"matcher": "*"` to the wrapper object

Use `$HOME/.gemini/hooks/memory-capture.sh` as the default command path (global install). The install skill in Plan 03 will adjust paths as needed.

Set timeout to 5000ms (5 seconds) for all hooks. This is generous since the script backgrounds memory-ingest and returns immediately.

Give each hook a unique descriptive `name` field (e.g., "memory-capture-session-start", "memory-capture-user-prompt").

Give each hook a `description` field explaining what it captures.

This file serves as both a reference template AND the actual configuration that the install skill will merge into the user's settings.json.
  </action>
  <verify>
1. `cat plugins/memory-gemini-adapter/.gemini/settings.json | jq .` succeeds (valid JSON)
2. `cat plugins/memory-gemini-adapter/.gemini/settings.json | jq '.hooks | keys | length'` outputs `6` (all 6 event types)
3. `cat plugins/memory-gemini-adapter/.gemini/settings.json | jq '.hooks.BeforeTool[0].matcher'` outputs `"*"` (matcher present for tool hooks)
4. `cat plugins/memory-gemini-adapter/.gemini/settings.json | jq '.hooks.AfterTool[0].matcher'` outputs `"*"`
5. All hook entries reference `memory-capture.sh` in the command field
  </verify>
  <done>
settings.json exists with valid JSON, registers all 6 event types (SessionStart, SessionEnd, BeforeAgent, AfterAgent, BeforeTool, AfterTool), uses correct nested array-of-objects structure, includes matcher for tool hooks, and references memory-capture.sh.
  </done>
</task>

</tasks>

<verification>
- Hook script handles all 6 Gemini event types with correct memory-ingest mapping
- Hook script is fail-open: never blocks, always returns {}, backgrounds memory-ingest
- settings.json is valid JSON with correct Gemini hook structure
- No stdout pollution from hook script (only {} output)
- Agent tag "gemini" included in all payloads
</verification>

<success_criteria>
- memory-capture.sh exists, is executable, handles all event types
- settings.json has all 6 hook registrations with correct structure
- Hook script returns {} for valid, invalid, and empty inputs
- memory-ingest call is backgrounded with output suppressed
</success_criteria>

<output>
After completion, create `.planning/phases/21-gemini-cli-adapter/21-01-SUMMARY.md`
</output>
